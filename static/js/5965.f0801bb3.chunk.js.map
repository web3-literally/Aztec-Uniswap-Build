{"version":3,"file":"static/js/5965.f0801bb3.chunk.js","mappings":"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","sources":["../node_modules/ajv/lib/ajv.ts","../node_modules/ajv/lib/compile/codegen/code.ts","../node_modules/ajv/lib/compile/codegen/index.ts","../node_modules/ajv/lib/compile/codegen/scope.ts","../node_modules/ajv/lib/compile/errors.ts","../node_modules/ajv/lib/compile/index.ts","../node_modules/ajv/lib/compile/names.ts","../node_modules/ajv/lib/compile/ref_error.ts","../node_modules/ajv/lib/compile/resolve.ts","../node_modules/ajv/lib/compile/rules.ts","../node_modules/ajv/lib/compile/util.ts","../node_modules/ajv/lib/compile/validate/applicability.ts","../node_modules/ajv/lib/compile/validate/boolSchema.ts","../node_modules/ajv/lib/compile/validate/dataType.ts","../node_modules/ajv/lib/compile/validate/defaults.ts","../node_modules/ajv/lib/compile/validate/index.ts","../node_modules/ajv/lib/compile/validate/keyword.ts","../node_modules/ajv/lib/compile/validate/subschema.ts","../node_modules/ajv/lib/core.ts","../node_modules/ajv/lib/runtime/equal.ts","../node_modules/ajv/lib/runtime/ucs2length.ts","../node_modules/ajv/lib/runtime/uri.ts","../node_modules/ajv/lib/runtime/validation_error.ts","../node_modules/ajv/lib/vocabularies/applicator/additionalItems.ts","../node_modules/ajv/lib/vocabularies/applicator/additionalProperties.ts","../node_modules/ajv/lib/vocabularies/applicator/allOf.ts","../node_modules/ajv/lib/vocabularies/applicator/anyOf.ts","../node_modules/ajv/lib/vocabularies/applicator/contains.ts","../node_modules/ajv/lib/vocabularies/applicator/dependencies.ts","../node_modules/ajv/lib/vocabularies/applicator/if.ts","../node_modules/ajv/lib/vocabularies/applicator/index.ts","../node_modules/ajv/lib/vocabularies/applicator/items.ts","../node_modules/ajv/lib/vocabularies/applicator/items2020.ts","../node_modules/ajv/lib/vocabularies/applicator/not.ts","../node_modules/ajv/lib/vocabularies/applicator/oneOf.ts","../node_modules/ajv/lib/vocabularies/applicator/patternProperties.ts","../node_modules/ajv/lib/vocabularies/applicator/prefixItems.ts","../node_modules/ajv/lib/vocabularies/applicator/properties.ts","../node_modules/ajv/lib/vocabularies/applicator/propertyNames.ts","../node_modules/ajv/lib/vocabularies/applicator/thenElse.ts","../node_modules/ajv/lib/vocabularies/code.ts","../node_modules/ajv/lib/vocabularies/core/id.ts","../node_modules/ajv/lib/vocabularies/core/index.ts","../node_modules/ajv/lib/vocabularies/core/ref.ts","../node_modules/ajv/lib/vocabularies/discriminator/index.ts","../node_modules/ajv/lib/vocabularies/discriminator/types.ts","../node_modules/ajv/lib/vocabularies/draft7.ts","../node_modules/ajv/lib/vocabularies/format/format.ts","../node_modules/ajv/lib/vocabularies/format/index.ts","../node_modules/ajv/lib/vocabularies/metadata.ts","../node_modules/ajv/lib/vocabularies/validation/const.ts","../node_modules/ajv/lib/vocabularies/validation/enum.ts","../node_modules/ajv/lib/vocabularies/validation/index.ts","../node_modules/ajv/lib/vocabularies/validation/limitItems.ts","../node_modules/ajv/lib/vocabularies/validation/limitLength.ts","../node_modules/ajv/lib/vocabularies/validation/limitNumber.ts","../node_modules/ajv/lib/vocabularies/validation/limitProperties.ts","../node_modules/ajv/lib/vocabularies/validation/multipleOf.ts","../node_modules/ajv/lib/vocabularies/validation/pattern.ts","../node_modules/ajv/lib/vocabularies/validation/required.ts","../node_modules/ajv/lib/vocabularies/validation/uniqueItems.ts","../node_modules/ajv/node_modules/json-schema-traverse/index.js","../node_modules/fast-deep-equal/index.js","../node_modules/uri-js/src/util.ts","../node_modules/uri-js/src/regexps-uri.ts","../node_modules/uri-js/src/regexps-iri.ts","../node_modules/uri-js/node_modules/punycode/punycode.es6.js","../node_modules/uri-js/src/uri.ts","../node_modules/uri-js/src/schemes/http.ts","../node_modules/uri-js/src/schemes/https.ts","../node_modules/uri-js/src/schemes/ws.ts","../node_modules/uri-js/src/schemes/wss.ts","../node_modules/uri-js/src/schemes/mailto.ts","../node_modules/uri-js/src/schemes/urn.ts","../node_modules/uri-js/src/schemes/urn-uuid.ts","../node_modules/uri-js/src/index.ts","../node_modules/@babel/runtime/helpers/taggedTemplateLiteral.js"],"sourcesContent":["import type {AnySchemaObject} from \"./types\"\nimport AjvCore from \"./core\"\nimport draft7Vocabularies from \"./vocabularies/draft7\"\nimport discriminator from \"./vocabularies/discriminator\"\nimport * as draft7MetaSchema from \"./refs/json-schema-draft-07.json\"\n\nconst META_SUPPORT_DATA = [\"/properties\"]\n\nconst META_SCHEMA_ID = \"http://json-schema.org/draft-07/schema\"\n\nclass Ajv extends AjvCore {\n  _addVocabularies(): void {\n    super._addVocabularies()\n    draft7Vocabularies.forEach((v) => this.addVocabulary(v))\n    if (this.opts.discriminator) this.addKeyword(discriminator)\n  }\n\n  _addDefaultMetaSchema(): void {\n    super._addDefaultMetaSchema()\n    if (!this.opts.meta) return\n    const metaSchema = this.opts.$data\n      ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA)\n      : draft7MetaSchema\n    this.addMetaSchema(metaSchema, META_SCHEMA_ID, false)\n    this.refs[\"http://json-schema.org/schema\"] = META_SCHEMA_ID\n  }\n\n  defaultMeta(): string | AnySchemaObject | undefined {\n    return (this.opts.defaultMeta =\n      super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : undefined))\n  }\n}\n\nmodule.exports = exports = Ajv\nObject.defineProperty(exports, \"__esModule\", {value: true})\n\nexport default Ajv\n\nexport {\n  Format,\n  FormatDefinition,\n  AsyncFormatDefinition,\n  KeywordDefinition,\n  KeywordErrorDefinition,\n  CodeKeywordDefinition,\n  MacroKeywordDefinition,\n  FuncKeywordDefinition,\n  Vocabulary,\n  Schema,\n  SchemaObject,\n  AnySchemaObject,\n  AsyncSchema,\n  AnySchema,\n  ValidateFunction,\n  AsyncValidateFunction,\n  SchemaValidateFunction,\n  ErrorObject,\n  ErrorNoParams,\n} from \"./types\"\n\nexport {Plugin, Options, CodeOptions, InstanceOptions, Logger, ErrorsTextOptions} from \"./core\"\nexport {SchemaCxt, SchemaObjCxt} from \"./compile\"\nexport {KeywordCxt} from \"./compile/validate\"\nexport {DefinedError} from \"./vocabularies/errors\"\nexport {JSONType} from \"./compile/rules\"\nexport {JSONSchemaType} from \"./types/json-schema\"\nexport {_, str, stringify, nil, Name, Code, CodeGen, CodeGenOptions} from \"./compile/codegen\"\nexport {default as ValidationError} from \"./runtime/validation_error\"\nexport {default as MissingRefError} from \"./compile/ref_error\"\n","export abstract class _CodeOrName {\n  abstract readonly str: string\n  abstract readonly names: UsedNames\n  abstract toString(): string\n  abstract emptyStr(): boolean\n}\n\nexport const IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i\n\nexport class Name extends _CodeOrName {\n  readonly str: string\n  constructor(s: string) {\n    super()\n    if (!IDENTIFIER.test(s)) throw new Error(\"CodeGen: name must be a valid identifier\")\n    this.str = s\n  }\n\n  toString(): string {\n    return this.str\n  }\n\n  emptyStr(): boolean {\n    return false\n  }\n\n  get names(): UsedNames {\n    return {[this.str]: 1}\n  }\n}\n\nexport class _Code extends _CodeOrName {\n  readonly _items: readonly CodeItem[]\n  private _str?: string\n  private _names?: UsedNames\n\n  constructor(code: string | readonly CodeItem[]) {\n    super()\n    this._items = typeof code === \"string\" ? [code] : code\n  }\n\n  toString(): string {\n    return this.str\n  }\n\n  emptyStr(): boolean {\n    if (this._items.length > 1) return false\n    const item = this._items[0]\n    return item === \"\" || item === '\"\"'\n  }\n\n  get str(): string {\n    return (this._str ??= this._items.reduce((s: string, c: CodeItem) => `${s}${c}`, \"\"))\n  }\n\n  get names(): UsedNames {\n    return (this._names ??= this._items.reduce((names: UsedNames, c) => {\n      if (c instanceof Name) names[c.str] = (names[c.str] || 0) + 1\n      return names\n    }, {}))\n  }\n}\n\nexport type CodeItem = Name | string | number | boolean | null\n\nexport type UsedNames = Record<string, number | undefined>\n\nexport type Code = _Code | Name\n\nexport type SafeExpr = Code | number | boolean | null\n\nexport const nil = new _Code(\"\")\n\ntype CodeArg = SafeExpr | string | undefined\n\nexport function _(strs: TemplateStringsArray, ...args: CodeArg[]): _Code {\n  const code: CodeItem[] = [strs[0]]\n  let i = 0\n  while (i < args.length) {\n    addCodeArg(code, args[i])\n    code.push(strs[++i])\n  }\n  return new _Code(code)\n}\n\nconst plus = new _Code(\"+\")\n\nexport function str(strs: TemplateStringsArray, ...args: (CodeArg | string[])[]): _Code {\n  const expr: CodeItem[] = [safeStringify(strs[0])]\n  let i = 0\n  while (i < args.length) {\n    expr.push(plus)\n    addCodeArg(expr, args[i])\n    expr.push(plus, safeStringify(strs[++i]))\n  }\n  optimize(expr)\n  return new _Code(expr)\n}\n\nexport function addCodeArg(code: CodeItem[], arg: CodeArg | string[]): void {\n  if (arg instanceof _Code) code.push(...arg._items)\n  else if (arg instanceof Name) code.push(arg)\n  else code.push(interpolate(arg))\n}\n\nfunction optimize(expr: CodeItem[]): void {\n  let i = 1\n  while (i < expr.length - 1) {\n    if (expr[i] === plus) {\n      const res = mergeExprItems(expr[i - 1], expr[i + 1])\n      if (res !== undefined) {\n        expr.splice(i - 1, 3, res)\n        continue\n      }\n      expr[i++] = \"+\"\n    }\n    i++\n  }\n}\n\nfunction mergeExprItems(a: CodeItem, b: CodeItem): CodeItem | undefined {\n  if (b === '\"\"') return a\n  if (a === '\"\"') return b\n  if (typeof a == \"string\") {\n    if (b instanceof Name || a[a.length - 1] !== '\"') return\n    if (typeof b != \"string\") return `${a.slice(0, -1)}${b}\"`\n    if (b[0] === '\"') return a.slice(0, -1) + b.slice(1)\n    return\n  }\n  if (typeof b == \"string\" && b[0] === '\"' && !(a instanceof Name)) return `\"${a}${b.slice(1)}`\n  return\n}\n\nexport function strConcat(c1: Code, c2: Code): Code {\n  return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str`${c1}${c2}`\n}\n\n// TODO do not allow arrays here\nfunction interpolate(x?: string | string[] | number | boolean | null): SafeExpr | string {\n  return typeof x == \"number\" || typeof x == \"boolean\" || x === null\n    ? x\n    : safeStringify(Array.isArray(x) ? x.join(\",\") : x)\n}\n\nexport function stringify(x: unknown): Code {\n  return new _Code(safeStringify(x))\n}\n\nexport function safeStringify(x: unknown): string {\n  return JSON.stringify(x)\n    .replace(/\\u2028/g, \"\\\\u2028\")\n    .replace(/\\u2029/g, \"\\\\u2029\")\n}\n\nexport function getProperty(key: Code | string | number): Code {\n  return typeof key == \"string\" && IDENTIFIER.test(key) ? new _Code(`.${key}`) : _`[${key}]`\n}\n\n//Does best effort to format the name properly\nexport function getEsmExportName(key: Code | string | number): Code {\n  if (typeof key == \"string\" && IDENTIFIER.test(key)) {\n    return new _Code(`${key}`)\n  }\n  throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`)\n}\n\nexport function regexpCode(rx: RegExp): Code {\n  return new _Code(rx.toString())\n}\n","import type {ScopeValueSets, NameValue, ValueScope, ValueScopeName} from \"./scope\"\nimport {_, nil, _Code, Code, Name, UsedNames, CodeItem, addCodeArg, _CodeOrName} from \"./code\"\nimport {Scope, varKinds} from \"./scope\"\n\nexport {_, str, strConcat, nil, getProperty, stringify, regexpCode, Name, Code} from \"./code\"\nexport {Scope, ScopeStore, ValueScope, ValueScopeName, ScopeValueSets, varKinds} from \"./scope\"\n\n// type for expressions that can be safely inserted in code without quotes\nexport type SafeExpr = Code | number | boolean | null\n\n// type that is either Code of function that adds code to CodeGen instance using its methods\nexport type Block = Code | (() => void)\n\nexport const operators = {\n  GT: new _Code(\">\"),\n  GTE: new _Code(\">=\"),\n  LT: new _Code(\"<\"),\n  LTE: new _Code(\"<=\"),\n  EQ: new _Code(\"===\"),\n  NEQ: new _Code(\"!==\"),\n  NOT: new _Code(\"!\"),\n  OR: new _Code(\"||\"),\n  AND: new _Code(\"&&\"),\n  ADD: new _Code(\"+\"),\n}\n\nabstract class Node {\n  abstract readonly names: UsedNames\n\n  optimizeNodes(): this | ChildNode | ChildNode[] | undefined {\n    return this\n  }\n\n  optimizeNames(_names: UsedNames, _constants: Constants): this | undefined {\n    return this\n  }\n\n  // get count(): number {\n  //   return 1\n  // }\n}\n\nclass Def extends Node {\n  constructor(private readonly varKind: Name, private readonly name: Name, private rhs?: SafeExpr) {\n    super()\n  }\n\n  render({es5, _n}: CGOptions): string {\n    const varKind = es5 ? varKinds.var : this.varKind\n    const rhs = this.rhs === undefined ? \"\" : ` = ${this.rhs}`\n    return `${varKind} ${this.name}${rhs};` + _n\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    if (!names[this.name.str]) return\n    if (this.rhs) this.rhs = optimizeExpr(this.rhs, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    return this.rhs instanceof _CodeOrName ? this.rhs.names : {}\n  }\n}\n\nclass Assign extends Node {\n  constructor(readonly lhs: Code, public rhs: SafeExpr, private readonly sideEffects?: boolean) {\n    super()\n  }\n\n  render({_n}: CGOptions): string {\n    return `${this.lhs} = ${this.rhs};` + _n\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    if (this.lhs instanceof Name && !names[this.lhs.str] && !this.sideEffects) return\n    this.rhs = optimizeExpr(this.rhs, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    const names = this.lhs instanceof Name ? {} : {...this.lhs.names}\n    return addExprNames(names, this.rhs)\n  }\n}\n\nclass AssignOp extends Assign {\n  constructor(lhs: Code, private readonly op: Code, rhs: SafeExpr, sideEffects?: boolean) {\n    super(lhs, rhs, sideEffects)\n  }\n\n  render({_n}: CGOptions): string {\n    return `${this.lhs} ${this.op}= ${this.rhs};` + _n\n  }\n}\n\nclass Label extends Node {\n  readonly names: UsedNames = {}\n  constructor(readonly label: Name) {\n    super()\n  }\n\n  render({_n}: CGOptions): string {\n    return `${this.label}:` + _n\n  }\n}\n\nclass Break extends Node {\n  readonly names: UsedNames = {}\n  constructor(readonly label?: Code) {\n    super()\n  }\n\n  render({_n}: CGOptions): string {\n    const label = this.label ? ` ${this.label}` : \"\"\n    return `break${label};` + _n\n  }\n}\n\nclass Throw extends Node {\n  constructor(readonly error: Code) {\n    super()\n  }\n\n  render({_n}: CGOptions): string {\n    return `throw ${this.error};` + _n\n  }\n\n  get names(): UsedNames {\n    return this.error.names\n  }\n}\n\nclass AnyCode extends Node {\n  constructor(private code: SafeExpr) {\n    super()\n  }\n\n  render({_n}: CGOptions): string {\n    return `${this.code};` + _n\n  }\n\n  optimizeNodes(): this | undefined {\n    return `${this.code}` ? this : undefined\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this {\n    this.code = optimizeExpr(this.code, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    return this.code instanceof _CodeOrName ? this.code.names : {}\n  }\n}\n\nabstract class ParentNode extends Node {\n  constructor(readonly nodes: ChildNode[] = []) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    return this.nodes.reduce((code, n) => code + n.render(opts), \"\")\n  }\n\n  optimizeNodes(): this | ChildNode | ChildNode[] | undefined {\n    const {nodes} = this\n    let i = nodes.length\n    while (i--) {\n      const n = nodes[i].optimizeNodes()\n      if (Array.isArray(n)) nodes.splice(i, 1, ...n)\n      else if (n) nodes[i] = n\n      else nodes.splice(i, 1)\n    }\n    return nodes.length > 0 ? this : undefined\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    const {nodes} = this\n    let i = nodes.length\n    while (i--) {\n      // iterating backwards improves 1-pass optimization\n      const n = nodes[i]\n      if (n.optimizeNames(names, constants)) continue\n      subtractNames(names, n.names)\n      nodes.splice(i, 1)\n    }\n    return nodes.length > 0 ? this : undefined\n  }\n\n  get names(): UsedNames {\n    return this.nodes.reduce((names: UsedNames, n) => addNames(names, n.names), {})\n  }\n\n  // get count(): number {\n  //   return this.nodes.reduce((c, n) => c + n.count, 1)\n  // }\n}\n\nabstract class BlockNode extends ParentNode {\n  render(opts: CGOptions): string {\n    return \"{\" + opts._n + super.render(opts) + \"}\" + opts._n\n  }\n}\n\nclass Root extends ParentNode {}\n\nclass Else extends BlockNode {\n  static readonly kind = \"else\"\n}\n\nclass If extends BlockNode {\n  static readonly kind = \"if\"\n  else?: If | Else\n  constructor(private condition: Code | boolean, nodes?: ChildNode[]) {\n    super(nodes)\n  }\n\n  render(opts: CGOptions): string {\n    let code = `if(${this.condition})` + super.render(opts)\n    if (this.else) code += \"else \" + this.else.render(opts)\n    return code\n  }\n\n  optimizeNodes(): If | ChildNode[] | undefined {\n    super.optimizeNodes()\n    const cond = this.condition\n    if (cond === true) return this.nodes // else is ignored here\n    let e = this.else\n    if (e) {\n      const ns = e.optimizeNodes()\n      e = this.else = Array.isArray(ns) ? new Else(ns) : (ns as Else | undefined)\n    }\n    if (e) {\n      if (cond === false) return e instanceof If ? e : e.nodes\n      if (this.nodes.length) return this\n      return new If(not(cond), e instanceof If ? [e] : e.nodes)\n    }\n    if (cond === false || !this.nodes.length) return undefined\n    return this\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    this.else = this.else?.optimizeNames(names, constants)\n    if (!(super.optimizeNames(names, constants) || this.else)) return\n    this.condition = optimizeExpr(this.condition, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    const names = super.names\n    addExprNames(names, this.condition)\n    if (this.else) addNames(names, this.else.names)\n    return names\n  }\n\n  // get count(): number {\n  //   return super.count + (this.else?.count || 0)\n  // }\n}\n\nabstract class For extends BlockNode {\n  static readonly kind = \"for\"\n}\n\nclass ForLoop extends For {\n  constructor(private iteration: Code) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    return `for(${this.iteration})` + super.render(opts)\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    if (!super.optimizeNames(names, constants)) return\n    this.iteration = optimizeExpr(this.iteration, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    return addNames(super.names, this.iteration.names)\n  }\n}\n\nclass ForRange extends For {\n  constructor(\n    private readonly varKind: Name,\n    private readonly name: Name,\n    private readonly from: SafeExpr,\n    private readonly to: SafeExpr\n  ) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    const varKind = opts.es5 ? varKinds.var : this.varKind\n    const {name, from, to} = this\n    return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts)\n  }\n\n  get names(): UsedNames {\n    const names = addExprNames(super.names, this.from)\n    return addExprNames(names, this.to)\n  }\n}\n\nclass ForIter extends For {\n  constructor(\n    private readonly loop: \"of\" | \"in\",\n    private readonly varKind: Name,\n    private readonly name: Name,\n    private iterable: Code\n  ) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts)\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    if (!super.optimizeNames(names, constants)) return\n    this.iterable = optimizeExpr(this.iterable, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    return addNames(super.names, this.iterable.names)\n  }\n}\n\nclass Func extends BlockNode {\n  static readonly kind = \"func\"\n  constructor(public name: Name, public args: Code, public async?: boolean) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    const _async = this.async ? \"async \" : \"\"\n    return `${_async}function ${this.name}(${this.args})` + super.render(opts)\n  }\n}\n\nclass Return extends ParentNode {\n  static readonly kind = \"return\"\n\n  render(opts: CGOptions): string {\n    return \"return \" + super.render(opts)\n  }\n}\n\nclass Try extends BlockNode {\n  catch?: Catch\n  finally?: Finally\n\n  render(opts: CGOptions): string {\n    let code = \"try\" + super.render(opts)\n    if (this.catch) code += this.catch.render(opts)\n    if (this.finally) code += this.finally.render(opts)\n    return code\n  }\n\n  optimizeNodes(): this {\n    super.optimizeNodes()\n    this.catch?.optimizeNodes() as Catch | undefined\n    this.finally?.optimizeNodes() as Finally | undefined\n    return this\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this {\n    super.optimizeNames(names, constants)\n    this.catch?.optimizeNames(names, constants)\n    this.finally?.optimizeNames(names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    const names = super.names\n    if (this.catch) addNames(names, this.catch.names)\n    if (this.finally) addNames(names, this.finally.names)\n    return names\n  }\n\n  // get count(): number {\n  //   return super.count + (this.catch?.count || 0) + (this.finally?.count || 0)\n  // }\n}\n\nclass Catch extends BlockNode {\n  static readonly kind = \"catch\"\n  constructor(readonly error: Name) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    return `catch(${this.error})` + super.render(opts)\n  }\n}\n\nclass Finally extends BlockNode {\n  static readonly kind = \"finally\"\n  render(opts: CGOptions): string {\n    return \"finally\" + super.render(opts)\n  }\n}\n\ntype StartBlockNode = If | For | Func | Return | Try\n\ntype LeafNode = Def | Assign | Label | Break | Throw | AnyCode\n\ntype ChildNode = StartBlockNode | LeafNode\n\ntype EndBlockNodeType =\n  | typeof If\n  | typeof Else\n  | typeof For\n  | typeof Func\n  | typeof Return\n  | typeof Catch\n  | typeof Finally\n\ntype Constants = Record<string, SafeExpr | undefined>\n\nexport interface CodeGenOptions {\n  es5?: boolean\n  lines?: boolean\n  ownProperties?: boolean\n}\n\ninterface CGOptions extends CodeGenOptions {\n  _n: \"\\n\" | \"\"\n}\n\nexport class CodeGen {\n  readonly _scope: Scope\n  readonly _extScope: ValueScope\n  readonly _values: ScopeValueSets = {}\n  private readonly _nodes: ParentNode[]\n  private readonly _blockStarts: number[] = []\n  private readonly _constants: Constants = {}\n  private readonly opts: CGOptions\n\n  constructor(extScope: ValueScope, opts: CodeGenOptions = {}) {\n    this.opts = {...opts, _n: opts.lines ? \"\\n\" : \"\"}\n    this._extScope = extScope\n    this._scope = new Scope({parent: extScope})\n    this._nodes = [new Root()]\n  }\n\n  toString(): string {\n    return this._root.render(this.opts)\n  }\n\n  // returns unique name in the internal scope\n  name(prefix: string): Name {\n    return this._scope.name(prefix)\n  }\n\n  // reserves unique name in the external scope\n  scopeName(prefix: string): ValueScopeName {\n    return this._extScope.name(prefix)\n  }\n\n  // reserves unique name in the external scope and assigns value to it\n  scopeValue(prefixOrName: ValueScopeName | string, value: NameValue): Name {\n    const name = this._extScope.value(prefixOrName, value)\n    const vs = this._values[name.prefix] || (this._values[name.prefix] = new Set())\n    vs.add(name)\n    return name\n  }\n\n  getScopeValue(prefix: string, keyOrRef: unknown): ValueScopeName | undefined {\n    return this._extScope.getValue(prefix, keyOrRef)\n  }\n\n  // return code that assigns values in the external scope to the names that are used internally\n  // (same names that were returned by gen.scopeName or gen.scopeValue)\n  scopeRefs(scopeName: Name): Code {\n    return this._extScope.scopeRefs(scopeName, this._values)\n  }\n\n  scopeCode(): Code {\n    return this._extScope.scopeCode(this._values)\n  }\n\n  private _def(\n    varKind: Name,\n    nameOrPrefix: Name | string,\n    rhs?: SafeExpr,\n    constant?: boolean\n  ): Name {\n    const name = this._scope.toName(nameOrPrefix)\n    if (rhs !== undefined && constant) this._constants[name.str] = rhs\n    this._leafNode(new Def(varKind, name, rhs))\n    return name\n  }\n\n  // `const` declaration (`var` in es5 mode)\n  const(nameOrPrefix: Name | string, rhs: SafeExpr, _constant?: boolean): Name {\n    return this._def(varKinds.const, nameOrPrefix, rhs, _constant)\n  }\n\n  // `let` declaration with optional assignment (`var` in es5 mode)\n  let(nameOrPrefix: Name | string, rhs?: SafeExpr, _constant?: boolean): Name {\n    return this._def(varKinds.let, nameOrPrefix, rhs, _constant)\n  }\n\n  // `var` declaration with optional assignment\n  var(nameOrPrefix: Name | string, rhs?: SafeExpr, _constant?: boolean): Name {\n    return this._def(varKinds.var, nameOrPrefix, rhs, _constant)\n  }\n\n  // assignment code\n  assign(lhs: Code, rhs: SafeExpr, sideEffects?: boolean): CodeGen {\n    return this._leafNode(new Assign(lhs, rhs, sideEffects))\n  }\n\n  // `+=` code\n  add(lhs: Code, rhs: SafeExpr): CodeGen {\n    return this._leafNode(new AssignOp(lhs, operators.ADD, rhs))\n  }\n\n  // appends passed SafeExpr to code or executes Block\n  code(c: Block | SafeExpr): CodeGen {\n    if (typeof c == \"function\") c()\n    else if (c !== nil) this._leafNode(new AnyCode(c))\n    return this\n  }\n\n  // returns code for object literal for the passed argument list of key-value pairs\n  object(...keyValues: [Name | string, SafeExpr | string][]): _Code {\n    const code: CodeItem[] = [\"{\"]\n    for (const [key, value] of keyValues) {\n      if (code.length > 1) code.push(\",\")\n      code.push(key)\n      if (key !== value || this.opts.es5) {\n        code.push(\":\")\n        addCodeArg(code, value)\n      }\n    }\n    code.push(\"}\")\n    return new _Code(code)\n  }\n\n  // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)\n  if(condition: Code | boolean, thenBody?: Block, elseBody?: Block): CodeGen {\n    this._blockNode(new If(condition))\n\n    if (thenBody && elseBody) {\n      this.code(thenBody).else().code(elseBody).endIf()\n    } else if (thenBody) {\n      this.code(thenBody).endIf()\n    } else if (elseBody) {\n      throw new Error('CodeGen: \"else\" body without \"then\" body')\n    }\n    return this\n  }\n\n  // `else if` clause - invalid without `if` or after `else` clauses\n  elseIf(condition: Code | boolean): CodeGen {\n    return this._elseNode(new If(condition))\n  }\n\n  // `else` clause - only valid after `if` or `else if` clauses\n  else(): CodeGen {\n    return this._elseNode(new Else())\n  }\n\n  // end `if` statement (needed if gen.if was used only with condition)\n  endIf(): CodeGen {\n    return this._endBlockNode(If, Else)\n  }\n\n  private _for(node: For, forBody?: Block): CodeGen {\n    this._blockNode(node)\n    if (forBody) this.code(forBody).endFor()\n    return this\n  }\n\n  // a generic `for` clause (or statement if `forBody` is passed)\n  for(iteration: Code, forBody?: Block): CodeGen {\n    return this._for(new ForLoop(iteration), forBody)\n  }\n\n  // `for` statement for a range of values\n  forRange(\n    nameOrPrefix: Name | string,\n    from: SafeExpr,\n    to: SafeExpr,\n    forBody: (index: Name) => void,\n    varKind: Code = this.opts.es5 ? varKinds.var : varKinds.let\n  ): CodeGen {\n    const name = this._scope.toName(nameOrPrefix)\n    return this._for(new ForRange(varKind, name, from, to), () => forBody(name))\n  }\n\n  // `for-of` statement (in es5 mode replace with a normal for loop)\n  forOf(\n    nameOrPrefix: Name | string,\n    iterable: Code,\n    forBody: (item: Name) => void,\n    varKind: Code = varKinds.const\n  ): CodeGen {\n    const name = this._scope.toName(nameOrPrefix)\n    if (this.opts.es5) {\n      const arr = iterable instanceof Name ? iterable : this.var(\"_arr\", iterable)\n      return this.forRange(\"_i\", 0, _`${arr}.length`, (i) => {\n        this.var(name, _`${arr}[${i}]`)\n        forBody(name)\n      })\n    }\n    return this._for(new ForIter(\"of\", varKind, name, iterable), () => forBody(name))\n  }\n\n  // `for-in` statement.\n  // With option `ownProperties` replaced with a `for-of` loop for object keys\n  forIn(\n    nameOrPrefix: Name | string,\n    obj: Code,\n    forBody: (item: Name) => void,\n    varKind: Code = this.opts.es5 ? varKinds.var : varKinds.const\n  ): CodeGen {\n    if (this.opts.ownProperties) {\n      return this.forOf(nameOrPrefix, _`Object.keys(${obj})`, forBody)\n    }\n    const name = this._scope.toName(nameOrPrefix)\n    return this._for(new ForIter(\"in\", varKind, name, obj), () => forBody(name))\n  }\n\n  // end `for` loop\n  endFor(): CodeGen {\n    return this._endBlockNode(For)\n  }\n\n  // `label` statement\n  label(label: Name): CodeGen {\n    return this._leafNode(new Label(label))\n  }\n\n  // `break` statement\n  break(label?: Code): CodeGen {\n    return this._leafNode(new Break(label))\n  }\n\n  // `return` statement\n  return(value: Block | SafeExpr): CodeGen {\n    const node = new Return()\n    this._blockNode(node)\n    this.code(value)\n    if (node.nodes.length !== 1) throw new Error('CodeGen: \"return\" should have one node')\n    return this._endBlockNode(Return)\n  }\n\n  // `try` statement\n  try(tryBody: Block, catchCode?: (e: Name) => void, finallyCode?: Block): CodeGen {\n    if (!catchCode && !finallyCode) throw new Error('CodeGen: \"try\" without \"catch\" and \"finally\"')\n    const node = new Try()\n    this._blockNode(node)\n    this.code(tryBody)\n    if (catchCode) {\n      const error = this.name(\"e\")\n      this._currNode = node.catch = new Catch(error)\n      catchCode(error)\n    }\n    if (finallyCode) {\n      this._currNode = node.finally = new Finally()\n      this.code(finallyCode)\n    }\n    return this._endBlockNode(Catch, Finally)\n  }\n\n  // `throw` statement\n  throw(error: Code): CodeGen {\n    return this._leafNode(new Throw(error))\n  }\n\n  // start self-balancing block\n  block(body?: Block, nodeCount?: number): CodeGen {\n    this._blockStarts.push(this._nodes.length)\n    if (body) this.code(body).endBlock(nodeCount)\n    return this\n  }\n\n  // end the current self-balancing block\n  endBlock(nodeCount?: number): CodeGen {\n    const len = this._blockStarts.pop()\n    if (len === undefined) throw new Error(\"CodeGen: not in self-balancing block\")\n    const toClose = this._nodes.length - len\n    if (toClose < 0 || (nodeCount !== undefined && toClose !== nodeCount)) {\n      throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`)\n    }\n    this._nodes.length = len\n    return this\n  }\n\n  // `function` heading (or definition if funcBody is passed)\n  func(name: Name, args: Code = nil, async?: boolean, funcBody?: Block): CodeGen {\n    this._blockNode(new Func(name, args, async))\n    if (funcBody) this.code(funcBody).endFunc()\n    return this\n  }\n\n  // end function definition\n  endFunc(): CodeGen {\n    return this._endBlockNode(Func)\n  }\n\n  optimize(n = 1): void {\n    while (n-- > 0) {\n      this._root.optimizeNodes()\n      this._root.optimizeNames(this._root.names, this._constants)\n    }\n  }\n\n  private _leafNode(node: LeafNode): CodeGen {\n    this._currNode.nodes.push(node)\n    return this\n  }\n\n  private _blockNode(node: StartBlockNode): void {\n    this._currNode.nodes.push(node)\n    this._nodes.push(node)\n  }\n\n  private _endBlockNode(N1: EndBlockNodeType, N2?: EndBlockNodeType): CodeGen {\n    const n = this._currNode\n    if (n instanceof N1 || (N2 && n instanceof N2)) {\n      this._nodes.pop()\n      return this\n    }\n    throw new Error(`CodeGen: not in block \"${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}\"`)\n  }\n\n  private _elseNode(node: If | Else): CodeGen {\n    const n = this._currNode\n    if (!(n instanceof If)) {\n      throw new Error('CodeGen: \"else\" without \"if\"')\n    }\n    this._currNode = n.else = node\n    return this\n  }\n\n  private get _root(): Root {\n    return this._nodes[0] as Root\n  }\n\n  private get _currNode(): ParentNode {\n    const ns = this._nodes\n    return ns[ns.length - 1]\n  }\n\n  private set _currNode(node: ParentNode) {\n    const ns = this._nodes\n    ns[ns.length - 1] = node\n  }\n\n  // get nodeCount(): number {\n  //   return this._root.count\n  // }\n}\n\nfunction addNames(names: UsedNames, from: UsedNames): UsedNames {\n  for (const n in from) names[n] = (names[n] || 0) + (from[n] || 0)\n  return names\n}\n\nfunction addExprNames(names: UsedNames, from: SafeExpr): UsedNames {\n  return from instanceof _CodeOrName ? addNames(names, from.names) : names\n}\n\nfunction optimizeExpr<T extends SafeExpr | Code>(expr: T, names: UsedNames, constants: Constants): T\nfunction optimizeExpr(expr: SafeExpr, names: UsedNames, constants: Constants): SafeExpr {\n  if (expr instanceof Name) return replaceName(expr)\n  if (!canOptimize(expr)) return expr\n  return new _Code(\n    expr._items.reduce((items: CodeItem[], c: SafeExpr | string) => {\n      if (c instanceof Name) c = replaceName(c)\n      if (c instanceof _Code) items.push(...c._items)\n      else items.push(c)\n      return items\n    }, [])\n  )\n\n  function replaceName(n: Name): SafeExpr {\n    const c = constants[n.str]\n    if (c === undefined || names[n.str] !== 1) return n\n    delete names[n.str]\n    return c\n  }\n\n  function canOptimize(e: SafeExpr): e is _Code {\n    return (\n      e instanceof _Code &&\n      e._items.some(\n        (c) => c instanceof Name && names[c.str] === 1 && constants[c.str] !== undefined\n      )\n    )\n  }\n}\n\nfunction subtractNames(names: UsedNames, from: UsedNames): void {\n  for (const n in from) names[n] = (names[n] || 0) - (from[n] || 0)\n}\n\nexport function not<T extends Code | SafeExpr>(x: T): T\nexport function not(x: Code | SafeExpr): Code | SafeExpr {\n  return typeof x == \"boolean\" || typeof x == \"number\" || x === null ? !x : _`!${par(x)}`\n}\n\nconst andCode = mappend(operators.AND)\n\n// boolean AND (&&) expression with the passed arguments\nexport function and(...args: Code[]): Code {\n  return args.reduce(andCode)\n}\n\nconst orCode = mappend(operators.OR)\n\n// boolean OR (||) expression with the passed arguments\nexport function or(...args: Code[]): Code {\n  return args.reduce(orCode)\n}\n\ntype MAppend = (x: Code, y: Code) => Code\n\nfunction mappend(op: Code): MAppend {\n  return (x, y) => (x === nil ? y : y === nil ? x : _`${par(x)} ${op} ${par(y)}`)\n}\n\nfunction par(x: Code): Code {\n  return x instanceof Name ? x : _`(${x})`\n}\n","import {_, nil, Code, Name} from \"./code\"\n\ninterface NameGroup {\n  prefix: string\n  index: number\n}\n\nexport interface NameValue {\n  ref: ValueReference // this is the reference to any value that can be referred to from generated code via `globals` var in the closure\n  key?: unknown // any key to identify a global to avoid duplicates, if not passed ref is used\n  code?: Code // this is the code creating the value needed for standalone code wit_out closure - can be a primitive value, function or import (`require`)\n}\n\nexport type ValueReference = unknown // possibly make CodeGen parameterized type on this type\n\nclass ValueError extends Error {\n  readonly value?: NameValue\n  constructor(name: ValueScopeName) {\n    super(`CodeGen: \"code\" for ${name} not defined`)\n    this.value = name.value\n  }\n}\n\ninterface ScopeOptions {\n  prefixes?: Set<string>\n  parent?: Scope\n}\n\ninterface ValueScopeOptions extends ScopeOptions {\n  scope: ScopeStore\n  es5?: boolean\n  lines?: boolean\n}\n\nexport type ScopeStore = Record<string, ValueReference[] | undefined>\n\ntype ScopeValues = {\n  [Prefix in string]?: Map<unknown, ValueScopeName>\n}\n\nexport type ScopeValueSets = {\n  [Prefix in string]?: Set<ValueScopeName>\n}\n\nexport enum UsedValueState {\n  Started,\n  Completed,\n}\n\nexport type UsedScopeValues = {\n  [Prefix in string]?: Map<ValueScopeName, UsedValueState | undefined>\n}\n\nexport const varKinds = {\n  const: new Name(\"const\"),\n  let: new Name(\"let\"),\n  var: new Name(\"var\"),\n}\n\nexport class Scope {\n  protected readonly _names: {[Prefix in string]?: NameGroup} = {}\n  protected readonly _prefixes?: Set<string>\n  protected readonly _parent?: Scope\n\n  constructor({prefixes, parent}: ScopeOptions = {}) {\n    this._prefixes = prefixes\n    this._parent = parent\n  }\n\n  toName(nameOrPrefix: Name | string): Name {\n    return nameOrPrefix instanceof Name ? nameOrPrefix : this.name(nameOrPrefix)\n  }\n\n  name(prefix: string): Name {\n    return new Name(this._newName(prefix))\n  }\n\n  protected _newName(prefix: string): string {\n    const ng = this._names[prefix] || this._nameGroup(prefix)\n    return `${prefix}${ng.index++}`\n  }\n\n  private _nameGroup(prefix: string): NameGroup {\n    if (this._parent?._prefixes?.has(prefix) || (this._prefixes && !this._prefixes.has(prefix))) {\n      throw new Error(`CodeGen: prefix \"${prefix}\" is not allowed in this scope`)\n    }\n    return (this._names[prefix] = {prefix, index: 0})\n  }\n}\n\ninterface ScopePath {\n  property: string\n  itemIndex: number\n}\n\nexport class ValueScopeName extends Name {\n  readonly prefix: string\n  value?: NameValue\n  scopePath?: Code\n\n  constructor(prefix: string, nameStr: string) {\n    super(nameStr)\n    this.prefix = prefix\n  }\n\n  setValue(value: NameValue, {property, itemIndex}: ScopePath): void {\n    this.value = value\n    this.scopePath = _`.${new Name(property)}[${itemIndex}]`\n  }\n}\n\ninterface VSOptions extends ValueScopeOptions {\n  _n: Code\n}\n\nconst line = _`\\n`\n\nexport class ValueScope extends Scope {\n  protected readonly _values: ScopeValues = {}\n  protected readonly _scope: ScopeStore\n  readonly opts: VSOptions\n\n  constructor(opts: ValueScopeOptions) {\n    super(opts)\n    this._scope = opts.scope\n    this.opts = {...opts, _n: opts.lines ? line : nil}\n  }\n\n  get(): ScopeStore {\n    return this._scope\n  }\n\n  name(prefix: string): ValueScopeName {\n    return new ValueScopeName(prefix, this._newName(prefix))\n  }\n\n  value(nameOrPrefix: ValueScopeName | string, value: NameValue): ValueScopeName {\n    if (value.ref === undefined) throw new Error(\"CodeGen: ref must be passed in value\")\n    const name = this.toName(nameOrPrefix) as ValueScopeName\n    const {prefix} = name\n    const valueKey = value.key ?? value.ref\n    let vs = this._values[prefix]\n    if (vs) {\n      const _name = vs.get(valueKey)\n      if (_name) return _name\n    } else {\n      vs = this._values[prefix] = new Map()\n    }\n    vs.set(valueKey, name)\n\n    const s = this._scope[prefix] || (this._scope[prefix] = [])\n    const itemIndex = s.length\n    s[itemIndex] = value.ref\n    name.setValue(value, {property: prefix, itemIndex})\n    return name\n  }\n\n  getValue(prefix: string, keyOrRef: unknown): ValueScopeName | undefined {\n    const vs = this._values[prefix]\n    if (!vs) return\n    return vs.get(keyOrRef)\n  }\n\n  scopeRefs(scopeName: Name, values: ScopeValues | ScopeValueSets = this._values): Code {\n    return this._reduceValues(values, (name: ValueScopeName) => {\n      if (name.scopePath === undefined) throw new Error(`CodeGen: name \"${name}\" has no value`)\n      return _`${scopeName}${name.scopePath}`\n    })\n  }\n\n  scopeCode(\n    values: ScopeValues | ScopeValueSets = this._values,\n    usedValues?: UsedScopeValues,\n    getCode?: (n: ValueScopeName) => Code | undefined\n  ): Code {\n    return this._reduceValues(\n      values,\n      (name: ValueScopeName) => {\n        if (name.value === undefined) throw new Error(`CodeGen: name \"${name}\" has no value`)\n        return name.value.code\n      },\n      usedValues,\n      getCode\n    )\n  }\n\n  private _reduceValues(\n    values: ScopeValues | ScopeValueSets,\n    valueCode: (n: ValueScopeName) => Code | undefined,\n    usedValues: UsedScopeValues = {},\n    getCode?: (n: ValueScopeName) => Code | undefined\n  ): Code {\n    let code: Code = nil\n    for (const prefix in values) {\n      const vs = values[prefix]\n      if (!vs) continue\n      const nameSet = (usedValues[prefix] = usedValues[prefix] || new Map())\n      vs.forEach((name: ValueScopeName) => {\n        if (nameSet.has(name)) return\n        nameSet.set(name, UsedValueState.Started)\n        let c = valueCode(name)\n        if (c) {\n          const def = this.opts.es5 ? varKinds.var : varKinds.const\n          code = _`${code}${def} ${name} = ${c};${this.opts._n}`\n        } else if ((c = getCode?.(name))) {\n          code = _`${code}${c}${this.opts._n}`\n        } else {\n          throw new ValueError(name)\n        }\n        nameSet.set(name, UsedValueState.Completed)\n      })\n    }\n    return code\n  }\n}\n","import type {KeywordErrorCxt, KeywordErrorDefinition} from \"../types\"\nimport type {SchemaCxt} from \"./index\"\nimport {CodeGen, _, str, strConcat, Code, Name} from \"./codegen\"\nimport {SafeExpr} from \"./codegen/code\"\nimport {getErrorPath, Type} from \"./util\"\nimport N from \"./names\"\n\nexport const keywordError: KeywordErrorDefinition = {\n  message: ({keyword}) => str`must pass \"${keyword}\" keyword validation`,\n}\n\nexport const keyword$DataError: KeywordErrorDefinition = {\n  message: ({keyword, schemaType}) =>\n    schemaType\n      ? str`\"${keyword}\" keyword must be ${schemaType} ($data)`\n      : str`\"${keyword}\" keyword is invalid ($data)`,\n}\n\nexport interface ErrorPaths {\n  instancePath?: Code\n  schemaPath?: string\n  parentSchema?: boolean\n}\n\nexport function reportError(\n  cxt: KeywordErrorCxt,\n  error: KeywordErrorDefinition = keywordError,\n  errorPaths?: ErrorPaths,\n  overrideAllErrors?: boolean\n): void {\n  const {it} = cxt\n  const {gen, compositeRule, allErrors} = it\n  const errObj = errorObjectCode(cxt, error, errorPaths)\n  if (overrideAllErrors ?? (compositeRule || allErrors)) {\n    addError(gen, errObj)\n  } else {\n    returnErrors(it, _`[${errObj}]`)\n  }\n}\n\nexport function reportExtraError(\n  cxt: KeywordErrorCxt,\n  error: KeywordErrorDefinition = keywordError,\n  errorPaths?: ErrorPaths\n): void {\n  const {it} = cxt\n  const {gen, compositeRule, allErrors} = it\n  const errObj = errorObjectCode(cxt, error, errorPaths)\n  addError(gen, errObj)\n  if (!(compositeRule || allErrors)) {\n    returnErrors(it, N.vErrors)\n  }\n}\n\nexport function resetErrorsCount(gen: CodeGen, errsCount: Name): void {\n  gen.assign(N.errors, errsCount)\n  gen.if(_`${N.vErrors} !== null`, () =>\n    gen.if(\n      errsCount,\n      () => gen.assign(_`${N.vErrors}.length`, errsCount),\n      () => gen.assign(N.vErrors, null)\n    )\n  )\n}\n\nexport function extendErrors({\n  gen,\n  keyword,\n  schemaValue,\n  data,\n  errsCount,\n  it,\n}: KeywordErrorCxt): void {\n  /* istanbul ignore if */\n  if (errsCount === undefined) throw new Error(\"ajv implementation error\")\n  const err = gen.name(\"err\")\n  gen.forRange(\"i\", errsCount, N.errors, (i) => {\n    gen.const(err, _`${N.vErrors}[${i}]`)\n    gen.if(_`${err}.instancePath === undefined`, () =>\n      gen.assign(_`${err}.instancePath`, strConcat(N.instancePath, it.errorPath))\n    )\n    gen.assign(_`${err}.schemaPath`, str`${it.errSchemaPath}/${keyword}`)\n    if (it.opts.verbose) {\n      gen.assign(_`${err}.schema`, schemaValue)\n      gen.assign(_`${err}.data`, data)\n    }\n  })\n}\n\nfunction addError(gen: CodeGen, errObj: Code): void {\n  const err = gen.const(\"err\", errObj)\n  gen.if(\n    _`${N.vErrors} === null`,\n    () => gen.assign(N.vErrors, _`[${err}]`),\n    _`${N.vErrors}.push(${err})`\n  )\n  gen.code(_`${N.errors}++`)\n}\n\nfunction returnErrors(it: SchemaCxt, errs: Code): void {\n  const {gen, validateName, schemaEnv} = it\n  if (schemaEnv.$async) {\n    gen.throw(_`new ${it.ValidationError as Name}(${errs})`)\n  } else {\n    gen.assign(_`${validateName}.errors`, errs)\n    gen.return(false)\n  }\n}\n\nconst E = {\n  keyword: new Name(\"keyword\"),\n  schemaPath: new Name(\"schemaPath\"), // also used in JTD errors\n  params: new Name(\"params\"),\n  propertyName: new Name(\"propertyName\"),\n  message: new Name(\"message\"),\n  schema: new Name(\"schema\"),\n  parentSchema: new Name(\"parentSchema\"),\n}\n\nfunction errorObjectCode(\n  cxt: KeywordErrorCxt,\n  error: KeywordErrorDefinition,\n  errorPaths?: ErrorPaths\n): Code {\n  const {createErrors} = cxt.it\n  if (createErrors === false) return _`{}`\n  return errorObject(cxt, error, errorPaths)\n}\n\nfunction errorObject(\n  cxt: KeywordErrorCxt,\n  error: KeywordErrorDefinition,\n  errorPaths: ErrorPaths = {}\n): Code {\n  const {gen, it} = cxt\n  const keyValues: [Name, SafeExpr | string][] = [\n    errorInstancePath(it, errorPaths),\n    errorSchemaPath(cxt, errorPaths),\n  ]\n  extraErrorProps(cxt, error, keyValues)\n  return gen.object(...keyValues)\n}\n\nfunction errorInstancePath({errorPath}: SchemaCxt, {instancePath}: ErrorPaths): [Name, Code] {\n  const instPath = instancePath\n    ? str`${errorPath}${getErrorPath(instancePath, Type.Str)}`\n    : errorPath\n  return [N.instancePath, strConcat(N.instancePath, instPath)]\n}\n\nfunction errorSchemaPath(\n  {keyword, it: {errSchemaPath}}: KeywordErrorCxt,\n  {schemaPath, parentSchema}: ErrorPaths\n): [Name, string | Code] {\n  let schPath = parentSchema ? errSchemaPath : str`${errSchemaPath}/${keyword}`\n  if (schemaPath) {\n    schPath = str`${schPath}${getErrorPath(schemaPath, Type.Str)}`\n  }\n  return [E.schemaPath, schPath]\n}\n\nfunction extraErrorProps(\n  cxt: KeywordErrorCxt,\n  {params, message}: KeywordErrorDefinition,\n  keyValues: [Name, SafeExpr | string][]\n): void {\n  const {keyword, data, schemaValue, it} = cxt\n  const {opts, propertyName, topSchemaRef, schemaPath} = it\n  keyValues.push(\n    [E.keyword, keyword],\n    [E.params, typeof params == \"function\" ? params(cxt) : params || _`{}`]\n  )\n  if (opts.messages) {\n    keyValues.push([E.message, typeof message == \"function\" ? message(cxt) : message])\n  }\n  if (opts.verbose) {\n    keyValues.push(\n      [E.schema, schemaValue],\n      [E.parentSchema, _`${topSchemaRef}${schemaPath}`],\n      [N.data, data]\n    )\n  }\n  if (propertyName) keyValues.push([E.propertyName, propertyName])\n}\n","import type {\n  AnySchema,\n  AnySchemaObject,\n  AnyValidateFunction,\n  AsyncValidateFunction,\n  EvaluatedProperties,\n  EvaluatedItems,\n} from \"../types\"\nimport type Ajv from \"../core\"\nimport type {InstanceOptions} from \"../core\"\nimport {CodeGen, _, nil, stringify, Name, Code, ValueScopeName} from \"./codegen\"\nimport ValidationError from \"../runtime/validation_error\"\nimport N from \"./names\"\nimport {LocalRefs, getFullPath, _getFullPath, inlineRef, normalizeId, resolveUrl} from \"./resolve\"\nimport {schemaHasRulesButRef, unescapeFragment} from \"./util\"\nimport {validateFunctionCode} from \"./validate\"\nimport * as URI from \"uri-js\"\nimport {JSONType} from \"./rules\"\n\nexport type SchemaRefs = {\n  [Ref in string]?: SchemaEnv | AnySchema\n}\n\nexport interface SchemaCxt {\n  readonly gen: CodeGen\n  readonly allErrors?: boolean // validation mode - whether to collect all errors or break on error\n  readonly data: Name // Name with reference to the current part of data instance\n  readonly parentData: Name // should be used in keywords modifying data\n  readonly parentDataProperty: Code | number // should be used in keywords modifying data\n  readonly dataNames: Name[]\n  readonly dataPathArr: (Code | number)[]\n  readonly dataLevel: number // the level of the currently validated data,\n  // it can be used to access both the property names and the data on all levels from the top.\n  dataTypes: JSONType[] // data types applied to the current part of data instance\n  definedProperties: Set<string> // set of properties to keep track of for required checks\n  readonly topSchemaRef: Code\n  readonly validateName: Name\n  evaluated?: Name\n  readonly ValidationError?: Name\n  readonly schema: AnySchema // current schema object - equal to parentSchema passed via KeywordCxt\n  readonly schemaEnv: SchemaEnv\n  readonly rootId: string\n  baseId: string // the current schema base URI that should be used as the base for resolving URIs in references (\\$ref)\n  readonly schemaPath: Code // the run-time expression that evaluates to the property name of the current schema\n  readonly errSchemaPath: string // this is actual string, should not be changed to Code\n  readonly errorPath: Code\n  readonly propertyName?: Name\n  readonly compositeRule?: boolean // true indicates that the current schema is inside the compound keyword,\n  // where failing some rule doesn't mean validation failure (`anyOf`, `oneOf`, `not`, `if`).\n  // This flag is used to determine whether you can return validation result immediately after any error in case the option `allErrors` is not `true.\n  // You only need to use it if you have many steps in your keywords and potentially can define multiple errors.\n  props?: EvaluatedProperties | Name // properties evaluated by this schema - used by parent schema or assigned to validation function\n  items?: EvaluatedItems | Name // last item evaluated by this schema - used by parent schema or assigned to validation function\n  jtdDiscriminator?: string\n  jtdMetadata?: boolean\n  readonly createErrors?: boolean\n  readonly opts: InstanceOptions // Ajv instance option.\n  readonly self: Ajv // current Ajv instance\n}\n\nexport interface SchemaObjCxt extends SchemaCxt {\n  readonly schema: AnySchemaObject\n}\ninterface SchemaEnvArgs {\n  readonly schema: AnySchema\n  readonly schemaId?: \"$id\" | \"id\"\n  readonly root?: SchemaEnv\n  readonly baseId?: string\n  readonly schemaPath?: string\n  readonly localRefs?: LocalRefs\n  readonly meta?: boolean\n}\n\nexport class SchemaEnv implements SchemaEnvArgs {\n  readonly schema: AnySchema\n  readonly schemaId?: \"$id\" | \"id\"\n  readonly root: SchemaEnv\n  baseId: string // TODO possibly, it should be readonly\n  schemaPath?: string\n  localRefs?: LocalRefs\n  readonly meta?: boolean\n  readonly $async?: boolean // true if the current schema is asynchronous.\n  readonly refs: SchemaRefs = {}\n  readonly dynamicAnchors: {[Ref in string]?: true} = {}\n  validate?: AnyValidateFunction\n  validateName?: ValueScopeName\n  serialize?: (data: unknown) => string\n  serializeName?: ValueScopeName\n  parse?: (data: string) => unknown\n  parseName?: ValueScopeName\n\n  constructor(env: SchemaEnvArgs) {\n    let schema: AnySchemaObject | undefined\n    if (typeof env.schema == \"object\") schema = env.schema\n    this.schema = env.schema\n    this.schemaId = env.schemaId\n    this.root = env.root || this\n    this.baseId = env.baseId ?? normalizeId(schema?.[env.schemaId || \"$id\"])\n    this.schemaPath = env.schemaPath\n    this.localRefs = env.localRefs\n    this.meta = env.meta\n    this.$async = schema?.$async\n    this.refs = {}\n  }\n}\n\n// let codeSize = 0\n// let nodeCount = 0\n\n// Compiles schema in SchemaEnv\nexport function compileSchema(this: Ajv, sch: SchemaEnv): SchemaEnv {\n  // TODO refactor - remove compilations\n  const _sch = getCompilingSchema.call(this, sch)\n  if (_sch) return _sch\n  const rootId = getFullPath(this.opts.uriResolver, sch.root.baseId) // TODO if getFullPath removed 1 tests fails\n  const {es5, lines} = this.opts.code\n  const {ownProperties} = this.opts\n  const gen = new CodeGen(this.scope, {es5, lines, ownProperties})\n  let _ValidationError\n  if (sch.$async) {\n    _ValidationError = gen.scopeValue(\"Error\", {\n      ref: ValidationError,\n      code: _`require(\"ajv/dist/runtime/validation_error\").default`,\n    })\n  }\n\n  const validateName = gen.scopeName(\"validate\")\n  sch.validateName = validateName\n\n  const schemaCxt: SchemaCxt = {\n    gen,\n    allErrors: this.opts.allErrors,\n    data: N.data,\n    parentData: N.parentData,\n    parentDataProperty: N.parentDataProperty,\n    dataNames: [N.data],\n    dataPathArr: [nil], // TODO can its length be used as dataLevel if nil is removed?\n    dataLevel: 0,\n    dataTypes: [],\n    definedProperties: new Set<string>(),\n    topSchemaRef: gen.scopeValue(\n      \"schema\",\n      this.opts.code.source === true\n        ? {ref: sch.schema, code: stringify(sch.schema)}\n        : {ref: sch.schema}\n    ),\n    validateName,\n    ValidationError: _ValidationError,\n    schema: sch.schema,\n    schemaEnv: sch,\n    rootId,\n    baseId: sch.baseId || rootId,\n    schemaPath: nil,\n    errSchemaPath: sch.schemaPath || (this.opts.jtd ? \"\" : \"#\"),\n    errorPath: _`\"\"`,\n    opts: this.opts,\n    self: this,\n  }\n\n  let sourceCode: string | undefined\n  try {\n    this._compilations.add(sch)\n    validateFunctionCode(schemaCxt)\n    gen.optimize(this.opts.code.optimize)\n    // gen.optimize(1)\n    const validateCode = gen.toString()\n    sourceCode = `${gen.scopeRefs(N.scope)}return ${validateCode}`\n    // console.log((codeSize += sourceCode.length), (nodeCount += gen.nodeCount))\n    if (this.opts.code.process) sourceCode = this.opts.code.process(sourceCode, sch)\n    // console.log(\"\\n\\n\\n *** \\n\", sourceCode)\n    const makeValidate = new Function(`${N.self}`, `${N.scope}`, sourceCode)\n    const validate: AnyValidateFunction = makeValidate(this, this.scope.get())\n    this.scope.value(validateName, {ref: validate})\n\n    validate.errors = null\n    validate.schema = sch.schema\n    validate.schemaEnv = sch\n    if (sch.$async) (validate as AsyncValidateFunction).$async = true\n    if (this.opts.code.source === true) {\n      validate.source = {validateName, validateCode, scopeValues: gen._values}\n    }\n    if (this.opts.unevaluated) {\n      const {props, items} = schemaCxt\n      validate.evaluated = {\n        props: props instanceof Name ? undefined : props,\n        items: items instanceof Name ? undefined : items,\n        dynamicProps: props instanceof Name,\n        dynamicItems: items instanceof Name,\n      }\n      if (validate.source) validate.source.evaluated = stringify(validate.evaluated)\n    }\n    sch.validate = validate\n    return sch\n  } catch (e) {\n    delete sch.validate\n    delete sch.validateName\n    if (sourceCode) this.logger.error(\"Error compiling schema, function code:\", sourceCode)\n    // console.log(\"\\n\\n\\n *** \\n\", sourceCode, this.opts)\n    throw e\n  } finally {\n    this._compilations.delete(sch)\n  }\n}\n\nexport function resolveRef(\n  this: Ajv,\n  root: SchemaEnv,\n  baseId: string,\n  ref: string\n): AnySchema | SchemaEnv | undefined {\n  ref = resolveUrl(this.opts.uriResolver, baseId, ref)\n  const schOrFunc = root.refs[ref]\n  if (schOrFunc) return schOrFunc\n\n  let _sch = resolve.call(this, root, ref)\n  if (_sch === undefined) {\n    const schema = root.localRefs?.[ref] // TODO maybe localRefs should hold SchemaEnv\n    const {schemaId} = this.opts\n    if (schema) _sch = new SchemaEnv({schema, schemaId, root, baseId})\n  }\n\n  if (_sch === undefined) return\n  return (root.refs[ref] = inlineOrCompile.call(this, _sch))\n}\n\nfunction inlineOrCompile(this: Ajv, sch: SchemaEnv): AnySchema | SchemaEnv {\n  if (inlineRef(sch.schema, this.opts.inlineRefs)) return sch.schema\n  return sch.validate ? sch : compileSchema.call(this, sch)\n}\n\n// Index of schema compilation in the currently compiled list\nexport function getCompilingSchema(this: Ajv, schEnv: SchemaEnv): SchemaEnv | void {\n  for (const sch of this._compilations) {\n    if (sameSchemaEnv(sch, schEnv)) return sch\n  }\n}\n\nfunction sameSchemaEnv(s1: SchemaEnv, s2: SchemaEnv): boolean {\n  return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId\n}\n\n// resolve and compile the references ($ref)\n// TODO returns AnySchemaObject (if the schema can be inlined) or validation function\nfunction resolve(\n  this: Ajv,\n  root: SchemaEnv, // information about the root schema for the current schema\n  ref: string // reference to resolve\n): SchemaEnv | undefined {\n  let sch\n  while (typeof (sch = this.refs[ref]) == \"string\") ref = sch\n  return sch || this.schemas[ref] || resolveSchema.call(this, root, ref)\n}\n\n// Resolve schema, its root and baseId\nexport function resolveSchema(\n  this: Ajv,\n  root: SchemaEnv, // root object with properties schema, refs TODO below SchemaEnv is assigned to it\n  ref: string // reference to resolve\n): SchemaEnv | undefined {\n  const p = this.opts.uriResolver.parse(ref)\n  const refPath = _getFullPath(this.opts.uriResolver, p)\n  let baseId = getFullPath(this.opts.uriResolver, root.baseId, undefined)\n  // TODO `Object.keys(root.schema).length > 0` should not be needed - but removing breaks 2 tests\n  if (Object.keys(root.schema).length > 0 && refPath === baseId) {\n    return getJsonPointer.call(this, p, root)\n  }\n\n  const id = normalizeId(refPath)\n  const schOrRef = this.refs[id] || this.schemas[id]\n  if (typeof schOrRef == \"string\") {\n    const sch = resolveSchema.call(this, root, schOrRef)\n    if (typeof sch?.schema !== \"object\") return\n    return getJsonPointer.call(this, p, sch)\n  }\n\n  if (typeof schOrRef?.schema !== \"object\") return\n  if (!schOrRef.validate) compileSchema.call(this, schOrRef)\n  if (id === normalizeId(ref)) {\n    const {schema} = schOrRef\n    const {schemaId} = this.opts\n    const schId = schema[schemaId]\n    if (schId) baseId = resolveUrl(this.opts.uriResolver, baseId, schId)\n    return new SchemaEnv({schema, schemaId, root, baseId})\n  }\n  return getJsonPointer.call(this, p, schOrRef)\n}\n\nconst PREVENT_SCOPE_CHANGE = new Set([\n  \"properties\",\n  \"patternProperties\",\n  \"enum\",\n  \"dependencies\",\n  \"definitions\",\n])\n\nfunction getJsonPointer(\n  this: Ajv,\n  parsedRef: URI.URIComponents,\n  {baseId, schema, root}: SchemaEnv\n): SchemaEnv | undefined {\n  if (parsedRef.fragment?.[0] !== \"/\") return\n  for (const part of parsedRef.fragment.slice(1).split(\"/\")) {\n    if (typeof schema === \"boolean\") return\n    const partSchema = schema[unescapeFragment(part)]\n    if (partSchema === undefined) return\n    schema = partSchema\n    // TODO PREVENT_SCOPE_CHANGE could be defined in keyword def?\n    const schId = typeof schema === \"object\" && schema[this.opts.schemaId]\n    if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {\n      baseId = resolveUrl(this.opts.uriResolver, baseId, schId)\n    }\n  }\n  let env: SchemaEnv | undefined\n  if (typeof schema != \"boolean\" && schema.$ref && !schemaHasRulesButRef(schema, this.RULES)) {\n    const $ref = resolveUrl(this.opts.uriResolver, baseId, schema.$ref)\n    env = resolveSchema.call(this, root, $ref)\n  }\n  // even though resolution failed we need to return SchemaEnv to throw exception\n  // so that compileAsync loads missing schema.\n  const {schemaId} = this.opts\n  env = env || new SchemaEnv({schema, schemaId, root, baseId})\n  if (env.schema !== env.root.schema) return env\n  return undefined\n}\n","import {Name} from \"./codegen\"\n\nconst names = {\n  // validation function arguments\n  data: new Name(\"data\"), // data passed to validation function\n  // args passed from referencing schema\n  valCxt: new Name(\"valCxt\"), // validation/data context - should not be used directly, it is destructured to the names below\n  instancePath: new Name(\"instancePath\"),\n  parentData: new Name(\"parentData\"),\n  parentDataProperty: new Name(\"parentDataProperty\"),\n  rootData: new Name(\"rootData\"), // root data - same as the data passed to the first/top validation function\n  dynamicAnchors: new Name(\"dynamicAnchors\"), // used to support recursiveRef and dynamicRef\n  // function scoped variables\n  vErrors: new Name(\"vErrors\"), // null or array of validation errors\n  errors: new Name(\"errors\"), // counter of validation errors\n  this: new Name(\"this\"),\n  // \"globals\"\n  self: new Name(\"self\"),\n  scope: new Name(\"scope\"),\n  // JTD serialize/parse name for JSON string and position\n  json: new Name(\"json\"),\n  jsonPos: new Name(\"jsonPos\"),\n  jsonLen: new Name(\"jsonLen\"),\n  jsonPart: new Name(\"jsonPart\"),\n}\n\nexport default names\n","import {resolveUrl, normalizeId, getFullPath} from \"./resolve\"\nimport type {UriResolver} from \"../types\"\n\nexport default class MissingRefError extends Error {\n  readonly missingRef: string\n  readonly missingSchema: string\n\n  constructor(resolver: UriResolver, baseId: string, ref: string, msg?: string) {\n    super(msg || `can't resolve reference ${ref} from id ${baseId}`)\n    this.missingRef = resolveUrl(resolver, baseId, ref)\n    this.missingSchema = normalizeId(getFullPath(resolver, this.missingRef))\n  }\n}\n","import type {AnySchema, AnySchemaObject, UriResolver} from \"../types\"\nimport type Ajv from \"../ajv\"\nimport type {URIComponents} from \"uri-js\"\nimport {eachItem} from \"./util\"\nimport * as equal from \"fast-deep-equal\"\nimport * as traverse from \"json-schema-traverse\"\n\n// the hash of local references inside the schema (created by getSchemaRefs), used for inline resolution\nexport type LocalRefs = {[Ref in string]?: AnySchemaObject}\n\n// TODO refactor to use keyword definitions\nconst SIMPLE_INLINED = new Set([\n  \"type\",\n  \"format\",\n  \"pattern\",\n  \"maxLength\",\n  \"minLength\",\n  \"maxProperties\",\n  \"minProperties\",\n  \"maxItems\",\n  \"minItems\",\n  \"maximum\",\n  \"minimum\",\n  \"uniqueItems\",\n  \"multipleOf\",\n  \"required\",\n  \"enum\",\n  \"const\",\n])\n\nexport function inlineRef(schema: AnySchema, limit: boolean | number = true): boolean {\n  if (typeof schema == \"boolean\") return true\n  if (limit === true) return !hasRef(schema)\n  if (!limit) return false\n  return countKeys(schema) <= limit\n}\n\nconst REF_KEYWORDS = new Set([\n  \"$ref\",\n  \"$recursiveRef\",\n  \"$recursiveAnchor\",\n  \"$dynamicRef\",\n  \"$dynamicAnchor\",\n])\n\nfunction hasRef(schema: AnySchemaObject): boolean {\n  for (const key in schema) {\n    if (REF_KEYWORDS.has(key)) return true\n    const sch = schema[key]\n    if (Array.isArray(sch) && sch.some(hasRef)) return true\n    if (typeof sch == \"object\" && hasRef(sch)) return true\n  }\n  return false\n}\n\nfunction countKeys(schema: AnySchemaObject): number {\n  let count = 0\n  for (const key in schema) {\n    if (key === \"$ref\") return Infinity\n    count++\n    if (SIMPLE_INLINED.has(key)) continue\n    if (typeof schema[key] == \"object\") {\n      eachItem(schema[key], (sch) => (count += countKeys(sch)))\n    }\n    if (count === Infinity) return Infinity\n  }\n  return count\n}\n\nexport function getFullPath(resolver: UriResolver, id = \"\", normalize?: boolean): string {\n  if (normalize !== false) id = normalizeId(id)\n  const p = resolver.parse(id)\n  return _getFullPath(resolver, p)\n}\n\nexport function _getFullPath(resolver: UriResolver, p: URIComponents): string {\n  const serialized = resolver.serialize(p)\n  return serialized.split(\"#\")[0] + \"#\"\n}\n\nconst TRAILING_SLASH_HASH = /#\\/?$/\nexport function normalizeId(id: string | undefined): string {\n  return id ? id.replace(TRAILING_SLASH_HASH, \"\") : \"\"\n}\n\nexport function resolveUrl(resolver: UriResolver, baseId: string, id: string): string {\n  id = normalizeId(id)\n  return resolver.resolve(baseId, id)\n}\n\nconst ANCHOR = /^[a-z_][-a-z0-9._]*$/i\n\nexport function getSchemaRefs(this: Ajv, schema: AnySchema, baseId: string): LocalRefs {\n  if (typeof schema == \"boolean\") return {}\n  const {schemaId, uriResolver} = this.opts\n  const schId = normalizeId(schema[schemaId] || baseId)\n  const baseIds: {[JsonPtr in string]?: string} = {\"\": schId}\n  const pathPrefix = getFullPath(uriResolver, schId, false)\n  const localRefs: LocalRefs = {}\n  const schemaRefs: Set<string> = new Set()\n\n  traverse(schema, {allKeys: true}, (sch, jsonPtr, _, parentJsonPtr) => {\n    if (parentJsonPtr === undefined) return\n    const fullPath = pathPrefix + jsonPtr\n    let baseId = baseIds[parentJsonPtr]\n    if (typeof sch[schemaId] == \"string\") baseId = addRef.call(this, sch[schemaId])\n    addAnchor.call(this, sch.$anchor)\n    addAnchor.call(this, sch.$dynamicAnchor)\n    baseIds[jsonPtr] = baseId\n\n    function addRef(this: Ajv, ref: string): string {\n      // eslint-disable-next-line @typescript-eslint/unbound-method\n      const _resolve = this.opts.uriResolver.resolve\n      ref = normalizeId(baseId ? _resolve(baseId, ref) : ref)\n      if (schemaRefs.has(ref)) throw ambiguos(ref)\n      schemaRefs.add(ref)\n      let schOrRef = this.refs[ref]\n      if (typeof schOrRef == \"string\") schOrRef = this.refs[schOrRef]\n      if (typeof schOrRef == \"object\") {\n        checkAmbiguosRef(sch, schOrRef.schema, ref)\n      } else if (ref !== normalizeId(fullPath)) {\n        if (ref[0] === \"#\") {\n          checkAmbiguosRef(sch, localRefs[ref], ref)\n          localRefs[ref] = sch\n        } else {\n          this.refs[ref] = fullPath\n        }\n      }\n      return ref\n    }\n\n    function addAnchor(this: Ajv, anchor: unknown): void {\n      if (typeof anchor == \"string\") {\n        if (!ANCHOR.test(anchor)) throw new Error(`invalid anchor \"${anchor}\"`)\n        addRef.call(this, `#${anchor}`)\n      }\n    }\n  })\n\n  return localRefs\n\n  function checkAmbiguosRef(sch1: AnySchema, sch2: AnySchema | undefined, ref: string): void {\n    if (sch2 !== undefined && !equal(sch1, sch2)) throw ambiguos(ref)\n  }\n\n  function ambiguos(ref: string): Error {\n    return new Error(`reference \"${ref}\" resolves to more than one schema`)\n  }\n}\n","import type {AddedKeywordDefinition} from \"../types\"\n\nconst _jsonTypes = [\"string\", \"number\", \"integer\", \"boolean\", \"null\", \"object\", \"array\"] as const\n\nexport type JSONType = typeof _jsonTypes[number]\n\nconst jsonTypes: Set<string> = new Set(_jsonTypes)\n\nexport function isJSONType(x: unknown): x is JSONType {\n  return typeof x == \"string\" && jsonTypes.has(x)\n}\n\ntype ValidationTypes = {\n  [K in JSONType]: boolean | RuleGroup | undefined\n}\n\nexport interface ValidationRules {\n  rules: RuleGroup[]\n  post: RuleGroup\n  all: {[Key in string]?: boolean | Rule} // rules that have to be validated\n  keywords: {[Key in string]?: boolean} // all known keywords (superset of \"all\")\n  types: ValidationTypes\n}\n\nexport interface RuleGroup {\n  type?: JSONType\n  rules: Rule[]\n}\n\n// This interface wraps KeywordDefinition because definition can have multiple keywords\nexport interface Rule {\n  keyword: string\n  definition: AddedKeywordDefinition\n}\n\nexport function getRules(): ValidationRules {\n  const groups: Record<\"number\" | \"string\" | \"array\" | \"object\", RuleGroup> = {\n    number: {type: \"number\", rules: []},\n    string: {type: \"string\", rules: []},\n    array: {type: \"array\", rules: []},\n    object: {type: \"object\", rules: []},\n  }\n  return {\n    types: {...groups, integer: true, boolean: true, null: true},\n    rules: [{rules: []}, groups.number, groups.string, groups.array, groups.object],\n    post: {rules: []},\n    all: {},\n    keywords: {},\n  }\n}\n","import type {AnySchema, EvaluatedProperties, EvaluatedItems} from \"../types\"\nimport type {SchemaCxt, SchemaObjCxt} from \".\"\nimport {_, getProperty, Code, Name, CodeGen} from \"./codegen\"\nimport {_Code} from \"./codegen/code\"\nimport type {Rule, ValidationRules} from \"./rules\"\n\n// TODO refactor to use Set\nexport function toHash<T extends string = string>(arr: T[]): {[K in T]?: true} {\n  const hash: {[K in T]?: true} = {}\n  for (const item of arr) hash[item] = true\n  return hash\n}\n\nexport function alwaysValidSchema(it: SchemaCxt, schema: AnySchema): boolean | void {\n  if (typeof schema == \"boolean\") return schema\n  if (Object.keys(schema).length === 0) return true\n  checkUnknownRules(it, schema)\n  return !schemaHasRules(schema, it.self.RULES.all)\n}\n\nexport function checkUnknownRules(it: SchemaCxt, schema: AnySchema = it.schema): void {\n  const {opts, self} = it\n  if (!opts.strictSchema) return\n  if (typeof schema === \"boolean\") return\n  const rules = self.RULES.keywords\n  for (const key in schema) {\n    if (!rules[key]) checkStrictMode(it, `unknown keyword: \"${key}\"`)\n  }\n}\n\nexport function schemaHasRules(\n  schema: AnySchema,\n  rules: {[Key in string]?: boolean | Rule}\n): boolean {\n  if (typeof schema == \"boolean\") return !schema\n  for (const key in schema) if (rules[key]) return true\n  return false\n}\n\nexport function schemaHasRulesButRef(schema: AnySchema, RULES: ValidationRules): boolean {\n  if (typeof schema == \"boolean\") return !schema\n  for (const key in schema) if (key !== \"$ref\" && RULES.all[key]) return true\n  return false\n}\n\nexport function schemaRefOrVal(\n  {topSchemaRef, schemaPath}: SchemaObjCxt,\n  schema: unknown,\n  keyword: string,\n  $data?: string | false\n): Code | number | boolean {\n  if (!$data) {\n    if (typeof schema == \"number\" || typeof schema == \"boolean\") return schema\n    if (typeof schema == \"string\") return _`${schema}`\n  }\n  return _`${topSchemaRef}${schemaPath}${getProperty(keyword)}`\n}\n\nexport function unescapeFragment(str: string): string {\n  return unescapeJsonPointer(decodeURIComponent(str))\n}\n\nexport function escapeFragment(str: string | number): string {\n  return encodeURIComponent(escapeJsonPointer(str))\n}\n\nexport function escapeJsonPointer(str: string | number): string {\n  if (typeof str == \"number\") return `${str}`\n  return str.replace(/~/g, \"~0\").replace(/\\//g, \"~1\")\n}\n\nexport function unescapeJsonPointer(str: string): string {\n  return str.replace(/~1/g, \"/\").replace(/~0/g, \"~\")\n}\n\nexport function eachItem<T>(xs: T | T[], f: (x: T) => void): void {\n  if (Array.isArray(xs)) {\n    for (const x of xs) f(x)\n  } else {\n    f(xs)\n  }\n}\n\ntype SomeEvaluated = EvaluatedProperties | EvaluatedItems\n\ntype MergeEvaluatedFunc<T extends SomeEvaluated> = (\n  gen: CodeGen,\n  from: Name | T,\n  to: Name | Exclude<T, true> | undefined,\n  toName?: typeof Name\n) => Name | T\n\ninterface MakeMergeFuncArgs<T extends SomeEvaluated> {\n  mergeNames: (gen: CodeGen, from: Name, to: Name) => void\n  mergeToName: (gen: CodeGen, from: T, to: Name) => void\n  mergeValues: (from: T, to: Exclude<T, true>) => T\n  resultToName: (gen: CodeGen, res?: T) => Name\n}\n\nfunction makeMergeEvaluated<T extends SomeEvaluated>({\n  mergeNames,\n  mergeToName,\n  mergeValues,\n  resultToName,\n}: MakeMergeFuncArgs<T>): MergeEvaluatedFunc<T> {\n  return (gen, from, to, toName) => {\n    const res =\n      to === undefined\n        ? from\n        : to instanceof Name\n        ? (from instanceof Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to)\n        : from instanceof Name\n        ? (mergeToName(gen, to, from), from)\n        : mergeValues(from, to)\n    return toName === Name && !(res instanceof Name) ? resultToName(gen, res) : res\n  }\n}\n\ninterface MergeEvaluated {\n  props: MergeEvaluatedFunc<EvaluatedProperties>\n  items: MergeEvaluatedFunc<EvaluatedItems>\n}\n\nexport const mergeEvaluated: MergeEvaluated = {\n  props: makeMergeEvaluated({\n    mergeNames: (gen, from, to) =>\n      gen.if(_`${to} !== true && ${from} !== undefined`, () => {\n        gen.if(\n          _`${from} === true`,\n          () => gen.assign(to, true),\n          () => gen.assign(to, _`${to} || {}`).code(_`Object.assign(${to}, ${from})`)\n        )\n      }),\n    mergeToName: (gen, from, to) =>\n      gen.if(_`${to} !== true`, () => {\n        if (from === true) {\n          gen.assign(to, true)\n        } else {\n          gen.assign(to, _`${to} || {}`)\n          setEvaluated(gen, to, from)\n        }\n      }),\n    mergeValues: (from, to) => (from === true ? true : {...from, ...to}),\n    resultToName: evaluatedPropsToName,\n  }),\n  items: makeMergeEvaluated({\n    mergeNames: (gen, from, to) =>\n      gen.if(_`${to} !== true && ${from} !== undefined`, () =>\n        gen.assign(to, _`${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)\n      ),\n    mergeToName: (gen, from, to) =>\n      gen.if(_`${to} !== true`, () =>\n        gen.assign(to, from === true ? true : _`${to} > ${from} ? ${to} : ${from}`)\n      ),\n    mergeValues: (from, to) => (from === true ? true : Math.max(from, to)),\n    resultToName: (gen, items) => gen.var(\"items\", items),\n  }),\n}\n\nexport function evaluatedPropsToName(gen: CodeGen, ps?: EvaluatedProperties): Name {\n  if (ps === true) return gen.var(\"props\", true)\n  const props = gen.var(\"props\", _`{}`)\n  if (ps !== undefined) setEvaluated(gen, props, ps)\n  return props\n}\n\nexport function setEvaluated(gen: CodeGen, props: Name, ps: {[K in string]?: true}): void {\n  Object.keys(ps).forEach((p) => gen.assign(_`${props}${getProperty(p)}`, true))\n}\n\nconst snippets: {[S in string]?: _Code} = {}\n\nexport function useFunc(gen: CodeGen, f: {code: string}): Name {\n  return gen.scopeValue(\"func\", {\n    ref: f,\n    code: snippets[f.code] || (snippets[f.code] = new _Code(f.code)),\n  })\n}\n\nexport enum Type {\n  Num,\n  Str,\n}\n\nexport function getErrorPath(\n  dataProp: Name | string | number,\n  dataPropType?: Type,\n  jsPropertySyntax?: boolean\n): Code | string {\n  // let path\n  if (dataProp instanceof Name) {\n    const isNumber = dataPropType === Type.Num\n    return jsPropertySyntax\n      ? isNumber\n        ? _`\"[\" + ${dataProp} + \"]\"`\n        : _`\"['\" + ${dataProp} + \"']\"`\n      : isNumber\n      ? _`\"/\" + ${dataProp}`\n      : _`\"/\" + ${dataProp}.replace(/~/g, \"~0\").replace(/\\\\//g, \"~1\")` // TODO maybe use global escapePointer\n  }\n  return jsPropertySyntax ? getProperty(dataProp).toString() : \"/\" + escapeJsonPointer(dataProp)\n}\n\nexport function checkStrictMode(\n  it: SchemaCxt,\n  msg: string,\n  mode: boolean | \"log\" = it.opts.strictSchema\n): void {\n  if (!mode) return\n  msg = `strict mode: ${msg}`\n  if (mode === true) throw new Error(msg)\n  it.self.logger.warn(msg)\n}\n","import type {AnySchemaObject} from \"../../types\"\nimport type {SchemaObjCxt} from \"..\"\nimport type {JSONType, RuleGroup, Rule} from \"../rules\"\n\nexport function schemaHasRulesForType(\n  {schema, self}: SchemaObjCxt,\n  type: JSONType\n): boolean | undefined {\n  const group = self.RULES.types[type]\n  return group && group !== true && shouldUseGroup(schema, group)\n}\n\nexport function shouldUseGroup(schema: AnySchemaObject, group: RuleGroup): boolean {\n  return group.rules.some((rule) => shouldUseRule(schema, rule))\n}\n\nexport function shouldUseRule(schema: AnySchemaObject, rule: Rule): boolean | undefined {\n  return (\n    schema[rule.keyword] !== undefined ||\n    rule.definition.implements?.some((kwd) => schema[kwd] !== undefined)\n  )\n}\n","import type {KeywordErrorDefinition, KeywordErrorCxt} from \"../../types\"\nimport type {SchemaCxt} from \"..\"\nimport {reportError} from \"../errors\"\nimport {_, Name} from \"../codegen\"\nimport N from \"../names\"\n\nconst boolError: KeywordErrorDefinition = {\n  message: \"boolean schema is false\",\n}\n\nexport function topBoolOrEmptySchema(it: SchemaCxt): void {\n  const {gen, schema, validateName} = it\n  if (schema === false) {\n    falseSchemaError(it, false)\n  } else if (typeof schema == \"object\" && schema.$async === true) {\n    gen.return(N.data)\n  } else {\n    gen.assign(_`${validateName}.errors`, null)\n    gen.return(true)\n  }\n}\n\nexport function boolOrEmptySchema(it: SchemaCxt, valid: Name): void {\n  const {gen, schema} = it\n  if (schema === false) {\n    gen.var(valid, false) // TODO var\n    falseSchemaError(it)\n  } else {\n    gen.var(valid, true) // TODO var\n  }\n}\n\nfunction falseSchemaError(it: SchemaCxt, overrideAllErrors?: boolean): void {\n  const {gen, data} = it\n  // TODO maybe some other interface should be used for non-keyword validation errors...\n  const cxt: KeywordErrorCxt = {\n    gen,\n    keyword: \"false schema\",\n    data,\n    schema: false,\n    schemaCode: false,\n    schemaValue: false,\n    params: {},\n    it,\n  }\n  reportError(cxt, boolError, undefined, overrideAllErrors)\n}\n","import type {\n  KeywordErrorDefinition,\n  KeywordErrorCxt,\n  ErrorObject,\n  AnySchemaObject,\n} from \"../../types\"\nimport type {SchemaObjCxt} from \"..\"\nimport {isJSONType, JSONType} from \"../rules\"\nimport {schemaHasRulesForType} from \"./applicability\"\nimport {reportError} from \"../errors\"\nimport {_, nil, and, not, operators, Code, Name} from \"../codegen\"\nimport {toHash, schemaRefOrVal} from \"../util\"\n\nexport enum DataType {\n  Correct,\n  Wrong,\n}\n\nexport function getSchemaTypes(schema: AnySchemaObject): JSONType[] {\n  const types = getJSONTypes(schema.type)\n  const hasNull = types.includes(\"null\")\n  if (hasNull) {\n    if (schema.nullable === false) throw new Error(\"type: null contradicts nullable: false\")\n  } else {\n    if (!types.length && schema.nullable !== undefined) {\n      throw new Error('\"nullable\" cannot be used without \"type\"')\n    }\n    if (schema.nullable === true) types.push(\"null\")\n  }\n  return types\n}\n\nexport function getJSONTypes(ts: unknown | unknown[]): JSONType[] {\n  const types: unknown[] = Array.isArray(ts) ? ts : ts ? [ts] : []\n  if (types.every(isJSONType)) return types\n  throw new Error(\"type must be JSONType or JSONType[]: \" + types.join(\",\"))\n}\n\nexport function coerceAndCheckDataType(it: SchemaObjCxt, types: JSONType[]): boolean {\n  const {gen, data, opts} = it\n  const coerceTo = coerceToTypes(types, opts.coerceTypes)\n  const checkTypes =\n    types.length > 0 &&\n    !(coerceTo.length === 0 && types.length === 1 && schemaHasRulesForType(it, types[0]))\n  if (checkTypes) {\n    const wrongType = checkDataTypes(types, data, opts.strictNumbers, DataType.Wrong)\n    gen.if(wrongType, () => {\n      if (coerceTo.length) coerceData(it, types, coerceTo)\n      else reportTypeError(it)\n    })\n  }\n  return checkTypes\n}\n\nconst COERCIBLE: Set<JSONType> = new Set([\"string\", \"number\", \"integer\", \"boolean\", \"null\"])\nfunction coerceToTypes(types: JSONType[], coerceTypes?: boolean | \"array\"): JSONType[] {\n  return coerceTypes\n    ? types.filter((t) => COERCIBLE.has(t) || (coerceTypes === \"array\" && t === \"array\"))\n    : []\n}\n\nfunction coerceData(it: SchemaObjCxt, types: JSONType[], coerceTo: JSONType[]): void {\n  const {gen, data, opts} = it\n  const dataType = gen.let(\"dataType\", _`typeof ${data}`)\n  const coerced = gen.let(\"coerced\", _`undefined`)\n  if (opts.coerceTypes === \"array\") {\n    gen.if(_`${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () =>\n      gen\n        .assign(data, _`${data}[0]`)\n        .assign(dataType, _`typeof ${data}`)\n        .if(checkDataTypes(types, data, opts.strictNumbers), () => gen.assign(coerced, data))\n    )\n  }\n  gen.if(_`${coerced} !== undefined`)\n  for (const t of coerceTo) {\n    if (COERCIBLE.has(t) || (t === \"array\" && opts.coerceTypes === \"array\")) {\n      coerceSpecificType(t)\n    }\n  }\n  gen.else()\n  reportTypeError(it)\n  gen.endIf()\n\n  gen.if(_`${coerced} !== undefined`, () => {\n    gen.assign(data, coerced)\n    assignParentData(it, coerced)\n  })\n\n  function coerceSpecificType(t: string): void {\n    switch (t) {\n      case \"string\":\n        gen\n          .elseIf(_`${dataType} == \"number\" || ${dataType} == \"boolean\"`)\n          .assign(coerced, _`\"\" + ${data}`)\n          .elseIf(_`${data} === null`)\n          .assign(coerced, _`\"\"`)\n        return\n      case \"number\":\n        gen\n          .elseIf(\n            _`${dataType} == \"boolean\" || ${data} === null\n              || (${dataType} == \"string\" && ${data} && ${data} == +${data})`\n          )\n          .assign(coerced, _`+${data}`)\n        return\n      case \"integer\":\n        gen\n          .elseIf(\n            _`${dataType} === \"boolean\" || ${data} === null\n              || (${dataType} === \"string\" && ${data} && ${data} == +${data} && !(${data} % 1))`\n          )\n          .assign(coerced, _`+${data}`)\n        return\n      case \"boolean\":\n        gen\n          .elseIf(_`${data} === \"false\" || ${data} === 0 || ${data} === null`)\n          .assign(coerced, false)\n          .elseIf(_`${data} === \"true\" || ${data} === 1`)\n          .assign(coerced, true)\n        return\n      case \"null\":\n        gen.elseIf(_`${data} === \"\" || ${data} === 0 || ${data} === false`)\n        gen.assign(coerced, null)\n        return\n\n      case \"array\":\n        gen\n          .elseIf(\n            _`${dataType} === \"string\" || ${dataType} === \"number\"\n              || ${dataType} === \"boolean\" || ${data} === null`\n          )\n          .assign(coerced, _`[${data}]`)\n    }\n  }\n}\n\nfunction assignParentData({gen, parentData, parentDataProperty}: SchemaObjCxt, expr: Name): void {\n  // TODO use gen.property\n  gen.if(_`${parentData} !== undefined`, () =>\n    gen.assign(_`${parentData}[${parentDataProperty}]`, expr)\n  )\n}\n\nexport function checkDataType(\n  dataType: JSONType,\n  data: Name,\n  strictNums?: boolean | \"log\",\n  correct = DataType.Correct\n): Code {\n  const EQ = correct === DataType.Correct ? operators.EQ : operators.NEQ\n  let cond: Code\n  switch (dataType) {\n    case \"null\":\n      return _`${data} ${EQ} null`\n    case \"array\":\n      cond = _`Array.isArray(${data})`\n      break\n    case \"object\":\n      cond = _`${data} && typeof ${data} == \"object\" && !Array.isArray(${data})`\n      break\n    case \"integer\":\n      cond = numCond(_`!(${data} % 1) && !isNaN(${data})`)\n      break\n    case \"number\":\n      cond = numCond()\n      break\n    default:\n      return _`typeof ${data} ${EQ} ${dataType}`\n  }\n  return correct === DataType.Correct ? cond : not(cond)\n\n  function numCond(_cond: Code = nil): Code {\n    return and(_`typeof ${data} == \"number\"`, _cond, strictNums ? _`isFinite(${data})` : nil)\n  }\n}\n\nexport function checkDataTypes(\n  dataTypes: JSONType[],\n  data: Name,\n  strictNums?: boolean | \"log\",\n  correct?: DataType\n): Code {\n  if (dataTypes.length === 1) {\n    return checkDataType(dataTypes[0], data, strictNums, correct)\n  }\n  let cond: Code\n  const types = toHash(dataTypes)\n  if (types.array && types.object) {\n    const notObj = _`typeof ${data} != \"object\"`\n    cond = types.null ? notObj : _`!${data} || ${notObj}`\n    delete types.null\n    delete types.array\n    delete types.object\n  } else {\n    cond = nil\n  }\n  if (types.number) delete types.integer\n  for (const t in types) cond = and(cond, checkDataType(t as JSONType, data, strictNums, correct))\n  return cond\n}\n\nexport type TypeError = ErrorObject<\"type\", {type: string}>\n\nconst typeError: KeywordErrorDefinition = {\n  message: ({schema}) => `must be ${schema}`,\n  params: ({schema, schemaValue}) =>\n    typeof schema == \"string\" ? _`{type: ${schema}}` : _`{type: ${schemaValue}}`,\n}\n\nexport function reportTypeError(it: SchemaObjCxt): void {\n  const cxt = getTypeErrorContext(it)\n  reportError(cxt, typeError)\n}\n\nfunction getTypeErrorContext(it: SchemaObjCxt): KeywordErrorCxt {\n  const {gen, data, schema} = it\n  const schemaCode = schemaRefOrVal(it, schema, \"type\")\n  return {\n    gen,\n    keyword: \"type\",\n    data,\n    schema: schema.type,\n    schemaCode,\n    schemaValue: schemaCode,\n    parentSchema: schema,\n    params: {},\n    it,\n  }\n}\n","import type {SchemaObjCxt} from \"..\"\nimport {_, getProperty, stringify} from \"../codegen\"\nimport {checkStrictMode} from \"../util\"\n\nexport function assignDefaults(it: SchemaObjCxt, ty?: string): void {\n  const {properties, items} = it.schema\n  if (ty === \"object\" && properties) {\n    for (const key in properties) {\n      assignDefault(it, key, properties[key].default)\n    }\n  } else if (ty === \"array\" && Array.isArray(items)) {\n    items.forEach((sch, i: number) => assignDefault(it, i, sch.default))\n  }\n}\n\nfunction assignDefault(it: SchemaObjCxt, prop: string | number, defaultValue: unknown): void {\n  const {gen, compositeRule, data, opts} = it\n  if (defaultValue === undefined) return\n  const childData = _`${data}${getProperty(prop)}`\n  if (compositeRule) {\n    checkStrictMode(it, `default is ignored for: ${childData}`)\n    return\n  }\n\n  let condition = _`${childData} === undefined`\n  if (opts.useDefaults === \"empty\") {\n    condition = _`${condition} || ${childData} === null || ${childData} === \"\"`\n  }\n  // `${childData} === undefined` +\n  // (opts.useDefaults === \"empty\" ? ` || ${childData} === null || ${childData} === \"\"` : \"\")\n  gen.if(condition, _`${childData} = ${stringify(defaultValue)}`)\n}\n","import type {\n  AddedKeywordDefinition,\n  AnySchema,\n  AnySchemaObject,\n  KeywordErrorCxt,\n  KeywordCxtParams,\n} from \"../../types\"\nimport type {SchemaCxt, SchemaObjCxt} from \"..\"\nimport type {InstanceOptions} from \"../../core\"\nimport {boolOrEmptySchema, topBoolOrEmptySchema} from \"./boolSchema\"\nimport {coerceAndCheckDataType, getSchemaTypes} from \"./dataType\"\nimport {shouldUseGroup, shouldUseRule} from \"./applicability\"\nimport {checkDataType, checkDataTypes, reportTypeError, DataType} from \"./dataType\"\nimport {assignDefaults} from \"./defaults\"\nimport {funcKeywordCode, macroKeywordCode, validateKeywordUsage, validSchemaType} from \"./keyword\"\nimport {getSubschema, extendSubschemaData, SubschemaArgs, extendSubschemaMode} from \"./subschema\"\nimport {_, nil, str, or, not, getProperty, Block, Code, Name, CodeGen} from \"../codegen\"\nimport N from \"../names\"\nimport {resolveUrl} from \"../resolve\"\nimport {\n  schemaRefOrVal,\n  schemaHasRulesButRef,\n  checkUnknownRules,\n  checkStrictMode,\n  unescapeJsonPointer,\n  mergeEvaluated,\n} from \"../util\"\nimport type {JSONType, Rule, RuleGroup} from \"../rules\"\nimport {\n  ErrorPaths,\n  reportError,\n  reportExtraError,\n  resetErrorsCount,\n  keyword$DataError,\n} from \"../errors\"\n\n// schema compilation - generates validation function, subschemaCode (below) is used for subschemas\nexport function validateFunctionCode(it: SchemaCxt): void {\n  if (isSchemaObj(it)) {\n    checkKeywords(it)\n    if (schemaCxtHasRules(it)) {\n      topSchemaObjCode(it)\n      return\n    }\n  }\n  validateFunction(it, () => topBoolOrEmptySchema(it))\n}\n\nfunction validateFunction(\n  {gen, validateName, schema, schemaEnv, opts}: SchemaCxt,\n  body: Block\n): void {\n  if (opts.code.es5) {\n    gen.func(validateName, _`${N.data}, ${N.valCxt}`, schemaEnv.$async, () => {\n      gen.code(_`\"use strict\"; ${funcSourceUrl(schema, opts)}`)\n      destructureValCxtES5(gen, opts)\n      gen.code(body)\n    })\n  } else {\n    gen.func(validateName, _`${N.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () =>\n      gen.code(funcSourceUrl(schema, opts)).code(body)\n    )\n  }\n}\n\nfunction destructureValCxt(opts: InstanceOptions): Code {\n  return _`{${N.instancePath}=\"\", ${N.parentData}, ${N.parentDataProperty}, ${N.rootData}=${\n    N.data\n  }${opts.dynamicRef ? _`, ${N.dynamicAnchors}={}` : nil}}={}`\n}\n\nfunction destructureValCxtES5(gen: CodeGen, opts: InstanceOptions): void {\n  gen.if(\n    N.valCxt,\n    () => {\n      gen.var(N.instancePath, _`${N.valCxt}.${N.instancePath}`)\n      gen.var(N.parentData, _`${N.valCxt}.${N.parentData}`)\n      gen.var(N.parentDataProperty, _`${N.valCxt}.${N.parentDataProperty}`)\n      gen.var(N.rootData, _`${N.valCxt}.${N.rootData}`)\n      if (opts.dynamicRef) gen.var(N.dynamicAnchors, _`${N.valCxt}.${N.dynamicAnchors}`)\n    },\n    () => {\n      gen.var(N.instancePath, _`\"\"`)\n      gen.var(N.parentData, _`undefined`)\n      gen.var(N.parentDataProperty, _`undefined`)\n      gen.var(N.rootData, N.data)\n      if (opts.dynamicRef) gen.var(N.dynamicAnchors, _`{}`)\n    }\n  )\n}\n\nfunction topSchemaObjCode(it: SchemaObjCxt): void {\n  const {schema, opts, gen} = it\n  validateFunction(it, () => {\n    if (opts.$comment && schema.$comment) commentKeyword(it)\n    checkNoDefault(it)\n    gen.let(N.vErrors, null)\n    gen.let(N.errors, 0)\n    if (opts.unevaluated) resetEvaluated(it)\n    typeAndKeywords(it)\n    returnResults(it)\n  })\n  return\n}\n\nfunction resetEvaluated(it: SchemaObjCxt): void {\n  // TODO maybe some hook to execute it in the end to check whether props/items are Name, as in assignEvaluated\n  const {gen, validateName} = it\n  it.evaluated = gen.const(\"evaluated\", _`${validateName}.evaluated`)\n  gen.if(_`${it.evaluated}.dynamicProps`, () => gen.assign(_`${it.evaluated}.props`, _`undefined`))\n  gen.if(_`${it.evaluated}.dynamicItems`, () => gen.assign(_`${it.evaluated}.items`, _`undefined`))\n}\n\nfunction funcSourceUrl(schema: AnySchema, opts: InstanceOptions): Code {\n  const schId = typeof schema == \"object\" && schema[opts.schemaId]\n  return schId && (opts.code.source || opts.code.process) ? _`/*# sourceURL=${schId} */` : nil\n}\n\n// schema compilation - this function is used recursively to generate code for sub-schemas\nfunction subschemaCode(it: SchemaCxt, valid: Name): void {\n  if (isSchemaObj(it)) {\n    checkKeywords(it)\n    if (schemaCxtHasRules(it)) {\n      subSchemaObjCode(it, valid)\n      return\n    }\n  }\n  boolOrEmptySchema(it, valid)\n}\n\nfunction schemaCxtHasRules({schema, self}: SchemaCxt): boolean {\n  if (typeof schema == \"boolean\") return !schema\n  for (const key in schema) if (self.RULES.all[key]) return true\n  return false\n}\n\nfunction isSchemaObj(it: SchemaCxt): it is SchemaObjCxt {\n  return typeof it.schema != \"boolean\"\n}\n\nfunction subSchemaObjCode(it: SchemaObjCxt, valid: Name): void {\n  const {schema, gen, opts} = it\n  if (opts.$comment && schema.$comment) commentKeyword(it)\n  updateContext(it)\n  checkAsyncSchema(it)\n  const errsCount = gen.const(\"_errs\", N.errors)\n  typeAndKeywords(it, errsCount)\n  // TODO var\n  gen.var(valid, _`${errsCount} === ${N.errors}`)\n}\n\nfunction checkKeywords(it: SchemaObjCxt): void {\n  checkUnknownRules(it)\n  checkRefsAndKeywords(it)\n}\n\nfunction typeAndKeywords(it: SchemaObjCxt, errsCount?: Name): void {\n  if (it.opts.jtd) return schemaKeywords(it, [], false, errsCount)\n  const types = getSchemaTypes(it.schema)\n  const checkedTypes = coerceAndCheckDataType(it, types)\n  schemaKeywords(it, types, !checkedTypes, errsCount)\n}\n\nfunction checkRefsAndKeywords(it: SchemaObjCxt): void {\n  const {schema, errSchemaPath, opts, self} = it\n  if (schema.$ref && opts.ignoreKeywordsWithRef && schemaHasRulesButRef(schema, self.RULES)) {\n    self.logger.warn(`$ref: keywords ignored in schema at path \"${errSchemaPath}\"`)\n  }\n}\n\nfunction checkNoDefault(it: SchemaObjCxt): void {\n  const {schema, opts} = it\n  if (schema.default !== undefined && opts.useDefaults && opts.strictSchema) {\n    checkStrictMode(it, \"default is ignored in the schema root\")\n  }\n}\n\nfunction updateContext(it: SchemaObjCxt): void {\n  const schId = it.schema[it.opts.schemaId]\n  if (schId) it.baseId = resolveUrl(it.opts.uriResolver, it.baseId, schId)\n}\n\nfunction checkAsyncSchema(it: SchemaObjCxt): void {\n  if (it.schema.$async && !it.schemaEnv.$async) throw new Error(\"async schema in sync schema\")\n}\n\nfunction commentKeyword({gen, schemaEnv, schema, errSchemaPath, opts}: SchemaObjCxt): void {\n  const msg = schema.$comment\n  if (opts.$comment === true) {\n    gen.code(_`${N.self}.logger.log(${msg})`)\n  } else if (typeof opts.$comment == \"function\") {\n    const schemaPath = str`${errSchemaPath}/$comment`\n    const rootName = gen.scopeValue(\"root\", {ref: schemaEnv.root})\n    gen.code(_`${N.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`)\n  }\n}\n\nfunction returnResults(it: SchemaCxt): void {\n  const {gen, schemaEnv, validateName, ValidationError, opts} = it\n  if (schemaEnv.$async) {\n    // TODO assign unevaluated\n    gen.if(\n      _`${N.errors} === 0`,\n      () => gen.return(N.data),\n      () => gen.throw(_`new ${ValidationError as Name}(${N.vErrors})`)\n    )\n  } else {\n    gen.assign(_`${validateName}.errors`, N.vErrors)\n    if (opts.unevaluated) assignEvaluated(it)\n    gen.return(_`${N.errors} === 0`)\n  }\n}\n\nfunction assignEvaluated({gen, evaluated, props, items}: SchemaCxt): void {\n  if (props instanceof Name) gen.assign(_`${evaluated}.props`, props)\n  if (items instanceof Name) gen.assign(_`${evaluated}.items`, items)\n}\n\nfunction schemaKeywords(\n  it: SchemaObjCxt,\n  types: JSONType[],\n  typeErrors: boolean,\n  errsCount?: Name\n): void {\n  const {gen, schema, data, allErrors, opts, self} = it\n  const {RULES} = self\n  if (schema.$ref && (opts.ignoreKeywordsWithRef || !schemaHasRulesButRef(schema, RULES))) {\n    gen.block(() => keywordCode(it, \"$ref\", (RULES.all.$ref as Rule).definition)) // TODO typecast\n    return\n  }\n  if (!opts.jtd) checkStrictTypes(it, types)\n  gen.block(() => {\n    for (const group of RULES.rules) groupKeywords(group)\n    groupKeywords(RULES.post)\n  })\n\n  function groupKeywords(group: RuleGroup): void {\n    if (!shouldUseGroup(schema, group)) return\n    if (group.type) {\n      gen.if(checkDataType(group.type, data, opts.strictNumbers))\n      iterateKeywords(it, group)\n      if (types.length === 1 && types[0] === group.type && typeErrors) {\n        gen.else()\n        reportTypeError(it)\n      }\n      gen.endIf()\n    } else {\n      iterateKeywords(it, group)\n    }\n    // TODO make it \"ok\" call?\n    if (!allErrors) gen.if(_`${N.errors} === ${errsCount || 0}`)\n  }\n}\n\nfunction iterateKeywords(it: SchemaObjCxt, group: RuleGroup): void {\n  const {\n    gen,\n    schema,\n    opts: {useDefaults},\n  } = it\n  if (useDefaults) assignDefaults(it, group.type)\n  gen.block(() => {\n    for (const rule of group.rules) {\n      if (shouldUseRule(schema, rule)) {\n        keywordCode(it, rule.keyword, rule.definition, group.type)\n      }\n    }\n  })\n}\n\nfunction checkStrictTypes(it: SchemaObjCxt, types: JSONType[]): void {\n  if (it.schemaEnv.meta || !it.opts.strictTypes) return\n  checkContextTypes(it, types)\n  if (!it.opts.allowUnionTypes) checkMultipleTypes(it, types)\n  checkKeywordTypes(it, it.dataTypes)\n}\n\nfunction checkContextTypes(it: SchemaObjCxt, types: JSONType[]): void {\n  if (!types.length) return\n  if (!it.dataTypes.length) {\n    it.dataTypes = types\n    return\n  }\n  types.forEach((t) => {\n    if (!includesType(it.dataTypes, t)) {\n      strictTypesError(it, `type \"${t}\" not allowed by context \"${it.dataTypes.join(\",\")}\"`)\n    }\n  })\n  narrowSchemaTypes(it, types)\n}\n\nfunction checkMultipleTypes(it: SchemaObjCxt, ts: JSONType[]): void {\n  if (ts.length > 1 && !(ts.length === 2 && ts.includes(\"null\"))) {\n    strictTypesError(it, \"use allowUnionTypes to allow union type keyword\")\n  }\n}\n\nfunction checkKeywordTypes(it: SchemaObjCxt, ts: JSONType[]): void {\n  const rules = it.self.RULES.all\n  for (const keyword in rules) {\n    const rule = rules[keyword]\n    if (typeof rule == \"object\" && shouldUseRule(it.schema, rule)) {\n      const {type} = rule.definition\n      if (type.length && !type.some((t) => hasApplicableType(ts, t))) {\n        strictTypesError(it, `missing type \"${type.join(\",\")}\" for keyword \"${keyword}\"`)\n      }\n    }\n  }\n}\n\nfunction hasApplicableType(schTs: JSONType[], kwdT: JSONType): boolean {\n  return schTs.includes(kwdT) || (kwdT === \"number\" && schTs.includes(\"integer\"))\n}\n\nfunction includesType(ts: JSONType[], t: JSONType): boolean {\n  return ts.includes(t) || (t === \"integer\" && ts.includes(\"number\"))\n}\n\nfunction narrowSchemaTypes(it: SchemaObjCxt, withTypes: JSONType[]): void {\n  const ts: JSONType[] = []\n  for (const t of it.dataTypes) {\n    if (includesType(withTypes, t)) ts.push(t)\n    else if (withTypes.includes(\"integer\") && t === \"number\") ts.push(\"integer\")\n  }\n  it.dataTypes = ts\n}\n\nfunction strictTypesError(it: SchemaObjCxt, msg: string): void {\n  const schemaPath = it.schemaEnv.baseId + it.errSchemaPath\n  msg += ` at \"${schemaPath}\" (strictTypes)`\n  checkStrictMode(it, msg, it.opts.strictTypes)\n}\n\nexport class KeywordCxt implements KeywordErrorCxt {\n  readonly gen: CodeGen\n  readonly allErrors?: boolean\n  readonly keyword: string\n  readonly data: Name // Name referencing the current level of the data instance\n  readonly $data?: string | false\n  schema: any // keyword value in the schema\n  readonly schemaValue: Code | number | boolean // Code reference to keyword schema value or primitive value\n  readonly schemaCode: Code | number | boolean // Code reference to resolved schema value (different if schema is $data)\n  readonly schemaType: JSONType[] // allowed type(s) of keyword value in the schema\n  readonly parentSchema: AnySchemaObject\n  readonly errsCount?: Name // Name reference to the number of validation errors collected before this keyword,\n  // requires option trackErrors in keyword definition\n  params: KeywordCxtParams // object to pass parameters to error messages from keyword code\n  readonly it: SchemaObjCxt // schema compilation context (schema is guaranteed to be an object, not boolean)\n  readonly def: AddedKeywordDefinition\n\n  constructor(it: SchemaObjCxt, def: AddedKeywordDefinition, keyword: string) {\n    validateKeywordUsage(it, def, keyword)\n    this.gen = it.gen\n    this.allErrors = it.allErrors\n    this.keyword = keyword\n    this.data = it.data\n    this.schema = it.schema[keyword]\n    this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data\n    this.schemaValue = schemaRefOrVal(it, this.schema, keyword, this.$data)\n    this.schemaType = def.schemaType\n    this.parentSchema = it.schema\n    this.params = {}\n    this.it = it\n    this.def = def\n\n    if (this.$data) {\n      this.schemaCode = it.gen.const(\"vSchema\", getData(this.$data, it))\n    } else {\n      this.schemaCode = this.schemaValue\n      if (!validSchemaType(this.schema, def.schemaType, def.allowUndefined)) {\n        throw new Error(`${keyword} value must be ${JSON.stringify(def.schemaType)}`)\n      }\n    }\n\n    if (\"code\" in def ? def.trackErrors : def.errors !== false) {\n      this.errsCount = it.gen.const(\"_errs\", N.errors)\n    }\n  }\n\n  result(condition: Code, successAction?: () => void, failAction?: () => void): void {\n    this.failResult(not(condition), successAction, failAction)\n  }\n\n  failResult(condition: Code, successAction?: () => void, failAction?: () => void): void {\n    this.gen.if(condition)\n    if (failAction) failAction()\n    else this.error()\n    if (successAction) {\n      this.gen.else()\n      successAction()\n      if (this.allErrors) this.gen.endIf()\n    } else {\n      if (this.allErrors) this.gen.endIf()\n      else this.gen.else()\n    }\n  }\n\n  pass(condition: Code, failAction?: () => void): void {\n    this.failResult(not(condition), undefined, failAction)\n  }\n\n  fail(condition?: Code): void {\n    if (condition === undefined) {\n      this.error()\n      if (!this.allErrors) this.gen.if(false) // this branch will be removed by gen.optimize\n      return\n    }\n    this.gen.if(condition)\n    this.error()\n    if (this.allErrors) this.gen.endIf()\n    else this.gen.else()\n  }\n\n  fail$data(condition: Code): void {\n    if (!this.$data) return this.fail(condition)\n    const {schemaCode} = this\n    this.fail(_`${schemaCode} !== undefined && (${or(this.invalid$data(), condition)})`)\n  }\n\n  error(append?: boolean, errorParams?: KeywordCxtParams, errorPaths?: ErrorPaths): void {\n    if (errorParams) {\n      this.setParams(errorParams)\n      this._error(append, errorPaths)\n      this.setParams({})\n      return\n    }\n    this._error(append, errorPaths)\n  }\n\n  private _error(append?: boolean, errorPaths?: ErrorPaths): void {\n    ;(append ? reportExtraError : reportError)(this, this.def.error, errorPaths)\n  }\n\n  $dataError(): void {\n    reportError(this, this.def.$dataError || keyword$DataError)\n  }\n\n  reset(): void {\n    if (this.errsCount === undefined) throw new Error('add \"trackErrors\" to keyword definition')\n    resetErrorsCount(this.gen, this.errsCount)\n  }\n\n  ok(cond: Code | boolean): void {\n    if (!this.allErrors) this.gen.if(cond)\n  }\n\n  setParams(obj: KeywordCxtParams, assign?: true): void {\n    if (assign) Object.assign(this.params, obj)\n    else this.params = obj\n  }\n\n  block$data(valid: Name, codeBlock: () => void, $dataValid: Code = nil): void {\n    this.gen.block(() => {\n      this.check$data(valid, $dataValid)\n      codeBlock()\n    })\n  }\n\n  check$data(valid: Name = nil, $dataValid: Code = nil): void {\n    if (!this.$data) return\n    const {gen, schemaCode, schemaType, def} = this\n    gen.if(or(_`${schemaCode} === undefined`, $dataValid))\n    if (valid !== nil) gen.assign(valid, true)\n    if (schemaType.length || def.validateSchema) {\n      gen.elseIf(this.invalid$data())\n      this.$dataError()\n      if (valid !== nil) gen.assign(valid, false)\n    }\n    gen.else()\n  }\n\n  invalid$data(): Code {\n    const {gen, schemaCode, schemaType, def, it} = this\n    return or(wrong$DataType(), invalid$DataSchema())\n\n    function wrong$DataType(): Code {\n      if (schemaType.length) {\n        /* istanbul ignore if */\n        if (!(schemaCode instanceof Name)) throw new Error(\"ajv implementation error\")\n        const st = Array.isArray(schemaType) ? schemaType : [schemaType]\n        return _`${checkDataTypes(st, schemaCode, it.opts.strictNumbers, DataType.Wrong)}`\n      }\n      return nil\n    }\n\n    function invalid$DataSchema(): Code {\n      if (def.validateSchema) {\n        const validateSchemaRef = gen.scopeValue(\"validate$data\", {ref: def.validateSchema}) // TODO value.code for standalone\n        return _`!${validateSchemaRef}(${schemaCode})`\n      }\n      return nil\n    }\n  }\n\n  subschema(appl: SubschemaArgs, valid: Name): SchemaCxt {\n    const subschema = getSubschema(this.it, appl)\n    extendSubschemaData(subschema, this.it, appl)\n    extendSubschemaMode(subschema, appl)\n    const nextContext = {...this.it, ...subschema, items: undefined, props: undefined}\n    subschemaCode(nextContext, valid)\n    return nextContext\n  }\n\n  mergeEvaluated(schemaCxt: SchemaCxt, toName?: typeof Name): void {\n    const {it, gen} = this\n    if (!it.opts.unevaluated) return\n    if (it.props !== true && schemaCxt.props !== undefined) {\n      it.props = mergeEvaluated.props(gen, schemaCxt.props, it.props, toName)\n    }\n    if (it.items !== true && schemaCxt.items !== undefined) {\n      it.items = mergeEvaluated.items(gen, schemaCxt.items, it.items, toName)\n    }\n  }\n\n  mergeValidEvaluated(schemaCxt: SchemaCxt, valid: Name): boolean | void {\n    const {it, gen} = this\n    if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {\n      gen.if(valid, () => this.mergeEvaluated(schemaCxt, Name))\n      return true\n    }\n  }\n}\n\nfunction keywordCode(\n  it: SchemaObjCxt,\n  keyword: string,\n  def: AddedKeywordDefinition,\n  ruleType?: JSONType\n): void {\n  const cxt = new KeywordCxt(it, def, keyword)\n  if (\"code\" in def) {\n    def.code(cxt, ruleType)\n  } else if (cxt.$data && def.validate) {\n    funcKeywordCode(cxt, def)\n  } else if (\"macro\" in def) {\n    macroKeywordCode(cxt, def)\n  } else if (def.compile || def.validate) {\n    funcKeywordCode(cxt, def)\n  }\n}\n\nconst JSON_POINTER = /^\\/(?:[^~]|~0|~1)*$/\nconst RELATIVE_JSON_POINTER = /^([0-9]+)(#|\\/(?:[^~]|~0|~1)*)?$/\nexport function getData(\n  $data: string,\n  {dataLevel, dataNames, dataPathArr}: SchemaCxt\n): Code | number {\n  let jsonPointer\n  let data: Code\n  if ($data === \"\") return N.rootData\n  if ($data[0] === \"/\") {\n    if (!JSON_POINTER.test($data)) throw new Error(`Invalid JSON-pointer: ${$data}`)\n    jsonPointer = $data\n    data = N.rootData\n  } else {\n    const matches = RELATIVE_JSON_POINTER.exec($data)\n    if (!matches) throw new Error(`Invalid JSON-pointer: ${$data}`)\n    const up: number = +matches[1]\n    jsonPointer = matches[2]\n    if (jsonPointer === \"#\") {\n      if (up >= dataLevel) throw new Error(errorMsg(\"property/index\", up))\n      return dataPathArr[dataLevel - up]\n    }\n    if (up > dataLevel) throw new Error(errorMsg(\"data\", up))\n    data = dataNames[dataLevel - up]\n    if (!jsonPointer) return data\n  }\n\n  let expr = data\n  const segments = jsonPointer.split(\"/\")\n  for (const segment of segments) {\n    if (segment) {\n      data = _`${data}${getProperty(unescapeJsonPointer(segment))}`\n      expr = _`${expr} && ${data}`\n    }\n  }\n  return expr\n\n  function errorMsg(pointerType: string, up: number): string {\n    return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`\n  }\n}\n","import type {KeywordCxt} from \".\"\nimport type {\n  AnySchema,\n  SchemaValidateFunction,\n  AnyValidateFunction,\n  AddedKeywordDefinition,\n  MacroKeywordDefinition,\n  FuncKeywordDefinition,\n} from \"../../types\"\nimport type {SchemaObjCxt} from \"..\"\nimport {_, nil, not, stringify, Code, Name, CodeGen} from \"../codegen\"\nimport N from \"../names\"\nimport type {JSONType} from \"../rules\"\nimport {callValidateCode} from \"../../vocabularies/code\"\nimport {extendErrors} from \"../errors\"\n\ntype KeywordCompilationResult = AnySchema | SchemaValidateFunction | AnyValidateFunction\n\nexport function macroKeywordCode(cxt: KeywordCxt, def: MacroKeywordDefinition): void {\n  const {gen, keyword, schema, parentSchema, it} = cxt\n  const macroSchema = def.macro.call(it.self, schema, parentSchema, it)\n  const schemaRef = useKeyword(gen, keyword, macroSchema)\n  if (it.opts.validateSchema !== false) it.self.validateSchema(macroSchema, true)\n\n  const valid = gen.name(\"valid\")\n  cxt.subschema(\n    {\n      schema: macroSchema,\n      schemaPath: nil,\n      errSchemaPath: `${it.errSchemaPath}/${keyword}`,\n      topSchemaRef: schemaRef,\n      compositeRule: true,\n    },\n    valid\n  )\n  cxt.pass(valid, () => cxt.error(true))\n}\n\nexport function funcKeywordCode(cxt: KeywordCxt, def: FuncKeywordDefinition): void {\n  const {gen, keyword, schema, parentSchema, $data, it} = cxt\n  checkAsyncKeyword(it, def)\n  const validate =\n    !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate\n  const validateRef = useKeyword(gen, keyword, validate)\n  const valid = gen.let(\"valid\")\n  cxt.block$data(valid, validateKeyword)\n  cxt.ok(def.valid ?? valid)\n\n  function validateKeyword(): void {\n    if (def.errors === false) {\n      assignValid()\n      if (def.modifying) modifyData(cxt)\n      reportErrs(() => cxt.error())\n    } else {\n      const ruleErrs = def.async ? validateAsync() : validateSync()\n      if (def.modifying) modifyData(cxt)\n      reportErrs(() => addErrs(cxt, ruleErrs))\n    }\n  }\n\n  function validateAsync(): Name {\n    const ruleErrs = gen.let(\"ruleErrs\", null)\n    gen.try(\n      () => assignValid(_`await `),\n      (e) =>\n        gen.assign(valid, false).if(\n          _`${e} instanceof ${it.ValidationError as Name}`,\n          () => gen.assign(ruleErrs, _`${e}.errors`),\n          () => gen.throw(e)\n        )\n    )\n    return ruleErrs\n  }\n\n  function validateSync(): Code {\n    const validateErrs = _`${validateRef}.errors`\n    gen.assign(validateErrs, null)\n    assignValid(nil)\n    return validateErrs\n  }\n\n  function assignValid(_await: Code = def.async ? _`await ` : nil): void {\n    const passCxt = it.opts.passContext ? N.this : N.self\n    const passSchema = !((\"compile\" in def && !$data) || def.schema === false)\n    gen.assign(\n      valid,\n      _`${_await}${callValidateCode(cxt, validateRef, passCxt, passSchema)}`,\n      def.modifying\n    )\n  }\n\n  function reportErrs(errors: () => void): void {\n    gen.if(not(def.valid ?? valid), errors)\n  }\n}\n\nfunction modifyData(cxt: KeywordCxt): void {\n  const {gen, data, it} = cxt\n  gen.if(it.parentData, () => gen.assign(data, _`${it.parentData}[${it.parentDataProperty}]`))\n}\n\nfunction addErrs(cxt: KeywordCxt, errs: Code): void {\n  const {gen} = cxt\n  gen.if(\n    _`Array.isArray(${errs})`,\n    () => {\n      gen\n        .assign(N.vErrors, _`${N.vErrors} === null ? ${errs} : ${N.vErrors}.concat(${errs})`)\n        .assign(N.errors, _`${N.vErrors}.length`)\n      extendErrors(cxt)\n    },\n    () => cxt.error()\n  )\n}\n\nfunction checkAsyncKeyword({schemaEnv}: SchemaObjCxt, def: FuncKeywordDefinition): void {\n  if (def.async && !schemaEnv.$async) throw new Error(\"async keyword in sync schema\")\n}\n\nfunction useKeyword(gen: CodeGen, keyword: string, result?: KeywordCompilationResult): Name {\n  if (result === undefined) throw new Error(`keyword \"${keyword}\" failed to compile`)\n  return gen.scopeValue(\n    \"keyword\",\n    typeof result == \"function\" ? {ref: result} : {ref: result, code: stringify(result)}\n  )\n}\n\nexport function validSchemaType(\n  schema: unknown,\n  schemaType: JSONType[],\n  allowUndefined = false\n): boolean {\n  // TODO add tests\n  return (\n    !schemaType.length ||\n    schemaType.some((st) =>\n      st === \"array\"\n        ? Array.isArray(schema)\n        : st === \"object\"\n        ? schema && typeof schema == \"object\" && !Array.isArray(schema)\n        : typeof schema == st || (allowUndefined && typeof schema == \"undefined\")\n    )\n  )\n}\n\nexport function validateKeywordUsage(\n  {schema, opts, self, errSchemaPath}: SchemaObjCxt,\n  def: AddedKeywordDefinition,\n  keyword: string\n): void {\n  /* istanbul ignore if */\n  if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {\n    throw new Error(\"ajv implementation error\")\n  }\n\n  const deps = def.dependencies\n  if (deps?.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {\n    throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(\",\")}`)\n  }\n\n  if (def.validateSchema) {\n    const valid = def.validateSchema(schema[keyword])\n    if (!valid) {\n      const msg =\n        `keyword \"${keyword}\" value is invalid at path \"${errSchemaPath}\": ` +\n        self.errorsText(def.validateSchema.errors)\n      if (opts.validateSchema === \"log\") self.logger.error(msg)\n      else throw new Error(msg)\n    }\n  }\n}\n","import type {AnySchema} from \"../../types\"\nimport type {SchemaObjCxt} from \"..\"\nimport {_, str, getProperty, Code, Name} from \"../codegen\"\nimport {escapeFragment, getErrorPath, Type} from \"../util\"\nimport type {JSONType} from \"../rules\"\n\nexport interface SubschemaContext {\n  // TODO use Optional? align with SchemCxt property types\n  schema: AnySchema\n  schemaPath: Code\n  errSchemaPath: string\n  topSchemaRef?: Code\n  errorPath?: Code\n  dataLevel?: number\n  dataTypes?: JSONType[]\n  data?: Name\n  parentData?: Name\n  parentDataProperty?: Code | number\n  dataNames?: Name[]\n  dataPathArr?: (Code | number)[]\n  propertyName?: Name\n  jtdDiscriminator?: string\n  jtdMetadata?: boolean\n  compositeRule?: true\n  createErrors?: boolean\n  allErrors?: boolean\n}\n\nexport type SubschemaArgs = Partial<{\n  keyword: string\n  schemaProp: string | number\n  schema: AnySchema\n  schemaPath: Code\n  errSchemaPath: string\n  topSchemaRef: Code\n  data: Name | Code\n  dataProp: Code | string | number\n  dataTypes: JSONType[]\n  definedProperties: Set<string>\n  propertyName: Name\n  dataPropType: Type\n  jtdDiscriminator: string\n  jtdMetadata: boolean\n  compositeRule: true\n  createErrors: boolean\n  allErrors: boolean\n}>\n\nexport function getSubschema(\n  it: SchemaObjCxt,\n  {keyword, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef}: SubschemaArgs\n): SubschemaContext {\n  if (keyword !== undefined && schema !== undefined) {\n    throw new Error('both \"keyword\" and \"schema\" passed, only one allowed')\n  }\n\n  if (keyword !== undefined) {\n    const sch = it.schema[keyword]\n    return schemaProp === undefined\n      ? {\n          schema: sch,\n          schemaPath: _`${it.schemaPath}${getProperty(keyword)}`,\n          errSchemaPath: `${it.errSchemaPath}/${keyword}`,\n        }\n      : {\n          schema: sch[schemaProp],\n          schemaPath: _`${it.schemaPath}${getProperty(keyword)}${getProperty(schemaProp)}`,\n          errSchemaPath: `${it.errSchemaPath}/${keyword}/${escapeFragment(schemaProp)}`,\n        }\n  }\n\n  if (schema !== undefined) {\n    if (schemaPath === undefined || errSchemaPath === undefined || topSchemaRef === undefined) {\n      throw new Error('\"schemaPath\", \"errSchemaPath\" and \"topSchemaRef\" are required with \"schema\"')\n    }\n    return {\n      schema,\n      schemaPath,\n      topSchemaRef,\n      errSchemaPath,\n    }\n  }\n\n  throw new Error('either \"keyword\" or \"schema\" must be passed')\n}\n\nexport function extendSubschemaData(\n  subschema: SubschemaContext,\n  it: SchemaObjCxt,\n  {dataProp, dataPropType: dpType, data, dataTypes, propertyName}: SubschemaArgs\n): void {\n  if (data !== undefined && dataProp !== undefined) {\n    throw new Error('both \"data\" and \"dataProp\" passed, only one allowed')\n  }\n\n  const {gen} = it\n\n  if (dataProp !== undefined) {\n    const {errorPath, dataPathArr, opts} = it\n    const nextData = gen.let(\"data\", _`${it.data}${getProperty(dataProp)}`, true)\n    dataContextProps(nextData)\n    subschema.errorPath = str`${errorPath}${getErrorPath(dataProp, dpType, opts.jsPropertySyntax)}`\n    subschema.parentDataProperty = _`${dataProp}`\n    subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty]\n  }\n\n  if (data !== undefined) {\n    const nextData = data instanceof Name ? data : gen.let(\"data\", data, true) // replaceable if used once?\n    dataContextProps(nextData)\n    if (propertyName !== undefined) subschema.propertyName = propertyName\n    // TODO something is possibly wrong here with not changing parentDataProperty and not appending dataPathArr\n  }\n\n  if (dataTypes) subschema.dataTypes = dataTypes\n\n  function dataContextProps(_nextData: Name): void {\n    subschema.data = _nextData\n    subschema.dataLevel = it.dataLevel + 1\n    subschema.dataTypes = []\n    it.definedProperties = new Set<string>()\n    subschema.parentData = it.data\n    subschema.dataNames = [...it.dataNames, _nextData]\n  }\n}\n\nexport function extendSubschemaMode(\n  subschema: SubschemaContext,\n  {jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors}: SubschemaArgs\n): void {\n  if (compositeRule !== undefined) subschema.compositeRule = compositeRule\n  if (createErrors !== undefined) subschema.createErrors = createErrors\n  if (allErrors !== undefined) subschema.allErrors = allErrors\n  subschema.jtdDiscriminator = jtdDiscriminator // not inherited\n  subschema.jtdMetadata = jtdMetadata // not inherited\n}\n","export {\n  Format,\n  FormatDefinition,\n  AsyncFormatDefinition,\n  KeywordDefinition,\n  KeywordErrorDefinition,\n  CodeKeywordDefinition,\n  MacroKeywordDefinition,\n  FuncKeywordDefinition,\n  Vocabulary,\n  Schema,\n  SchemaObject,\n  AnySchemaObject,\n  AsyncSchema,\n  AnySchema,\n  ValidateFunction,\n  AsyncValidateFunction,\n  AnyValidateFunction,\n  ErrorObject,\n  ErrorNoParams,\n} from \"./types\"\n\nexport {SchemaCxt, SchemaObjCxt} from \"./compile\"\nexport interface Plugin<Opts> {\n  (ajv: Ajv, options?: Opts): Ajv\n  [prop: string]: any\n}\n\nexport {KeywordCxt} from \"./compile/validate\"\nexport {DefinedError} from \"./vocabularies/errors\"\nexport {JSONType} from \"./compile/rules\"\nexport {JSONSchemaType} from \"./types/json-schema\"\nexport {JTDSchemaType, SomeJTDSchemaType, JTDDataType} from \"./types/jtd-schema\"\nexport {_, str, stringify, nil, Name, Code, CodeGen, CodeGenOptions} from \"./compile/codegen\"\n\nimport type {\n  Schema,\n  AnySchema,\n  AnySchemaObject,\n  SchemaObject,\n  AsyncSchema,\n  Vocabulary,\n  KeywordDefinition,\n  AddedKeywordDefinition,\n  AnyValidateFunction,\n  ValidateFunction,\n  AsyncValidateFunction,\n  ErrorObject,\n  Format,\n  AddedFormat,\n  RegExpEngine,\n  UriResolver,\n} from \"./types\"\nimport type {JSONSchemaType} from \"./types/json-schema\"\nimport type {JTDSchemaType, SomeJTDSchemaType, JTDDataType} from \"./types/jtd-schema\"\nimport ValidationError from \"./runtime/validation_error\"\nimport MissingRefError from \"./compile/ref_error\"\nimport {getRules, ValidationRules, Rule, RuleGroup, JSONType} from \"./compile/rules\"\nimport {SchemaEnv, compileSchema, resolveSchema} from \"./compile\"\nimport {Code, ValueScope} from \"./compile/codegen\"\nimport {normalizeId, getSchemaRefs} from \"./compile/resolve\"\nimport {getJSONTypes} from \"./compile/validate/dataType\"\nimport {eachItem} from \"./compile/util\"\nimport * as $dataRefSchema from \"./refs/data.json\"\n\nimport DefaultUriResolver from \"./runtime/uri\"\n\nconst defaultRegExp: RegExpEngine = (str, flags) => new RegExp(str, flags)\ndefaultRegExp.code = \"new RegExp\"\n\nconst META_IGNORE_OPTIONS: (keyof Options)[] = [\"removeAdditional\", \"useDefaults\", \"coerceTypes\"]\nconst EXT_SCOPE_NAMES = new Set([\n  \"validate\",\n  \"serialize\",\n  \"parse\",\n  \"wrapper\",\n  \"root\",\n  \"schema\",\n  \"keyword\",\n  \"pattern\",\n  \"formats\",\n  \"validate$data\",\n  \"func\",\n  \"obj\",\n  \"Error\",\n])\n\nexport type Options = CurrentOptions & DeprecatedOptions\n\nexport interface CurrentOptions {\n  // strict mode options (NEW)\n  strict?: boolean | \"log\"\n  strictSchema?: boolean | \"log\"\n  strictNumbers?: boolean | \"log\"\n  strictTypes?: boolean | \"log\"\n  strictTuples?: boolean | \"log\"\n  strictRequired?: boolean | \"log\"\n  allowMatchingProperties?: boolean // disables a strict mode restriction\n  allowUnionTypes?: boolean\n  validateFormats?: boolean\n  // validation and reporting options:\n  $data?: boolean\n  allErrors?: boolean\n  verbose?: boolean\n  discriminator?: boolean\n  unicodeRegExp?: boolean\n  timestamp?: \"string\" | \"date\" // JTD only\n  parseDate?: boolean // JTD only\n  allowDate?: boolean // JTD only\n  $comment?:\n    | true\n    | ((comment: string, schemaPath?: string, rootSchema?: AnySchemaObject) => unknown)\n  formats?: {[Name in string]?: Format}\n  keywords?: Vocabulary\n  schemas?: AnySchema[] | {[Key in string]?: AnySchema}\n  logger?: Logger | false\n  loadSchema?: (uri: string) => Promise<AnySchemaObject>\n  // options to modify validated data:\n  removeAdditional?: boolean | \"all\" | \"failing\"\n  useDefaults?: boolean | \"empty\"\n  coerceTypes?: boolean | \"array\"\n  // advanced options:\n  next?: boolean // NEW\n  unevaluated?: boolean // NEW\n  dynamicRef?: boolean // NEW\n  schemaId?: \"id\" | \"$id\"\n  jtd?: boolean // NEW\n  meta?: SchemaObject | boolean\n  defaultMeta?: string | AnySchemaObject\n  validateSchema?: boolean | \"log\"\n  addUsedSchema?: boolean\n  inlineRefs?: boolean | number\n  passContext?: boolean\n  loopRequired?: number\n  loopEnum?: number // NEW\n  ownProperties?: boolean\n  multipleOfPrecision?: number\n  int32range?: boolean // JTD only\n  messages?: boolean\n  code?: CodeOptions // NEW\n  uriResolver?: UriResolver\n}\n\nexport interface CodeOptions {\n  es5?: boolean\n  esm?: boolean\n  lines?: boolean\n  optimize?: boolean | number\n  formats?: Code // code to require (or construct) map of available formats - for standalone code\n  source?: boolean\n  process?: (code: string, schema?: SchemaEnv) => string\n  regExp?: RegExpEngine\n}\n\ninterface InstanceCodeOptions extends CodeOptions {\n  regExp: RegExpEngine\n  optimize: number\n}\n\ninterface DeprecatedOptions {\n  /** @deprecated */\n  ignoreKeywordsWithRef?: boolean\n  /** @deprecated */\n  jsPropertySyntax?: boolean // added instead of jsonPointers\n  /** @deprecated */\n  unicode?: boolean\n}\n\ninterface RemovedOptions {\n  format?: boolean\n  errorDataPath?: \"object\" | \"property\"\n  nullable?: boolean // \"nullable\" keyword is supported by default\n  jsonPointers?: boolean\n  extendRefs?: true | \"ignore\" | \"fail\"\n  missingRefs?: true | \"ignore\" | \"fail\"\n  processCode?: (code: string, schema?: SchemaEnv) => string\n  sourceCode?: boolean\n  strictDefaults?: boolean\n  strictKeywords?: boolean\n  uniqueItems?: boolean\n  unknownFormats?: true | string[] | \"ignore\"\n  cache?: any\n  serialize?: (schema: AnySchema) => unknown\n  ajvErrors?: boolean\n}\n\ntype OptionsInfo<T extends RemovedOptions | DeprecatedOptions> = {\n  [K in keyof T]-?: string | undefined\n}\n\nconst removedOptions: OptionsInfo<RemovedOptions> = {\n  errorDataPath: \"\",\n  format: \"`validateFormats: false` can be used instead.\",\n  nullable: '\"nullable\" keyword is supported by default.',\n  jsonPointers: \"Deprecated jsPropertySyntax can be used instead.\",\n  extendRefs: \"Deprecated ignoreKeywordsWithRef can be used instead.\",\n  missingRefs: \"Pass empty schema with $id that should be ignored to ajv.addSchema.\",\n  processCode: \"Use option `code: {process: (code, schemaEnv: object) => string}`\",\n  sourceCode: \"Use option `code: {source: true}`\",\n  strictDefaults: \"It is default now, see option `strict`.\",\n  strictKeywords: \"It is default now, see option `strict`.\",\n  uniqueItems: '\"uniqueItems\" keyword is always validated.',\n  unknownFormats: \"Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).\",\n  cache: \"Map is used as cache, schema object as key.\",\n  serialize: \"Map is used as cache, schema object as key.\",\n  ajvErrors: \"It is default now.\",\n}\n\nconst deprecatedOptions: OptionsInfo<DeprecatedOptions> = {\n  ignoreKeywordsWithRef: \"\",\n  jsPropertySyntax: \"\",\n  unicode: '\"minLength\"/\"maxLength\" account for unicode characters by default.',\n}\n\ntype RequiredInstanceOptions = {\n  [K in\n    | \"strictSchema\"\n    | \"strictNumbers\"\n    | \"strictTypes\"\n    | \"strictTuples\"\n    | \"strictRequired\"\n    | \"inlineRefs\"\n    | \"loopRequired\"\n    | \"loopEnum\"\n    | \"meta\"\n    | \"messages\"\n    | \"schemaId\"\n    | \"addUsedSchema\"\n    | \"validateSchema\"\n    | \"validateFormats\"\n    | \"int32range\"\n    | \"unicodeRegExp\"\n    | \"uriResolver\"]: NonNullable<Options[K]>\n} & {code: InstanceCodeOptions}\n\nexport type InstanceOptions = Options & RequiredInstanceOptions\n\nconst MAX_EXPRESSION = 200\n\n// eslint-disable-next-line complexity\nfunction requiredOptions(o: Options): RequiredInstanceOptions {\n  const s = o.strict\n  const _optz = o.code?.optimize\n  const optimize = _optz === true || _optz === undefined ? 1 : _optz || 0\n  const regExp = o.code?.regExp ?? defaultRegExp\n  const uriResolver = o.uriResolver ?? DefaultUriResolver\n  return {\n    strictSchema: o.strictSchema ?? s ?? true,\n    strictNumbers: o.strictNumbers ?? s ?? true,\n    strictTypes: o.strictTypes ?? s ?? \"log\",\n    strictTuples: o.strictTuples ?? s ?? \"log\",\n    strictRequired: o.strictRequired ?? s ?? false,\n    code: o.code ? {...o.code, optimize, regExp} : {optimize, regExp},\n    loopRequired: o.loopRequired ?? MAX_EXPRESSION,\n    loopEnum: o.loopEnum ?? MAX_EXPRESSION,\n    meta: o.meta ?? true,\n    messages: o.messages ?? true,\n    inlineRefs: o.inlineRefs ?? true,\n    schemaId: o.schemaId ?? \"$id\",\n    addUsedSchema: o.addUsedSchema ?? true,\n    validateSchema: o.validateSchema ?? true,\n    validateFormats: o.validateFormats ?? true,\n    unicodeRegExp: o.unicodeRegExp ?? true,\n    int32range: o.int32range ?? true,\n    uriResolver: uriResolver,\n  }\n}\n\nexport interface Logger {\n  log(...args: unknown[]): unknown\n  warn(...args: unknown[]): unknown\n  error(...args: unknown[]): unknown\n}\n\nexport default class Ajv {\n  opts: InstanceOptions\n  errors?: ErrorObject[] | null // errors from the last validation\n  logger: Logger\n  // shared external scope values for compiled functions\n  readonly scope: ValueScope\n  readonly schemas: {[Key in string]?: SchemaEnv} = {}\n  readonly refs: {[Ref in string]?: SchemaEnv | string} = {}\n  readonly formats: {[Name in string]?: AddedFormat} = {}\n  readonly RULES: ValidationRules\n  readonly _compilations: Set<SchemaEnv> = new Set()\n  private readonly _loading: {[Ref in string]?: Promise<AnySchemaObject>} = {}\n  private readonly _cache: Map<AnySchema, SchemaEnv> = new Map()\n  private readonly _metaOpts: InstanceOptions\n\n  static ValidationError = ValidationError\n  static MissingRefError = MissingRefError\n\n  constructor(opts: Options = {}) {\n    opts = this.opts = {...opts, ...requiredOptions(opts)}\n    const {es5, lines} = this.opts.code\n\n    this.scope = new ValueScope({scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines})\n    this.logger = getLogger(opts.logger)\n    const formatOpt = opts.validateFormats\n    opts.validateFormats = false\n\n    this.RULES = getRules()\n    checkOptions.call(this, removedOptions, opts, \"NOT SUPPORTED\")\n    checkOptions.call(this, deprecatedOptions, opts, \"DEPRECATED\", \"warn\")\n    this._metaOpts = getMetaSchemaOptions.call(this)\n\n    if (opts.formats) addInitialFormats.call(this)\n    this._addVocabularies()\n    this._addDefaultMetaSchema()\n    if (opts.keywords) addInitialKeywords.call(this, opts.keywords)\n    if (typeof opts.meta == \"object\") this.addMetaSchema(opts.meta)\n    addInitialSchemas.call(this)\n    opts.validateFormats = formatOpt\n  }\n\n  _addVocabularies(): void {\n    this.addKeyword(\"$async\")\n  }\n\n  _addDefaultMetaSchema(): void {\n    const {$data, meta, schemaId} = this.opts\n    let _dataRefSchema: SchemaObject = $dataRefSchema\n    if (schemaId === \"id\") {\n      _dataRefSchema = {...$dataRefSchema}\n      _dataRefSchema.id = _dataRefSchema.$id\n      delete _dataRefSchema.$id\n    }\n    if (meta && $data) this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false)\n  }\n\n  defaultMeta(): string | AnySchemaObject | undefined {\n    const {meta, schemaId} = this.opts\n    return (this.opts.defaultMeta = typeof meta == \"object\" ? meta[schemaId] || meta : undefined)\n  }\n\n  // Validate data using schema\n  // AnySchema will be compiled and cached using schema itself as a key for Map\n  validate(schema: Schema | string, data: unknown): boolean\n  validate(schemaKeyRef: AnySchema | string, data: unknown): boolean | Promise<unknown>\n  validate<T>(schema: Schema | JSONSchemaType<T> | string, data: unknown): data is T\n  // Separated for type inference to work\n  // eslint-disable-next-line @typescript-eslint/unified-signatures\n  validate<T>(schema: JTDSchemaType<T>, data: unknown): data is T\n  // This overload is only intended for typescript inference, the first\n  // argument prevents manual type annotation from matching this overload\n  validate<N extends never, T extends SomeJTDSchemaType>(\n    schema: T,\n    data: unknown\n  ): data is JTDDataType<T>\n  validate<T>(schema: AsyncSchema, data: unknown | T): Promise<T>\n  validate<T>(schemaKeyRef: AnySchema | string, data: unknown): data is T | Promise<T>\n  validate<T>(\n    schemaKeyRef: AnySchema | string, // key, ref or schema object\n    data: unknown | T // to be validated\n  ): boolean | Promise<T> {\n    let v: AnyValidateFunction | undefined\n    if (typeof schemaKeyRef == \"string\") {\n      v = this.getSchema<T>(schemaKeyRef)\n      if (!v) throw new Error(`no schema with key or ref \"${schemaKeyRef}\"`)\n    } else {\n      v = this.compile<T>(schemaKeyRef)\n    }\n\n    const valid = v(data)\n    if (!(\"$async\" in v)) this.errors = v.errors\n    return valid\n  }\n\n  // Create validation function for passed schema\n  // _meta: true if schema is a meta-schema. Used internally to compile meta schemas of user-defined keywords.\n  compile<T = unknown>(schema: Schema | JSONSchemaType<T>, _meta?: boolean): ValidateFunction<T>\n  // Separated for type inference to work\n  // eslint-disable-next-line @typescript-eslint/unified-signatures\n  compile<T = unknown>(schema: JTDSchemaType<T>, _meta?: boolean): ValidateFunction<T>\n  // This overload is only intended for typescript inference, the first\n  // argument prevents manual type annotation from matching this overload\n  compile<N extends never, T extends SomeJTDSchemaType>(\n    schema: T,\n    _meta?: boolean\n  ): ValidateFunction<JTDDataType<T>>\n  compile<T = unknown>(schema: AsyncSchema, _meta?: boolean): AsyncValidateFunction<T>\n  compile<T = unknown>(schema: AnySchema, _meta?: boolean): AnyValidateFunction<T>\n  compile<T = unknown>(schema: AnySchema, _meta?: boolean): AnyValidateFunction<T> {\n    const sch = this._addSchema(schema, _meta)\n    return (sch.validate || this._compileSchemaEnv(sch)) as AnyValidateFunction<T>\n  }\n\n  // Creates validating function for passed schema with asynchronous loading of missing schemas.\n  // `loadSchema` option should be a function that accepts schema uri and returns promise that resolves with the schema.\n  // TODO allow passing schema URI\n  // meta - optional true to compile meta-schema\n  compileAsync<T = unknown>(\n    schema: SchemaObject | JSONSchemaType<T>,\n    _meta?: boolean\n  ): Promise<ValidateFunction<T>>\n  // Separated for type inference to work\n  // eslint-disable-next-line @typescript-eslint/unified-signatures\n  compileAsync<T = unknown>(schema: JTDSchemaType<T>, _meta?: boolean): Promise<ValidateFunction<T>>\n  compileAsync<T = unknown>(schema: AsyncSchema, meta?: boolean): Promise<AsyncValidateFunction<T>>\n  // eslint-disable-next-line @typescript-eslint/unified-signatures\n  compileAsync<T = unknown>(\n    schema: AnySchemaObject,\n    meta?: boolean\n  ): Promise<AnyValidateFunction<T>>\n  compileAsync<T = unknown>(\n    schema: AnySchemaObject,\n    meta?: boolean\n  ): Promise<AnyValidateFunction<T>> {\n    if (typeof this.opts.loadSchema != \"function\") {\n      throw new Error(\"options.loadSchema should be a function\")\n    }\n    const {loadSchema} = this.opts\n    return runCompileAsync.call(this, schema, meta)\n\n    async function runCompileAsync(\n      this: Ajv,\n      _schema: AnySchemaObject,\n      _meta?: boolean\n    ): Promise<AnyValidateFunction> {\n      await loadMetaSchema.call(this, _schema.$schema)\n      const sch = this._addSchema(_schema, _meta)\n      return sch.validate || _compileAsync.call(this, sch)\n    }\n\n    async function loadMetaSchema(this: Ajv, $ref?: string): Promise<void> {\n      if ($ref && !this.getSchema($ref)) {\n        await runCompileAsync.call(this, {$ref}, true)\n      }\n    }\n\n    async function _compileAsync(this: Ajv, sch: SchemaEnv): Promise<AnyValidateFunction> {\n      try {\n        return this._compileSchemaEnv(sch)\n      } catch (e) {\n        if (!(e instanceof MissingRefError)) throw e\n        checkLoaded.call(this, e)\n        await loadMissingSchema.call(this, e.missingSchema)\n        return _compileAsync.call(this, sch)\n      }\n    }\n\n    function checkLoaded(this: Ajv, {missingSchema: ref, missingRef}: MissingRefError): void {\n      if (this.refs[ref]) {\n        throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`)\n      }\n    }\n\n    async function loadMissingSchema(this: Ajv, ref: string): Promise<void> {\n      const _schema = await _loadSchema.call(this, ref)\n      if (!this.refs[ref]) await loadMetaSchema.call(this, _schema.$schema)\n      if (!this.refs[ref]) this.addSchema(_schema, ref, meta)\n    }\n\n    async function _loadSchema(this: Ajv, ref: string): Promise<AnySchemaObject> {\n      const p = this._loading[ref]\n      if (p) return p\n      try {\n        return await (this._loading[ref] = loadSchema(ref))\n      } finally {\n        delete this._loading[ref]\n      }\n    }\n  }\n\n  // Adds schema to the instance\n  addSchema(\n    schema: AnySchema | AnySchema[], // If array is passed, `key` will be ignored\n    key?: string, // Optional schema key. Can be passed to `validate` method instead of schema object or id/ref. One schema per instance can have empty `id` and `key`.\n    _meta?: boolean, // true if schema is a meta-schema. Used internally, addMetaSchema should be used instead.\n    _validateSchema = this.opts.validateSchema // false to skip schema validation. Used internally, option validateSchema should be used instead.\n  ): Ajv {\n    if (Array.isArray(schema)) {\n      for (const sch of schema) this.addSchema(sch, undefined, _meta, _validateSchema)\n      return this\n    }\n    let id: string | undefined\n    if (typeof schema === \"object\") {\n      const {schemaId} = this.opts\n      id = schema[schemaId]\n      if (id !== undefined && typeof id != \"string\") {\n        throw new Error(`schema ${schemaId} must be string`)\n      }\n    }\n    key = normalizeId(key || id)\n    this._checkUnique(key)\n    this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true)\n    return this\n  }\n\n  // Add schema that will be used to validate other schemas\n  // options in META_IGNORE_OPTIONS are alway set to false\n  addMetaSchema(\n    schema: AnySchemaObject,\n    key?: string, // schema key\n    _validateSchema = this.opts.validateSchema // false to skip schema validation, can be used to override validateSchema option for meta-schema\n  ): Ajv {\n    this.addSchema(schema, key, true, _validateSchema)\n    return this\n  }\n\n  //  Validate schema against its meta-schema\n  validateSchema(schema: AnySchema, throwOrLogError?: boolean): boolean | Promise<unknown> {\n    if (typeof schema == \"boolean\") return true\n    let $schema: string | AnySchemaObject | undefined\n    $schema = schema.$schema\n    if ($schema !== undefined && typeof $schema != \"string\") {\n      throw new Error(\"$schema must be a string\")\n    }\n    $schema = $schema || this.opts.defaultMeta || this.defaultMeta()\n    if (!$schema) {\n      this.logger.warn(\"meta-schema not available\")\n      this.errors = null\n      return true\n    }\n    const valid = this.validate($schema, schema)\n    if (!valid && throwOrLogError) {\n      const message = \"schema is invalid: \" + this.errorsText()\n      if (this.opts.validateSchema === \"log\") this.logger.error(message)\n      else throw new Error(message)\n    }\n    return valid\n  }\n\n  // Get compiled schema by `key` or `ref`.\n  // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)\n  getSchema<T = unknown>(keyRef: string): AnyValidateFunction<T> | undefined {\n    let sch\n    while (typeof (sch = getSchEnv.call(this, keyRef)) == \"string\") keyRef = sch\n    if (sch === undefined) {\n      const {schemaId} = this.opts\n      const root = new SchemaEnv({schema: {}, schemaId})\n      sch = resolveSchema.call(this, root, keyRef)\n      if (!sch) return\n      this.refs[keyRef] = sch\n    }\n    return (sch.validate || this._compileSchemaEnv(sch)) as AnyValidateFunction<T> | undefined\n  }\n\n  // Remove cached schema(s).\n  // If no parameter is passed all schemas but meta-schemas are removed.\n  // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.\n  // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.\n  removeSchema(schemaKeyRef?: AnySchema | string | RegExp): Ajv {\n    if (schemaKeyRef instanceof RegExp) {\n      this._removeAllSchemas(this.schemas, schemaKeyRef)\n      this._removeAllSchemas(this.refs, schemaKeyRef)\n      return this\n    }\n    switch (typeof schemaKeyRef) {\n      case \"undefined\":\n        this._removeAllSchemas(this.schemas)\n        this._removeAllSchemas(this.refs)\n        this._cache.clear()\n        return this\n      case \"string\": {\n        const sch = getSchEnv.call(this, schemaKeyRef)\n        if (typeof sch == \"object\") this._cache.delete(sch.schema)\n        delete this.schemas[schemaKeyRef]\n        delete this.refs[schemaKeyRef]\n        return this\n      }\n      case \"object\": {\n        const cacheKey = schemaKeyRef\n        this._cache.delete(cacheKey)\n        let id = schemaKeyRef[this.opts.schemaId]\n        if (id) {\n          id = normalizeId(id)\n          delete this.schemas[id]\n          delete this.refs[id]\n        }\n        return this\n      }\n      default:\n        throw new Error(\"ajv.removeSchema: invalid parameter\")\n    }\n  }\n\n  // add \"vocabulary\" - a collection of keywords\n  addVocabulary(definitions: Vocabulary): Ajv {\n    for (const def of definitions) this.addKeyword(def)\n    return this\n  }\n\n  addKeyword(\n    kwdOrDef: string | KeywordDefinition,\n    def?: KeywordDefinition // deprecated\n  ): Ajv {\n    let keyword: string | string[]\n    if (typeof kwdOrDef == \"string\") {\n      keyword = kwdOrDef\n      if (typeof def == \"object\") {\n        this.logger.warn(\"these parameters are deprecated, see docs for addKeyword\")\n        def.keyword = keyword\n      }\n    } else if (typeof kwdOrDef == \"object\" && def === undefined) {\n      def = kwdOrDef\n      keyword = def.keyword\n      if (Array.isArray(keyword) && !keyword.length) {\n        throw new Error(\"addKeywords: keyword must be string or non-empty array\")\n      }\n    } else {\n      throw new Error(\"invalid addKeywords parameters\")\n    }\n\n    checkKeyword.call(this, keyword, def)\n    if (!def) {\n      eachItem(keyword, (kwd) => addRule.call(this, kwd))\n      return this\n    }\n    keywordMetaschema.call(this, def)\n    const definition: AddedKeywordDefinition = {\n      ...def,\n      type: getJSONTypes(def.type),\n      schemaType: getJSONTypes(def.schemaType),\n    }\n    eachItem(\n      keyword,\n      definition.type.length === 0\n        ? (k) => addRule.call(this, k, definition)\n        : (k) => definition.type.forEach((t) => addRule.call(this, k, definition, t))\n    )\n    return this\n  }\n\n  getKeyword(keyword: string): AddedKeywordDefinition | boolean {\n    const rule = this.RULES.all[keyword]\n    return typeof rule == \"object\" ? rule.definition : !!rule\n  }\n\n  // Remove keyword\n  removeKeyword(keyword: string): Ajv {\n    // TODO return type should be Ajv\n    const {RULES} = this\n    delete RULES.keywords[keyword]\n    delete RULES.all[keyword]\n    for (const group of RULES.rules) {\n      const i = group.rules.findIndex((rule) => rule.keyword === keyword)\n      if (i >= 0) group.rules.splice(i, 1)\n    }\n    return this\n  }\n\n  // Add format\n  addFormat(name: string, format: Format): Ajv {\n    if (typeof format == \"string\") format = new RegExp(format)\n    this.formats[name] = format\n    return this\n  }\n\n  errorsText(\n    errors: ErrorObject[] | null | undefined = this.errors, // optional array of validation errors\n    {separator = \", \", dataVar = \"data\"}: ErrorsTextOptions = {} // optional options with properties `separator` and `dataVar`\n  ): string {\n    if (!errors || errors.length === 0) return \"No errors\"\n    return errors\n      .map((e) => `${dataVar}${e.instancePath} ${e.message}`)\n      .reduce((text, msg) => text + separator + msg)\n  }\n\n  $dataMetaSchema(metaSchema: AnySchemaObject, keywordsJsonPointers: string[]): AnySchemaObject {\n    const rules = this.RULES.all\n    metaSchema = JSON.parse(JSON.stringify(metaSchema))\n    for (const jsonPointer of keywordsJsonPointers) {\n      const segments = jsonPointer.split(\"/\").slice(1) // first segment is an empty string\n      let keywords = metaSchema\n      for (const seg of segments) keywords = keywords[seg] as AnySchemaObject\n\n      for (const key in rules) {\n        const rule = rules[key]\n        if (typeof rule != \"object\") continue\n        const {$data} = rule.definition\n        const schema = keywords[key] as AnySchemaObject | undefined\n        if ($data && schema) keywords[key] = schemaOrData(schema)\n      }\n    }\n\n    return metaSchema\n  }\n\n  private _removeAllSchemas(schemas: {[Ref in string]?: SchemaEnv | string}, regex?: RegExp): void {\n    for (const keyRef in schemas) {\n      const sch = schemas[keyRef]\n      if (!regex || regex.test(keyRef)) {\n        if (typeof sch == \"string\") {\n          delete schemas[keyRef]\n        } else if (sch && !sch.meta) {\n          this._cache.delete(sch.schema)\n          delete schemas[keyRef]\n        }\n      }\n    }\n  }\n\n  _addSchema(\n    schema: AnySchema,\n    meta?: boolean,\n    baseId?: string,\n    validateSchema = this.opts.validateSchema,\n    addSchema = this.opts.addUsedSchema\n  ): SchemaEnv {\n    let id: string | undefined\n    const {schemaId} = this.opts\n    if (typeof schema == \"object\") {\n      id = schema[schemaId]\n    } else {\n      if (this.opts.jtd) throw new Error(\"schema must be object\")\n      else if (typeof schema != \"boolean\") throw new Error(\"schema must be object or boolean\")\n    }\n    let sch = this._cache.get(schema)\n    if (sch !== undefined) return sch\n\n    baseId = normalizeId(id || baseId)\n    const localRefs = getSchemaRefs.call(this, schema, baseId)\n    sch = new SchemaEnv({schema, schemaId, meta, baseId, localRefs})\n    this._cache.set(sch.schema, sch)\n    if (addSchema && !baseId.startsWith(\"#\")) {\n      // TODO atm it is allowed to overwrite schemas without id (instead of not adding them)\n      if (baseId) this._checkUnique(baseId)\n      this.refs[baseId] = sch\n    }\n    if (validateSchema) this.validateSchema(schema, true)\n    return sch\n  }\n\n  private _checkUnique(id: string): void {\n    if (this.schemas[id] || this.refs[id]) {\n      throw new Error(`schema with key or id \"${id}\" already exists`)\n    }\n  }\n\n  private _compileSchemaEnv(sch: SchemaEnv): AnyValidateFunction {\n    if (sch.meta) this._compileMetaSchema(sch)\n    else compileSchema.call(this, sch)\n\n    /* istanbul ignore if */\n    if (!sch.validate) throw new Error(\"ajv implementation error\")\n    return sch.validate\n  }\n\n  private _compileMetaSchema(sch: SchemaEnv): void {\n    const currentOpts = this.opts\n    this.opts = this._metaOpts\n    try {\n      compileSchema.call(this, sch)\n    } finally {\n      this.opts = currentOpts\n    }\n  }\n}\n\nexport interface ErrorsTextOptions {\n  separator?: string\n  dataVar?: string\n}\n\nfunction checkOptions(\n  this: Ajv,\n  checkOpts: OptionsInfo<RemovedOptions | DeprecatedOptions>,\n  options: Options & RemovedOptions,\n  msg: string,\n  log: \"warn\" | \"error\" = \"error\"\n): void {\n  for (const key in checkOpts) {\n    const opt = key as keyof typeof checkOpts\n    if (opt in options) this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`)\n  }\n}\n\nfunction getSchEnv(this: Ajv, keyRef: string): SchemaEnv | string | undefined {\n  keyRef = normalizeId(keyRef) // TODO tests fail without this line\n  return this.schemas[keyRef] || this.refs[keyRef]\n}\n\nfunction addInitialSchemas(this: Ajv): void {\n  const optsSchemas = this.opts.schemas\n  if (!optsSchemas) return\n  if (Array.isArray(optsSchemas)) this.addSchema(optsSchemas)\n  else for (const key in optsSchemas) this.addSchema(optsSchemas[key] as AnySchema, key)\n}\n\nfunction addInitialFormats(this: Ajv): void {\n  for (const name in this.opts.formats) {\n    const format = this.opts.formats[name]\n    if (format) this.addFormat(name, format)\n  }\n}\n\nfunction addInitialKeywords(\n  this: Ajv,\n  defs: Vocabulary | {[K in string]?: KeywordDefinition}\n): void {\n  if (Array.isArray(defs)) {\n    this.addVocabulary(defs)\n    return\n  }\n  this.logger.warn(\"keywords option as map is deprecated, pass array\")\n  for (const keyword in defs) {\n    const def = defs[keyword] as KeywordDefinition\n    if (!def.keyword) def.keyword = keyword\n    this.addKeyword(def)\n  }\n}\n\nfunction getMetaSchemaOptions(this: Ajv): InstanceOptions {\n  const metaOpts = {...this.opts}\n  for (const opt of META_IGNORE_OPTIONS) delete metaOpts[opt]\n  return metaOpts\n}\n\nconst noLogs = {log() {}, warn() {}, error() {}}\n\nfunction getLogger(logger?: Partial<Logger> | false): Logger {\n  if (logger === false) return noLogs\n  if (logger === undefined) return console\n  if (logger.log && logger.warn && logger.error) return logger as Logger\n  throw new Error(\"logger must implement log, warn and error methods\")\n}\n\nconst KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i\n\nfunction checkKeyword(this: Ajv, keyword: string | string[], def?: KeywordDefinition): void {\n  const {RULES} = this\n  eachItem(keyword, (kwd) => {\n    if (RULES.keywords[kwd]) throw new Error(`Keyword ${kwd} is already defined`)\n    if (!KEYWORD_NAME.test(kwd)) throw new Error(`Keyword ${kwd} has invalid name`)\n  })\n  if (!def) return\n  if (def.$data && !(\"code\" in def || \"validate\" in def)) {\n    throw new Error('$data keyword must have \"code\" or \"validate\" function')\n  }\n}\n\nfunction addRule(\n  this: Ajv,\n  keyword: string,\n  definition?: AddedKeywordDefinition,\n  dataType?: JSONType\n): void {\n  const post = definition?.post\n  if (dataType && post) throw new Error('keyword with \"post\" flag cannot have \"type\"')\n  const {RULES} = this\n  let ruleGroup = post ? RULES.post : RULES.rules.find(({type: t}) => t === dataType)\n  if (!ruleGroup) {\n    ruleGroup = {type: dataType, rules: []}\n    RULES.rules.push(ruleGroup)\n  }\n  RULES.keywords[keyword] = true\n  if (!definition) return\n\n  const rule: Rule = {\n    keyword,\n    definition: {\n      ...definition,\n      type: getJSONTypes(definition.type),\n      schemaType: getJSONTypes(definition.schemaType),\n    },\n  }\n  if (definition.before) addBeforeRule.call(this, ruleGroup, rule, definition.before)\n  else ruleGroup.rules.push(rule)\n  RULES.all[keyword] = rule\n  definition.implements?.forEach((kwd) => this.addKeyword(kwd))\n}\n\nfunction addBeforeRule(this: Ajv, ruleGroup: RuleGroup, rule: Rule, before: string): void {\n  const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before)\n  if (i >= 0) {\n    ruleGroup.rules.splice(i, 0, rule)\n  } else {\n    ruleGroup.rules.push(rule)\n    this.logger.warn(`rule ${before} is not defined`)\n  }\n}\n\nfunction keywordMetaschema(this: Ajv, def: KeywordDefinition): void {\n  let {metaSchema} = def\n  if (metaSchema === undefined) return\n  if (def.$data && this.opts.$data) metaSchema = schemaOrData(metaSchema)\n  def.validateSchema = this.compile(metaSchema, true)\n}\n\nconst $dataRef = {\n  $ref: \"https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#\",\n}\n\nfunction schemaOrData(schema: AnySchema): AnySchemaObject {\n  return {anyOf: [schema, $dataRef]}\n}\n","// https://github.com/ajv-validator/ajv/issues/889\nimport * as equal from \"fast-deep-equal\"\n\ntype Equal = typeof equal & {code: string}\n;(equal as Equal).code = 'require(\"ajv/dist/runtime/equal\").default'\n\nexport default equal as Equal\n","// https://mathiasbynens.be/notes/javascript-encoding\n// https://github.com/bestiejs/punycode.js - punycode.ucs2.decode\nexport default function ucs2length(str: string): number {\n  const len = str.length\n  let length = 0\n  let pos = 0\n  let value: number\n  while (pos < len) {\n    length++\n    value = str.charCodeAt(pos++)\n    if (value >= 0xd800 && value <= 0xdbff && pos < len) {\n      // high surrogate, and there is a next character\n      value = str.charCodeAt(pos)\n      if ((value & 0xfc00) === 0xdc00) pos++ // low surrogate\n    }\n  }\n  return length\n}\n\nucs2length.code = 'require(\"ajv/dist/runtime/ucs2length\").default'\n","import * as uri from \"uri-js\"\n\ntype URI = typeof uri & {code: string}\n;(uri as URI).code = 'require(\"ajv/dist/runtime/uri\").default'\n\nexport default uri as URI\n","import type {ErrorObject} from \"../types\"\n\nexport default class ValidationError extends Error {\n  readonly errors: Partial<ErrorObject>[]\n  readonly ajv: true\n  readonly validation: true\n\n  constructor(errors: Partial<ErrorObject>[]) {\n    super(\"validation failed\")\n    this.errors = errors\n    this.ajv = this.validation = true\n  }\n}\n","import type {\n  CodeKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  AnySchema,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, not, Name} from \"../../compile/codegen\"\nimport {alwaysValidSchema, checkStrictMode, Type} from \"../../compile/util\"\n\nexport type AdditionalItemsError = ErrorObject<\"additionalItems\", {limit: number}, AnySchema>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {len}}) => str`must NOT have more than ${len} items`,\n  params: ({params: {len}}) => _`{limit: ${len}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"additionalItems\" as const,\n  type: \"array\",\n  schemaType: [\"boolean\", \"object\"],\n  before: \"uniqueItems\",\n  error,\n  code(cxt: KeywordCxt) {\n    const {parentSchema, it} = cxt\n    const {items} = parentSchema\n    if (!Array.isArray(items)) {\n      checkStrictMode(it, '\"additionalItems\" is ignored when \"items\" is not an array of schemas')\n      return\n    }\n    validateAdditionalItems(cxt, items)\n  },\n}\n\nexport function validateAdditionalItems(cxt: KeywordCxt, items: AnySchema[]): void {\n  const {gen, schema, data, keyword, it} = cxt\n  it.items = true\n  const len = gen.const(\"len\", _`${data}.length`)\n  if (schema === false) {\n    cxt.setParams({len: items.length})\n    cxt.pass(_`${len} <= ${items.length}`)\n  } else if (typeof schema == \"object\" && !alwaysValidSchema(it, schema)) {\n    const valid = gen.var(\"valid\", _`${len} <= ${items.length}`) // TODO var\n    gen.if(not(valid), () => validateItems(valid))\n    cxt.ok(valid)\n  }\n\n  function validateItems(valid: Name): void {\n    gen.forRange(\"i\", items.length, len, (i) => {\n      cxt.subschema({keyword, dataProp: i, dataPropType: Type.Num}, valid)\n      if (!it.allErrors) gen.if(not(valid), () => gen.break())\n    })\n  }\n}\n\nexport default def\n","import type {\n  CodeKeywordDefinition,\n  AddedKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  AnySchema,\n} from \"../../types\"\nimport {allSchemaProperties, usePattern, isOwnProperty} from \"../code\"\nimport {_, nil, or, not, Code, Name} from \"../../compile/codegen\"\nimport N from \"../../compile/names\"\nimport type {SubschemaArgs} from \"../../compile/validate/subschema\"\nimport {alwaysValidSchema, schemaRefOrVal, Type} from \"../../compile/util\"\n\nexport type AdditionalPropertiesError = ErrorObject<\n  \"additionalProperties\",\n  {additionalProperty: string},\n  AnySchema\n>\n\nconst error: KeywordErrorDefinition = {\n  message: \"must NOT have additional properties\",\n  params: ({params}) => _`{additionalProperty: ${params.additionalProperty}}`,\n}\n\nconst def: CodeKeywordDefinition & AddedKeywordDefinition = {\n  keyword: \"additionalProperties\",\n  type: [\"object\"],\n  schemaType: [\"boolean\", \"object\"],\n  allowUndefined: true,\n  trackErrors: true,\n  error,\n  code(cxt) {\n    const {gen, schema, parentSchema, data, errsCount, it} = cxt\n    /* istanbul ignore if */\n    if (!errsCount) throw new Error(\"ajv implementation error\")\n    const {allErrors, opts} = it\n    it.props = true\n    if (opts.removeAdditional !== \"all\" && alwaysValidSchema(it, schema)) return\n    const props = allSchemaProperties(parentSchema.properties)\n    const patProps = allSchemaProperties(parentSchema.patternProperties)\n    checkAdditionalProperties()\n    cxt.ok(_`${errsCount} === ${N.errors}`)\n\n    function checkAdditionalProperties(): void {\n      gen.forIn(\"key\", data, (key: Name) => {\n        if (!props.length && !patProps.length) additionalPropertyCode(key)\n        else gen.if(isAdditional(key), () => additionalPropertyCode(key))\n      })\n    }\n\n    function isAdditional(key: Name): Code {\n      let definedProp: Code\n      if (props.length > 8) {\n        // TODO maybe an option instead of hard-coded 8?\n        const propsSchema = schemaRefOrVal(it, parentSchema.properties, \"properties\")\n        definedProp = isOwnProperty(gen, propsSchema as Code, key)\n      } else if (props.length) {\n        definedProp = or(...props.map((p) => _`${key} === ${p}`))\n      } else {\n        definedProp = nil\n      }\n      if (patProps.length) {\n        definedProp = or(definedProp, ...patProps.map((p) => _`${usePattern(cxt, p)}.test(${key})`))\n      }\n      return not(definedProp)\n    }\n\n    function deleteAdditional(key: Name): void {\n      gen.code(_`delete ${data}[${key}]`)\n    }\n\n    function additionalPropertyCode(key: Name): void {\n      if (opts.removeAdditional === \"all\" || (opts.removeAdditional && schema === false)) {\n        deleteAdditional(key)\n        return\n      }\n\n      if (schema === false) {\n        cxt.setParams({additionalProperty: key})\n        cxt.error()\n        if (!allErrors) gen.break()\n        return\n      }\n\n      if (typeof schema == \"object\" && !alwaysValidSchema(it, schema)) {\n        const valid = gen.name(\"valid\")\n        if (opts.removeAdditional === \"failing\") {\n          applyAdditionalSchema(key, valid, false)\n          gen.if(not(valid), () => {\n            cxt.reset()\n            deleteAdditional(key)\n          })\n        } else {\n          applyAdditionalSchema(key, valid)\n          if (!allErrors) gen.if(not(valid), () => gen.break())\n        }\n      }\n    }\n\n    function applyAdditionalSchema(key: Name, valid: Name, errors?: false): void {\n      const subschema: SubschemaArgs = {\n        keyword: \"additionalProperties\",\n        dataProp: key,\n        dataPropType: Type.Str,\n      }\n      if (errors === false) {\n        Object.assign(subschema, {\n          compositeRule: true,\n          createErrors: false,\n          allErrors: false,\n        })\n      }\n      cxt.subschema(subschema, valid)\n    }\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition, AnySchema} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {alwaysValidSchema} from \"../../compile/util\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"allOf\",\n  schemaType: \"array\",\n  code(cxt: KeywordCxt) {\n    const {gen, schema, it} = cxt\n    /* istanbul ignore if */\n    if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\")\n    const valid = gen.name(\"valid\")\n    schema.forEach((sch: AnySchema, i: number) => {\n      if (alwaysValidSchema(it, sch)) return\n      const schCxt = cxt.subschema({keyword: \"allOf\", schemaProp: i}, valid)\n      cxt.ok(valid)\n      cxt.mergeEvaluated(schCxt)\n    })\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition, ErrorNoParams, AnySchema} from \"../../types\"\nimport {validateUnion} from \"../code\"\n\nexport type AnyOfError = ErrorNoParams<\"anyOf\", AnySchema[]>\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"anyOf\",\n  schemaType: \"array\",\n  trackErrors: true,\n  code: validateUnion,\n  error: {message: \"must match a schema in anyOf\"},\n}\n\nexport default def\n","import type {\n  CodeKeywordDefinition,\n  KeywordErrorDefinition,\n  ErrorObject,\n  AnySchema,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, Name} from \"../../compile/codegen\"\nimport {alwaysValidSchema, checkStrictMode, Type} from \"../../compile/util\"\n\nexport type ContainsError = ErrorObject<\n  \"contains\",\n  {minContains: number; maxContains?: number},\n  AnySchema\n>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {min, max}}) =>\n    max === undefined\n      ? str`must contain at least ${min} valid item(s)`\n      : str`must contain at least ${min} and no more than ${max} valid item(s)`,\n  params: ({params: {min, max}}) =>\n    max === undefined ? _`{minContains: ${min}}` : _`{minContains: ${min}, maxContains: ${max}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"contains\",\n  type: \"array\",\n  schemaType: [\"object\", \"boolean\"],\n  before: \"uniqueItems\",\n  trackErrors: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, schema, parentSchema, data, it} = cxt\n    let min: number\n    let max: number | undefined\n    const {minContains, maxContains} = parentSchema\n    if (it.opts.next) {\n      min = minContains === undefined ? 1 : minContains\n      max = maxContains\n    } else {\n      min = 1\n    }\n    const len = gen.const(\"len\", _`${data}.length`)\n    cxt.setParams({min, max})\n    if (max === undefined && min === 0) {\n      checkStrictMode(it, `\"minContains\" == 0 without \"maxContains\": \"contains\" keyword ignored`)\n      return\n    }\n    if (max !== undefined && min > max) {\n      checkStrictMode(it, `\"minContains\" > \"maxContains\" is always invalid`)\n      cxt.fail()\n      return\n    }\n    if (alwaysValidSchema(it, schema)) {\n      let cond = _`${len} >= ${min}`\n      if (max !== undefined) cond = _`${cond} && ${len} <= ${max}`\n      cxt.pass(cond)\n      return\n    }\n\n    it.items = true\n    const valid = gen.name(\"valid\")\n    if (max === undefined && min === 1) {\n      validateItems(valid, () => gen.if(valid, () => gen.break()))\n    } else if (min === 0) {\n      gen.let(valid, true)\n      if (max !== undefined) gen.if(_`${data}.length > 0`, validateItemsWithCount)\n    } else {\n      gen.let(valid, false)\n      validateItemsWithCount()\n    }\n    cxt.result(valid, () => cxt.reset())\n\n    function validateItemsWithCount(): void {\n      const schValid = gen.name(\"_valid\")\n      const count = gen.let(\"count\", 0)\n      validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)))\n    }\n\n    function validateItems(_valid: Name, block: () => void): void {\n      gen.forRange(\"i\", 0, len, (i) => {\n        cxt.subschema(\n          {\n            keyword: \"contains\",\n            dataProp: i,\n            dataPropType: Type.Num,\n            compositeRule: true,\n          },\n          _valid\n        )\n        block()\n      })\n    }\n\n    function checkLimits(count: Name): void {\n      gen.code(_`${count}++`)\n      if (max === undefined) {\n        gen.if(_`${count} >= ${min}`, () => gen.assign(valid, true).break())\n      } else {\n        gen.if(_`${count} > ${max}`, () => gen.assign(valid, false).break())\n        if (min === 1) gen.assign(valid, true)\n        else gen.if(_`${count} >= ${min}`, () => gen.assign(valid, true))\n      }\n    }\n  },\n}\n\nexport default def\n","import type {\n  CodeKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  SchemaMap,\n  AnySchema,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str} from \"../../compile/codegen\"\nimport {alwaysValidSchema} from \"../../compile/util\"\nimport {checkReportMissingProp, checkMissingProp, reportMissingProp, propertyInData} from \"../code\"\n\nexport type PropertyDependencies = {[K in string]?: string[]}\n\nexport interface DependenciesErrorParams {\n  property: string\n  missingProperty: string\n  depsCount: number\n  deps: string // TODO change to string[]\n}\n\ntype SchemaDependencies = SchemaMap\n\nexport type DependenciesError = ErrorObject<\n  \"dependencies\",\n  DependenciesErrorParams,\n  {[K in string]?: string[] | AnySchema}\n>\n\nexport const error: KeywordErrorDefinition = {\n  message: ({params: {property, depsCount, deps}}) => {\n    const property_ies = depsCount === 1 ? \"property\" : \"properties\"\n    return str`must have ${property_ies} ${deps} when property ${property} is present`\n  },\n  params: ({params: {property, depsCount, deps, missingProperty}}) =>\n    _`{property: ${property},\n    missingProperty: ${missingProperty},\n    depsCount: ${depsCount},\n    deps: ${deps}}`, // TODO change to reference\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"dependencies\",\n  type: \"object\",\n  schemaType: \"object\",\n  error,\n  code(cxt: KeywordCxt) {\n    const [propDeps, schDeps] = splitDependencies(cxt)\n    validatePropertyDeps(cxt, propDeps)\n    validateSchemaDeps(cxt, schDeps)\n  },\n}\n\nfunction splitDependencies({schema}: KeywordCxt): [PropertyDependencies, SchemaDependencies] {\n  const propertyDeps: PropertyDependencies = {}\n  const schemaDeps: SchemaDependencies = {}\n  for (const key in schema) {\n    if (key === \"__proto__\") continue\n    const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps\n    deps[key] = schema[key]\n  }\n  return [propertyDeps, schemaDeps]\n}\n\nexport function validatePropertyDeps(\n  cxt: KeywordCxt,\n  propertyDeps: {[K in string]?: string[]} = cxt.schema\n): void {\n  const {gen, data, it} = cxt\n  if (Object.keys(propertyDeps).length === 0) return\n  const missing = gen.let(\"missing\")\n  for (const prop in propertyDeps) {\n    const deps = propertyDeps[prop] as string[]\n    if (deps.length === 0) continue\n    const hasProperty = propertyInData(gen, data, prop, it.opts.ownProperties)\n    cxt.setParams({\n      property: prop,\n      depsCount: deps.length,\n      deps: deps.join(\", \"),\n    })\n    if (it.allErrors) {\n      gen.if(hasProperty, () => {\n        for (const depProp of deps) {\n          checkReportMissingProp(cxt, depProp)\n        }\n      })\n    } else {\n      gen.if(_`${hasProperty} && (${checkMissingProp(cxt, deps, missing)})`)\n      reportMissingProp(cxt, missing)\n      gen.else()\n    }\n  }\n}\n\nexport function validateSchemaDeps(cxt: KeywordCxt, schemaDeps: SchemaMap = cxt.schema): void {\n  const {gen, data, keyword, it} = cxt\n  const valid = gen.name(\"valid\")\n  for (const prop in schemaDeps) {\n    if (alwaysValidSchema(it, schemaDeps[prop] as AnySchema)) continue\n    gen.if(\n      propertyInData(gen, data, prop, it.opts.ownProperties),\n      () => {\n        const schCxt = cxt.subschema({keyword, schemaProp: prop}, valid)\n        cxt.mergeValidEvaluated(schCxt, valid)\n      },\n      () => gen.var(valid, true) // TODO var\n    )\n    cxt.ok(valid)\n  }\n}\n\nexport default def\n","import type {\n  CodeKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  AnySchema,\n} from \"../../types\"\nimport type {SchemaObjCxt} from \"../../compile\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, not, Name} from \"../../compile/codegen\"\nimport {alwaysValidSchema, checkStrictMode} from \"../../compile/util\"\n\nexport type IfKeywordError = ErrorObject<\"if\", {failingKeyword: string}, AnySchema>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params}) => str`must match \"${params.ifClause}\" schema`,\n  params: ({params}) => _`{failingKeyword: ${params.ifClause}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"if\",\n  schemaType: [\"object\", \"boolean\"],\n  trackErrors: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, parentSchema, it} = cxt\n    if (parentSchema.then === undefined && parentSchema.else === undefined) {\n      checkStrictMode(it, '\"if\" without \"then\" and \"else\" is ignored')\n    }\n    const hasThen = hasSchema(it, \"then\")\n    const hasElse = hasSchema(it, \"else\")\n    if (!hasThen && !hasElse) return\n\n    const valid = gen.let(\"valid\", true)\n    const schValid = gen.name(\"_valid\")\n    validateIf()\n    cxt.reset()\n\n    if (hasThen && hasElse) {\n      const ifClause = gen.let(\"ifClause\")\n      cxt.setParams({ifClause})\n      gen.if(schValid, validateClause(\"then\", ifClause), validateClause(\"else\", ifClause))\n    } else if (hasThen) {\n      gen.if(schValid, validateClause(\"then\"))\n    } else {\n      gen.if(not(schValid), validateClause(\"else\"))\n    }\n\n    cxt.pass(valid, () => cxt.error(true))\n\n    function validateIf(): void {\n      const schCxt = cxt.subschema(\n        {\n          keyword: \"if\",\n          compositeRule: true,\n          createErrors: false,\n          allErrors: false,\n        },\n        schValid\n      )\n      cxt.mergeEvaluated(schCxt)\n    }\n\n    function validateClause(keyword: string, ifClause?: Name): () => void {\n      return () => {\n        const schCxt = cxt.subschema({keyword}, schValid)\n        gen.assign(valid, schValid)\n        cxt.mergeValidEvaluated(schCxt, valid)\n        if (ifClause) gen.assign(ifClause, _`${keyword}`)\n        else cxt.setParams({ifClause: keyword})\n      }\n    }\n  },\n}\n\nfunction hasSchema(it: SchemaObjCxt, keyword: string): boolean {\n  const schema = it.schema[keyword]\n  return schema !== undefined && !alwaysValidSchema(it, schema)\n}\n\nexport default def\n","import type {ErrorNoParams, Vocabulary} from \"../../types\"\nimport additionalItems, {AdditionalItemsError} from \"./additionalItems\"\nimport prefixItems from \"./prefixItems\"\nimport items from \"./items\"\nimport items2020, {ItemsError} from \"./items2020\"\nimport contains, {ContainsError} from \"./contains\"\nimport dependencies, {DependenciesError} from \"./dependencies\"\nimport propertyNames, {PropertyNamesError} from \"./propertyNames\"\nimport additionalProperties, {AdditionalPropertiesError} from \"./additionalProperties\"\nimport properties from \"./properties\"\nimport patternProperties from \"./patternProperties\"\nimport notKeyword, {NotKeywordError} from \"./not\"\nimport anyOf, {AnyOfError} from \"./anyOf\"\nimport oneOf, {OneOfError} from \"./oneOf\"\nimport allOf from \"./allOf\"\nimport ifKeyword, {IfKeywordError} from \"./if\"\nimport thenElse from \"./thenElse\"\n\nexport default function getApplicator(draft2020 = false): Vocabulary {\n  const applicator = [\n    // any\n    notKeyword,\n    anyOf,\n    oneOf,\n    allOf,\n    ifKeyword,\n    thenElse,\n    // object\n    propertyNames,\n    additionalProperties,\n    dependencies,\n    properties,\n    patternProperties,\n  ]\n  // array\n  if (draft2020) applicator.push(prefixItems, items2020)\n  else applicator.push(additionalItems, items)\n  applicator.push(contains)\n  return applicator\n}\n\nexport type ApplicatorKeywordError =\n  | ErrorNoParams<\"false schema\">\n  | AdditionalItemsError\n  | ItemsError\n  | ContainsError\n  | AdditionalPropertiesError\n  | DependenciesError\n  | IfKeywordError\n  | AnyOfError\n  | OneOfError\n  | NotKeywordError\n  | PropertyNamesError\n","import type {CodeKeywordDefinition, AnySchema, AnySchemaObject} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_} from \"../../compile/codegen\"\nimport {alwaysValidSchema, mergeEvaluated, checkStrictMode} from \"../../compile/util\"\nimport {validateArray} from \"../code\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"items\",\n  type: \"array\",\n  schemaType: [\"object\", \"array\", \"boolean\"],\n  before: \"uniqueItems\",\n  code(cxt: KeywordCxt) {\n    const {schema, it} = cxt\n    if (Array.isArray(schema)) return validateTuple(cxt, \"additionalItems\", schema)\n    it.items = true\n    if (alwaysValidSchema(it, schema)) return\n    cxt.ok(validateArray(cxt))\n  },\n}\n\nexport function validateTuple(\n  cxt: KeywordCxt,\n  extraItems: string,\n  schArr: AnySchema[] = cxt.schema\n): void {\n  const {gen, parentSchema, data, keyword, it} = cxt\n  checkStrictTuple(parentSchema)\n  if (it.opts.unevaluated && schArr.length && it.items !== true) {\n    it.items = mergeEvaluated.items(gen, schArr.length, it.items)\n  }\n  const valid = gen.name(\"valid\")\n  const len = gen.const(\"len\", _`${data}.length`)\n  schArr.forEach((sch: AnySchema, i: number) => {\n    if (alwaysValidSchema(it, sch)) return\n    gen.if(_`${len} > ${i}`, () =>\n      cxt.subschema(\n        {\n          keyword,\n          schemaProp: i,\n          dataProp: i,\n        },\n        valid\n      )\n    )\n    cxt.ok(valid)\n  })\n\n  function checkStrictTuple(sch: AnySchemaObject): void {\n    const {opts, errSchemaPath} = it\n    const l = schArr.length\n    const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false)\n    if (opts.strictTuples && !fullTuple) {\n      const msg = `\"${keyword}\" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path \"${errSchemaPath}\"`\n      checkStrictMode(it, msg, opts.strictTuples)\n    }\n  }\n}\n\nexport default def\n","import type {\n  CodeKeywordDefinition,\n  KeywordErrorDefinition,\n  ErrorObject,\n  AnySchema,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str} from \"../../compile/codegen\"\nimport {alwaysValidSchema} from \"../../compile/util\"\nimport {validateArray} from \"../code\"\nimport {validateAdditionalItems} from \"./additionalItems\"\n\nexport type ItemsError = ErrorObject<\"items\", {limit: number}, AnySchema>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {len}}) => str`must NOT have more than ${len} items`,\n  params: ({params: {len}}) => _`{limit: ${len}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"items\",\n  type: \"array\",\n  schemaType: [\"object\", \"boolean\"],\n  before: \"uniqueItems\",\n  error,\n  code(cxt: KeywordCxt) {\n    const {schema, parentSchema, it} = cxt\n    const {prefixItems} = parentSchema\n    it.items = true\n    if (alwaysValidSchema(it, schema)) return\n    if (prefixItems) validateAdditionalItems(cxt, prefixItems)\n    else cxt.ok(validateArray(cxt))\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition, ErrorNoParams, AnySchema} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {alwaysValidSchema} from \"../../compile/util\"\n\nexport type NotKeywordError = ErrorNoParams<\"not\", AnySchema>\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"not\",\n  schemaType: [\"object\", \"boolean\"],\n  trackErrors: true,\n  code(cxt: KeywordCxt) {\n    const {gen, schema, it} = cxt\n    if (alwaysValidSchema(it, schema)) {\n      cxt.fail()\n      return\n    }\n\n    const valid = gen.name(\"valid\")\n    cxt.subschema(\n      {\n        keyword: \"not\",\n        compositeRule: true,\n        createErrors: false,\n        allErrors: false,\n      },\n      valid\n    )\n\n    cxt.failResult(\n      valid,\n      () => cxt.reset(),\n      () => cxt.error()\n    )\n  },\n  error: {message: \"must NOT be valid\"},\n}\n\nexport default def\n","import type {\n  CodeKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  AnySchema,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, Name} from \"../../compile/codegen\"\nimport {alwaysValidSchema} from \"../../compile/util\"\nimport {SchemaCxt} from \"../../compile\"\n\nexport type OneOfError = ErrorObject<\n  \"oneOf\",\n  {passingSchemas: [number, number] | null},\n  AnySchema[]\n>\n\nconst error: KeywordErrorDefinition = {\n  message: \"must match exactly one schema in oneOf\",\n  params: ({params}) => _`{passingSchemas: ${params.passing}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"oneOf\",\n  schemaType: \"array\",\n  trackErrors: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, schema, parentSchema, it} = cxt\n    /* istanbul ignore if */\n    if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\")\n    if (it.opts.discriminator && parentSchema.discriminator) return\n    const schArr: AnySchema[] = schema\n    const valid = gen.let(\"valid\", false)\n    const passing = gen.let(\"passing\", null)\n    const schValid = gen.name(\"_valid\")\n    cxt.setParams({passing})\n    // TODO possibly fail straight away (with warning or exception) if there are two empty always valid schemas\n\n    gen.block(validateOneOf)\n\n    cxt.result(\n      valid,\n      () => cxt.reset(),\n      () => cxt.error(true)\n    )\n\n    function validateOneOf(): void {\n      schArr.forEach((sch: AnySchema, i: number) => {\n        let schCxt: SchemaCxt | undefined\n        if (alwaysValidSchema(it, sch)) {\n          gen.var(schValid, true)\n        } else {\n          schCxt = cxt.subschema(\n            {\n              keyword: \"oneOf\",\n              schemaProp: i,\n              compositeRule: true,\n            },\n            schValid\n          )\n        }\n\n        if (i > 0) {\n          gen\n            .if(_`${schValid} && ${valid}`)\n            .assign(valid, false)\n            .assign(passing, _`[${passing}, ${i}]`)\n            .else()\n        }\n\n        gen.if(schValid, () => {\n          gen.assign(valid, true)\n          gen.assign(passing, i)\n          if (schCxt) cxt.mergeEvaluated(schCxt, Name)\n        })\n      })\n    }\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {allSchemaProperties, usePattern} from \"../code\"\nimport {_, not, Name} from \"../../compile/codegen\"\nimport {alwaysValidSchema, checkStrictMode} from \"../../compile/util\"\nimport {evaluatedPropsToName, Type} from \"../../compile/util\"\nimport {AnySchema} from \"../../types\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"patternProperties\",\n  type: \"object\",\n  schemaType: \"object\",\n  code(cxt: KeywordCxt) {\n    const {gen, schema, data, parentSchema, it} = cxt\n    const {opts} = it\n    const patterns = allSchemaProperties(schema)\n    const alwaysValidPatterns = patterns.filter((p) =>\n      alwaysValidSchema(it, schema[p] as AnySchema)\n    )\n\n    if (\n      patterns.length === 0 ||\n      (alwaysValidPatterns.length === patterns.length &&\n        (!it.opts.unevaluated || it.props === true))\n    ) {\n      return\n    }\n\n    const checkProperties =\n      opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties\n    const valid = gen.name(\"valid\")\n    if (it.props !== true && !(it.props instanceof Name)) {\n      it.props = evaluatedPropsToName(gen, it.props)\n    }\n    const {props} = it\n    validatePatternProperties()\n\n    function validatePatternProperties(): void {\n      for (const pat of patterns) {\n        if (checkProperties) checkMatchingProperties(pat)\n        if (it.allErrors) {\n          validateProperties(pat)\n        } else {\n          gen.var(valid, true) // TODO var\n          validateProperties(pat)\n          gen.if(valid)\n        }\n      }\n    }\n\n    function checkMatchingProperties(pat: string): void {\n      for (const prop in checkProperties) {\n        if (new RegExp(pat).test(prop)) {\n          checkStrictMode(\n            it,\n            `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`\n          )\n        }\n      }\n    }\n\n    function validateProperties(pat: string): void {\n      gen.forIn(\"key\", data, (key) => {\n        gen.if(_`${usePattern(cxt, pat)}.test(${key})`, () => {\n          const alwaysValid = alwaysValidPatterns.includes(pat)\n          if (!alwaysValid) {\n            cxt.subschema(\n              {\n                keyword: \"patternProperties\",\n                schemaProp: pat,\n                dataProp: key,\n                dataPropType: Type.Str,\n              },\n              valid\n            )\n          }\n\n          if (it.opts.unevaluated && props !== true) {\n            gen.assign(_`${props}[${key}]`, true)\n          } else if (!alwaysValid && !it.allErrors) {\n            // can short-circuit if `unevaluatedProperties` is not supported (opts.next === false)\n            // or if all properties were evaluated (props === true)\n            gen.if(not(valid), () => gen.break())\n          }\n        })\n      })\n    }\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition} from \"../../types\"\nimport {validateTuple} from \"./items\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"prefixItems\",\n  type: \"array\",\n  schemaType: [\"array\"],\n  before: \"uniqueItems\",\n  code: (cxt) => validateTuple(cxt, \"items\"),\n}\n\nexport default def\n","import type {CodeKeywordDefinition} from \"../../types\"\nimport {KeywordCxt} from \"../../compile/validate\"\nimport {propertyInData, allSchemaProperties} from \"../code\"\nimport {alwaysValidSchema, toHash, mergeEvaluated} from \"../../compile/util\"\nimport apDef from \"./additionalProperties\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"properties\",\n  type: \"object\",\n  schemaType: \"object\",\n  code(cxt: KeywordCxt) {\n    const {gen, schema, parentSchema, data, it} = cxt\n    if (it.opts.removeAdditional === \"all\" && parentSchema.additionalProperties === undefined) {\n      apDef.code(new KeywordCxt(it, apDef, \"additionalProperties\"))\n    }\n    const allProps = allSchemaProperties(schema)\n    for (const prop of allProps) {\n      it.definedProperties.add(prop)\n    }\n    if (it.opts.unevaluated && allProps.length && it.props !== true) {\n      it.props = mergeEvaluated.props(gen, toHash(allProps), it.props)\n    }\n    const properties = allProps.filter((p) => !alwaysValidSchema(it, schema[p]))\n    if (properties.length === 0) return\n    const valid = gen.name(\"valid\")\n\n    for (const prop of properties) {\n      if (hasDefault(prop)) {\n        applyPropertySchema(prop)\n      } else {\n        gen.if(propertyInData(gen, data, prop, it.opts.ownProperties))\n        applyPropertySchema(prop)\n        if (!it.allErrors) gen.else().var(valid, true)\n        gen.endIf()\n      }\n      cxt.it.definedProperties.add(prop)\n      cxt.ok(valid)\n    }\n\n    function hasDefault(prop: string): boolean | undefined {\n      return it.opts.useDefaults && !it.compositeRule && schema[prop].default !== undefined\n    }\n\n    function applyPropertySchema(prop: string): void {\n      cxt.subschema(\n        {\n          keyword: \"properties\",\n          schemaProp: prop,\n          dataProp: prop,\n        },\n        valid\n      )\n    }\n  },\n}\n\nexport default def\n","import type {\n  CodeKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  AnySchema,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, not} from \"../../compile/codegen\"\nimport {alwaysValidSchema} from \"../../compile/util\"\n\nexport type PropertyNamesError = ErrorObject<\"propertyNames\", {propertyName: string}, AnySchema>\n\nconst error: KeywordErrorDefinition = {\n  message: \"property name must be valid\",\n  params: ({params}) => _`{propertyName: ${params.propertyName}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"propertyNames\",\n  type: \"object\",\n  schemaType: [\"object\", \"boolean\"],\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, schema, data, it} = cxt\n    if (alwaysValidSchema(it, schema)) return\n    const valid = gen.name(\"valid\")\n\n    gen.forIn(\"key\", data, (key) => {\n      cxt.setParams({propertyName: key})\n      cxt.subschema(\n        {\n          keyword: \"propertyNames\",\n          data: key,\n          dataTypes: [\"string\"],\n          propertyName: key,\n          compositeRule: true,\n        },\n        valid\n      )\n      gen.if(not(valid), () => {\n        cxt.error(true)\n        if (!it.allErrors) gen.break()\n      })\n    })\n\n    cxt.ok(valid)\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {checkStrictMode} from \"../../compile/util\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: [\"then\", \"else\"],\n  schemaType: [\"object\", \"boolean\"],\n  code({keyword, parentSchema, it}: KeywordCxt) {\n    if (parentSchema.if === undefined) checkStrictMode(it, `\"${keyword}\" without \"if\" is ignored`)\n  },\n}\n\nexport default def\n","import type {AnySchema, SchemaMap} from \"../types\"\nimport type {SchemaCxt} from \"../compile\"\nimport type {KeywordCxt} from \"../compile/validate\"\nimport {CodeGen, _, and, or, not, nil, strConcat, getProperty, Code, Name} from \"../compile/codegen\"\nimport {alwaysValidSchema, Type} from \"../compile/util\"\nimport N from \"../compile/names\"\nimport {useFunc} from \"../compile/util\"\nexport function checkReportMissingProp(cxt: KeywordCxt, prop: string): void {\n  const {gen, data, it} = cxt\n  gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {\n    cxt.setParams({missingProperty: _`${prop}`}, true)\n    cxt.error()\n  })\n}\n\nexport function checkMissingProp(\n  {gen, data, it: {opts}}: KeywordCxt,\n  properties: string[],\n  missing: Name\n): Code {\n  return or(\n    ...properties.map((prop) =>\n      and(noPropertyInData(gen, data, prop, opts.ownProperties), _`${missing} = ${prop}`)\n    )\n  )\n}\n\nexport function reportMissingProp(cxt: KeywordCxt, missing: Name): void {\n  cxt.setParams({missingProperty: missing}, true)\n  cxt.error()\n}\n\nexport function hasPropFunc(gen: CodeGen): Name {\n  return gen.scopeValue(\"func\", {\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    ref: Object.prototype.hasOwnProperty,\n    code: _`Object.prototype.hasOwnProperty`,\n  })\n}\n\nexport function isOwnProperty(gen: CodeGen, data: Name, property: Name | string): Code {\n  return _`${hasPropFunc(gen)}.call(${data}, ${property})`\n}\n\nexport function propertyInData(\n  gen: CodeGen,\n  data: Name,\n  property: Name | string,\n  ownProperties?: boolean\n): Code {\n  const cond = _`${data}${getProperty(property)} !== undefined`\n  return ownProperties ? _`${cond} && ${isOwnProperty(gen, data, property)}` : cond\n}\n\nexport function noPropertyInData(\n  gen: CodeGen,\n  data: Name,\n  property: Name | string,\n  ownProperties?: boolean\n): Code {\n  const cond = _`${data}${getProperty(property)} === undefined`\n  return ownProperties ? or(cond, not(isOwnProperty(gen, data, property))) : cond\n}\n\nexport function allSchemaProperties(schemaMap?: SchemaMap): string[] {\n  return schemaMap ? Object.keys(schemaMap).filter((p) => p !== \"__proto__\") : []\n}\n\nexport function schemaProperties(it: SchemaCxt, schemaMap: SchemaMap): string[] {\n  return allSchemaProperties(schemaMap).filter(\n    (p) => !alwaysValidSchema(it, schemaMap[p] as AnySchema)\n  )\n}\n\nexport function callValidateCode(\n  {schemaCode, data, it: {gen, topSchemaRef, schemaPath, errorPath}, it}: KeywordCxt,\n  func: Code,\n  context: Code,\n  passSchema?: boolean\n): Code {\n  const dataAndSchema = passSchema ? _`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data\n  const valCxt: [Name, Code | number][] = [\n    [N.instancePath, strConcat(N.instancePath, errorPath)],\n    [N.parentData, it.parentData],\n    [N.parentDataProperty, it.parentDataProperty],\n    [N.rootData, N.rootData],\n  ]\n  if (it.opts.dynamicRef) valCxt.push([N.dynamicAnchors, N.dynamicAnchors])\n  const args = _`${dataAndSchema}, ${gen.object(...valCxt)}`\n  return context !== nil ? _`${func}.call(${context}, ${args})` : _`${func}(${args})`\n}\n\nconst newRegExp = _`new RegExp`\n\nexport function usePattern({gen, it: {opts}}: KeywordCxt, pattern: string): Name {\n  const u = opts.unicodeRegExp ? \"u\" : \"\"\n  const {regExp} = opts.code\n  const rx = regExp(pattern, u)\n\n  return gen.scopeValue(\"pattern\", {\n    key: rx.toString(),\n    ref: rx,\n    code: _`${regExp.code === \"new RegExp\" ? newRegExp : useFunc(gen, regExp)}(${pattern}, ${u})`,\n  })\n}\n\nexport function validateArray(cxt: KeywordCxt): Name {\n  const {gen, data, keyword, it} = cxt\n  const valid = gen.name(\"valid\")\n  if (it.allErrors) {\n    const validArr = gen.let(\"valid\", true)\n    validateItems(() => gen.assign(validArr, false))\n    return validArr\n  }\n  gen.var(valid, true)\n  validateItems(() => gen.break())\n  return valid\n\n  function validateItems(notValid: () => void): void {\n    const len = gen.const(\"len\", _`${data}.length`)\n    gen.forRange(\"i\", 0, len, (i) => {\n      cxt.subschema(\n        {\n          keyword,\n          dataProp: i,\n          dataPropType: Type.Num,\n        },\n        valid\n      )\n      gen.if(not(valid), notValid)\n    })\n  }\n}\n\nexport function validateUnion(cxt: KeywordCxt): void {\n  const {gen, schema, keyword, it} = cxt\n  /* istanbul ignore if */\n  if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\")\n  const alwaysValid = schema.some((sch: AnySchema) => alwaysValidSchema(it, sch))\n  if (alwaysValid && !it.opts.unevaluated) return\n\n  const valid = gen.let(\"valid\", false)\n  const schValid = gen.name(\"_valid\")\n\n  gen.block(() =>\n    schema.forEach((_sch: AnySchema, i: number) => {\n      const schCxt = cxt.subschema(\n        {\n          keyword,\n          schemaProp: i,\n          compositeRule: true,\n        },\n        schValid\n      )\n      gen.assign(valid, _`${valid} || ${schValid}`)\n      const merged = cxt.mergeValidEvaluated(schCxt, schValid)\n      // can short-circuit if `unevaluatedProperties/Items` not supported (opts.unevaluated !== true)\n      // or if all properties and items were evaluated (it.props === true && it.items === true)\n      if (!merged) gen.if(not(valid))\n    })\n  )\n\n  cxt.result(\n    valid,\n    () => cxt.reset(),\n    () => cxt.error(true)\n  )\n}\n","import type {CodeKeywordDefinition} from \"../../types\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"id\",\n  code() {\n    throw new Error('NOT SUPPORTED: keyword \"id\", use \"$id\" for schema ID')\n  },\n}\n\nexport default def\n","import type {Vocabulary} from \"../../types\"\nimport idKeyword from \"./id\"\nimport refKeyword from \"./ref\"\n\nconst core: Vocabulary = [\n  \"$schema\",\n  \"$id\",\n  \"$defs\",\n  \"$vocabulary\",\n  {keyword: \"$comment\"},\n  \"definitions\",\n  idKeyword,\n  refKeyword,\n]\n\nexport default core\n","import type {CodeKeywordDefinition, AnySchema} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport MissingRefError from \"../../compile/ref_error\"\nimport {callValidateCode} from \"../code\"\nimport {_, nil, stringify, Code, Name} from \"../../compile/codegen\"\nimport N from \"../../compile/names\"\nimport {SchemaEnv, resolveRef} from \"../../compile\"\nimport {mergeEvaluated} from \"../../compile/util\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"$ref\",\n  schemaType: \"string\",\n  code(cxt: KeywordCxt): void {\n    const {gen, schema: $ref, it} = cxt\n    const {baseId, schemaEnv: env, validateName, opts, self} = it\n    const {root} = env\n    if (($ref === \"#\" || $ref === \"#/\") && baseId === root.baseId) return callRootRef()\n    const schOrEnv = resolveRef.call(self, root, baseId, $ref)\n    if (schOrEnv === undefined) throw new MissingRefError(it.opts.uriResolver, baseId, $ref)\n    if (schOrEnv instanceof SchemaEnv) return callValidate(schOrEnv)\n    return inlineRefSchema(schOrEnv)\n\n    function callRootRef(): void {\n      if (env === root) return callRef(cxt, validateName, env, env.$async)\n      const rootName = gen.scopeValue(\"root\", {ref: root})\n      return callRef(cxt, _`${rootName}.validate`, root, root.$async)\n    }\n\n    function callValidate(sch: SchemaEnv): void {\n      const v = getValidate(cxt, sch)\n      callRef(cxt, v, sch, sch.$async)\n    }\n\n    function inlineRefSchema(sch: AnySchema): void {\n      const schName = gen.scopeValue(\n        \"schema\",\n        opts.code.source === true ? {ref: sch, code: stringify(sch)} : {ref: sch}\n      )\n      const valid = gen.name(\"valid\")\n      const schCxt = cxt.subschema(\n        {\n          schema: sch,\n          dataTypes: [],\n          schemaPath: nil,\n          topSchemaRef: schName,\n          errSchemaPath: $ref,\n        },\n        valid\n      )\n      cxt.mergeEvaluated(schCxt)\n      cxt.ok(valid)\n    }\n  },\n}\n\nexport function getValidate(cxt: KeywordCxt, sch: SchemaEnv): Code {\n  const {gen} = cxt\n  return sch.validate\n    ? gen.scopeValue(\"validate\", {ref: sch.validate})\n    : _`${gen.scopeValue(\"wrapper\", {ref: sch})}.validate`\n}\n\nexport function callRef(cxt: KeywordCxt, v: Code, sch?: SchemaEnv, $async?: boolean): void {\n  const {gen, it} = cxt\n  const {allErrors, schemaEnv: env, opts} = it\n  const passCxt = opts.passContext ? N.this : nil\n  if ($async) callAsyncRef()\n  else callSyncRef()\n\n  function callAsyncRef(): void {\n    if (!env.$async) throw new Error(\"async schema referenced by sync schema\")\n    const valid = gen.let(\"valid\")\n    gen.try(\n      () => {\n        gen.code(_`await ${callValidateCode(cxt, v, passCxt)}`)\n        addEvaluatedFrom(v) // TODO will not work with async, it has to be returned with the result\n        if (!allErrors) gen.assign(valid, true)\n      },\n      (e) => {\n        gen.if(_`!(${e} instanceof ${it.ValidationError as Name})`, () => gen.throw(e))\n        addErrorsFrom(e)\n        if (!allErrors) gen.assign(valid, false)\n      }\n    )\n    cxt.ok(valid)\n  }\n\n  function callSyncRef(): void {\n    cxt.result(\n      callValidateCode(cxt, v, passCxt),\n      () => addEvaluatedFrom(v),\n      () => addErrorsFrom(v)\n    )\n  }\n\n  function addErrorsFrom(source: Code): void {\n    const errs = _`${source}.errors`\n    gen.assign(N.vErrors, _`${N.vErrors} === null ? ${errs} : ${N.vErrors}.concat(${errs})`) // TODO tagged\n    gen.assign(N.errors, _`${N.vErrors}.length`)\n  }\n\n  function addEvaluatedFrom(source: Code): void {\n    if (!it.opts.unevaluated) return\n    const schEvaluated = sch?.validate?.evaluated\n    // TODO refactor\n    if (it.props !== true) {\n      if (schEvaluated && !schEvaluated.dynamicProps) {\n        if (schEvaluated.props !== undefined) {\n          it.props = mergeEvaluated.props(gen, schEvaluated.props, it.props)\n        }\n      } else {\n        const props = gen.var(\"props\", _`${source}.evaluated.props`)\n        it.props = mergeEvaluated.props(gen, props, it.props, Name)\n      }\n    }\n    if (it.items !== true) {\n      if (schEvaluated && !schEvaluated.dynamicItems) {\n        if (schEvaluated.items !== undefined) {\n          it.items = mergeEvaluated.items(gen, schEvaluated.items, it.items)\n        }\n      } else {\n        const items = gen.var(\"items\", _`${source}.evaluated.items`)\n        it.items = mergeEvaluated.items(gen, items, it.items, Name)\n      }\n    }\n  }\n}\n\nexport default def\n","import type {CodeKeywordDefinition, AnySchemaObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, getProperty, Name} from \"../../compile/codegen\"\nimport {DiscrError, DiscrErrorObj} from \"../discriminator/types\"\nimport {resolveRef, SchemaEnv} from \"../../compile\"\nimport {schemaHasRulesButRef} from \"../../compile/util\"\n\nexport type DiscriminatorError = DiscrErrorObj<DiscrError.Tag> | DiscrErrorObj<DiscrError.Mapping>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {discrError, tagName}}) =>\n    discrError === DiscrError.Tag\n      ? `tag \"${tagName}\" must be string`\n      : `value of tag \"${tagName}\" must be in oneOf`,\n  params: ({params: {discrError, tag, tagName}}) =>\n    _`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"discriminator\",\n  type: \"object\",\n  schemaType: \"object\",\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, data, schema, parentSchema, it} = cxt\n    const {oneOf} = parentSchema\n    if (!it.opts.discriminator) {\n      throw new Error(\"discriminator: requires discriminator option\")\n    }\n    const tagName = schema.propertyName\n    if (typeof tagName != \"string\") throw new Error(\"discriminator: requires propertyName\")\n    if (schema.mapping) throw new Error(\"discriminator: mapping is not supported\")\n    if (!oneOf) throw new Error(\"discriminator: requires oneOf keyword\")\n    const valid = gen.let(\"valid\", false)\n    const tag = gen.const(\"tag\", _`${data}${getProperty(tagName)}`)\n    gen.if(\n      _`typeof ${tag} == \"string\"`,\n      () => validateMapping(),\n      () => cxt.error(false, {discrError: DiscrError.Tag, tag, tagName})\n    )\n    cxt.ok(valid)\n\n    function validateMapping(): void {\n      const mapping = getMapping()\n      gen.if(false)\n      for (const tagValue in mapping) {\n        gen.elseIf(_`${tag} === ${tagValue}`)\n        gen.assign(valid, applyTagSchema(mapping[tagValue]))\n      }\n      gen.else()\n      cxt.error(false, {discrError: DiscrError.Mapping, tag, tagName})\n      gen.endIf()\n    }\n\n    function applyTagSchema(schemaProp?: number): Name {\n      const _valid = gen.name(\"valid\")\n      const schCxt = cxt.subschema({keyword: \"oneOf\", schemaProp}, _valid)\n      cxt.mergeEvaluated(schCxt, Name)\n      return _valid\n    }\n\n    function getMapping(): {[T in string]?: number} {\n      const oneOfMapping: {[T in string]?: number} = {}\n      const topRequired = hasRequired(parentSchema)\n      let tagRequired = true\n      for (let i = 0; i < oneOf.length; i++) {\n        let sch = oneOf[i]\n        if (sch?.$ref && !schemaHasRulesButRef(sch, it.self.RULES)) {\n          sch = resolveRef.call(it.self, it.schemaEnv.root, it.baseId, sch?.$ref)\n          if (sch instanceof SchemaEnv) sch = sch.schema\n        }\n        const propSch = sch?.properties?.[tagName]\n        if (typeof propSch != \"object\") {\n          throw new Error(\n            `discriminator: oneOf subschemas (or referenced schemas) must have \"properties/${tagName}\"`\n          )\n        }\n        tagRequired = tagRequired && (topRequired || hasRequired(sch))\n        addMappings(propSch, i)\n      }\n      if (!tagRequired) throw new Error(`discriminator: \"${tagName}\" must be required`)\n      return oneOfMapping\n\n      function hasRequired({required}: AnySchemaObject): boolean {\n        return Array.isArray(required) && required.includes(tagName)\n      }\n\n      function addMappings(sch: AnySchemaObject, i: number): void {\n        if (sch.const) {\n          addMapping(sch.const, i)\n        } else if (sch.enum) {\n          for (const tagValue of sch.enum) {\n            addMapping(tagValue, i)\n          }\n        } else {\n          throw new Error(`discriminator: \"properties/${tagName}\" must have \"const\" or \"enum\"`)\n        }\n      }\n\n      function addMapping(tagValue: unknown, i: number): void {\n        if (typeof tagValue != \"string\" || tagValue in oneOfMapping) {\n          throw new Error(`discriminator: \"${tagName}\" values must be unique strings`)\n        }\n        oneOfMapping[tagValue] = i\n      }\n    }\n  },\n}\n\nexport default def\n","import type {ErrorObject} from \"../../types\"\n\nexport enum DiscrError {\n  Tag = \"tag\",\n  Mapping = \"mapping\",\n}\n\nexport type DiscrErrorObj<E extends DiscrError> = ErrorObject<\n  \"discriminator\",\n  {error: E; tag: string; tagValue: unknown},\n  string\n>\n","import type {Vocabulary} from \"../types\"\nimport coreVocabulary from \"./core\"\nimport validationVocabulary from \"./validation\"\nimport getApplicatorVocabulary from \"./applicator\"\nimport formatVocabulary from \"./format\"\nimport {metadataVocabulary, contentVocabulary} from \"./metadata\"\n\nconst draft7Vocabularies: Vocabulary[] = [\n  coreVocabulary,\n  validationVocabulary,\n  getApplicatorVocabulary(),\n  formatVocabulary,\n  metadataVocabulary,\n  contentVocabulary,\n]\n\nexport default draft7Vocabularies\n","import type {\n  AddedFormat,\n  FormatValidator,\n  AsyncFormatValidator,\n  CodeKeywordDefinition,\n  KeywordErrorDefinition,\n  ErrorObject,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, nil, or, Code, getProperty, regexpCode} from \"../../compile/codegen\"\n\ntype FormatValidate =\n  | FormatValidator<string>\n  | FormatValidator<number>\n  | AsyncFormatValidator<string>\n  | AsyncFormatValidator<number>\n  | RegExp\n  | string\n  | true\n\nexport type FormatError = ErrorObject<\"format\", {format: string}, string | {$data: string}>\n\nconst error: KeywordErrorDefinition = {\n  message: ({schemaCode}) => str`must match format \"${schemaCode}\"`,\n  params: ({schemaCode}) => _`{format: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"format\",\n  type: [\"number\", \"string\"],\n  schemaType: \"string\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt, ruleType?: string) {\n    const {gen, data, $data, schema, schemaCode, it} = cxt\n    const {opts, errSchemaPath, schemaEnv, self} = it\n    if (!opts.validateFormats) return\n\n    if ($data) validate$DataFormat()\n    else validateFormat()\n\n    function validate$DataFormat(): void {\n      const fmts = gen.scopeValue(\"formats\", {\n        ref: self.formats,\n        code: opts.code.formats,\n      })\n      const fDef = gen.const(\"fDef\", _`${fmts}[${schemaCode}]`)\n      const fType = gen.let(\"fType\")\n      const format = gen.let(\"format\")\n      // TODO simplify\n      gen.if(\n        _`typeof ${fDef} == \"object\" && !(${fDef} instanceof RegExp)`,\n        () => gen.assign(fType, _`${fDef}.type || \"string\"`).assign(format, _`${fDef}.validate`),\n        () => gen.assign(fType, _`\"string\"`).assign(format, fDef)\n      )\n      cxt.fail$data(or(unknownFmt(), invalidFmt()))\n\n      function unknownFmt(): Code {\n        if (opts.strictSchema === false) return nil\n        return _`${schemaCode} && !${format}`\n      }\n\n      function invalidFmt(): Code {\n        const callFormat = schemaEnv.$async\n          ? _`(${fDef}.async ? await ${format}(${data}) : ${format}(${data}))`\n          : _`${format}(${data})`\n        const validData = _`(typeof ${format} == \"function\" ? ${callFormat} : ${format}.test(${data}))`\n        return _`${format} && ${format} !== true && ${fType} === ${ruleType} && !${validData}`\n      }\n    }\n\n    function validateFormat(): void {\n      const formatDef: AddedFormat | undefined = self.formats[schema]\n      if (!formatDef) {\n        unknownFormat()\n        return\n      }\n      if (formatDef === true) return\n      const [fmtType, format, fmtRef] = getFormat(formatDef)\n      if (fmtType === ruleType) cxt.pass(validCondition())\n\n      function unknownFormat(): void {\n        if (opts.strictSchema === false) {\n          self.logger.warn(unknownMsg())\n          return\n        }\n        throw new Error(unknownMsg())\n\n        function unknownMsg(): string {\n          return `unknown format \"${schema as string}\" ignored in schema at path \"${errSchemaPath}\"`\n        }\n      }\n\n      function getFormat(fmtDef: AddedFormat): [string, FormatValidate, Code] {\n        const code =\n          fmtDef instanceof RegExp\n            ? regexpCode(fmtDef)\n            : opts.code.formats\n            ? _`${opts.code.formats}${getProperty(schema)}`\n            : undefined\n        const fmt = gen.scopeValue(\"formats\", {key: schema, ref: fmtDef, code})\n        if (typeof fmtDef == \"object\" && !(fmtDef instanceof RegExp)) {\n          return [fmtDef.type || \"string\", fmtDef.validate, _`${fmt}.validate`]\n        }\n\n        return [\"string\", fmtDef, fmt]\n      }\n\n      function validCondition(): Code {\n        if (typeof formatDef == \"object\" && !(formatDef instanceof RegExp) && formatDef.async) {\n          if (!schemaEnv.$async) throw new Error(\"async format in sync schema\")\n          return _`await ${fmtRef}(${data})`\n        }\n        return typeof format == \"function\" ? _`${fmtRef}(${data})` : _`${fmtRef}.test(${data})`\n      }\n    }\n  },\n}\n\nexport default def\n","import type {Vocabulary} from \"../../types\"\nimport formatKeyword from \"./format\"\n\nconst format: Vocabulary = [formatKeyword]\n\nexport default format\n","import type {Vocabulary} from \"../types\"\n\nexport const metadataVocabulary: Vocabulary = [\n  \"title\",\n  \"description\",\n  \"default\",\n  \"deprecated\",\n  \"readOnly\",\n  \"writeOnly\",\n  \"examples\",\n]\n\nexport const contentVocabulary: Vocabulary = [\n  \"contentMediaType\",\n  \"contentEncoding\",\n  \"contentSchema\",\n]\n","import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_} from \"../../compile/codegen\"\nimport {useFunc} from \"../../compile/util\"\nimport equal from \"../../runtime/equal\"\n\nexport type ConstError = ErrorObject<\"const\", {allowedValue: any}>\n\nconst error: KeywordErrorDefinition = {\n  message: \"must be equal to constant\",\n  params: ({schemaCode}) => _`{allowedValue: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"const\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, data, $data, schemaCode, schema} = cxt\n    if ($data || (schema && typeof schema == \"object\")) {\n      cxt.fail$data(_`!${useFunc(gen, equal)}(${data}, ${schemaCode})`)\n    } else {\n      cxt.fail(_`${schema} !== ${data}`)\n    }\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, or, Name, Code} from \"../../compile/codegen\"\nimport {useFunc} from \"../../compile/util\"\nimport equal from \"../../runtime/equal\"\n\nexport type EnumError = ErrorObject<\"enum\", {allowedValues: any[]}, any[] | {$data: string}>\n\nconst error: KeywordErrorDefinition = {\n  message: \"must be equal to one of the allowed values\",\n  params: ({schemaCode}) => _`{allowedValues: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"enum\",\n  schemaType: \"array\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, data, $data, schema, schemaCode, it} = cxt\n    if (!$data && schema.length === 0) throw new Error(\"enum must have non-empty array\")\n    const useLoop = schema.length >= it.opts.loopEnum\n    let eql: Name | undefined\n    const getEql = (): Name => (eql ??= useFunc(gen, equal))\n\n    let valid: Code\n    if (useLoop || $data) {\n      valid = gen.let(\"valid\")\n      cxt.block$data(valid, loopEnum)\n    } else {\n      /* istanbul ignore if */\n      if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\")\n      const vSchema = gen.const(\"vSchema\", schemaCode)\n      valid = or(...schema.map((_x: unknown, i: number) => equalCode(vSchema, i)))\n    }\n    cxt.pass(valid)\n\n    function loopEnum(): void {\n      gen.assign(valid, false)\n      gen.forOf(\"v\", schemaCode as Code, (v) =>\n        gen.if(_`${getEql()}(${data}, ${v})`, () => gen.assign(valid, true).break())\n      )\n    }\n\n    function equalCode(vSchema: Name, i: number): Code {\n      const sch = schema[i]\n      return typeof sch === \"object\" && sch !== null\n        ? _`${getEql()}(${data}, ${vSchema}[${i}])`\n        : _`${data} === ${sch}`\n    }\n  },\n}\n\nexport default def\n","import type {ErrorObject, Vocabulary} from \"../../types\"\nimport limitNumber, {LimitNumberError} from \"./limitNumber\"\nimport multipleOf, {MultipleOfError} from \"./multipleOf\"\nimport limitLength from \"./limitLength\"\nimport pattern, {PatternError} from \"./pattern\"\nimport limitProperties from \"./limitProperties\"\nimport required, {RequiredError} from \"./required\"\nimport limitItems from \"./limitItems\"\nimport uniqueItems, {UniqueItemsError} from \"./uniqueItems\"\nimport constKeyword, {ConstError} from \"./const\"\nimport enumKeyword, {EnumError} from \"./enum\"\n\nconst validation: Vocabulary = [\n  // number\n  limitNumber,\n  multipleOf,\n  // string\n  limitLength,\n  pattern,\n  // object\n  limitProperties,\n  required,\n  // array\n  limitItems,\n  uniqueItems,\n  // any\n  {keyword: \"type\", schemaType: [\"string\", \"array\"]},\n  {keyword: \"nullable\", schemaType: \"boolean\"},\n  constKeyword,\n  enumKeyword,\n]\n\nexport default validation\n\ntype LimitError = ErrorObject<\n  \"maxItems\" | \"minItems\" | \"minProperties\" | \"maxProperties\" | \"minLength\" | \"maxLength\",\n  {limit: number},\n  number | {$data: string}\n>\n\nexport type ValidationKeywordError =\n  | LimitError\n  | LimitNumberError\n  | MultipleOfError\n  | PatternError\n  | RequiredError\n  | UniqueItemsError\n  | ConstError\n  | EnumError\n","import type {CodeKeywordDefinition, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, operators} from \"../../compile/codegen\"\n\nconst error: KeywordErrorDefinition = {\n  message({keyword, schemaCode}) {\n    const comp = keyword === \"maxItems\" ? \"more\" : \"fewer\"\n    return str`must NOT have ${comp} than ${schemaCode} items`\n  },\n  params: ({schemaCode}) => _`{limit: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: [\"maxItems\", \"minItems\"],\n  type: \"array\",\n  schemaType: \"number\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {keyword, data, schemaCode} = cxt\n    const op = keyword === \"maxItems\" ? operators.GT : operators.LT\n    cxt.fail$data(_`${data}.length ${op} ${schemaCode}`)\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, operators} from \"../../compile/codegen\"\nimport {useFunc} from \"../../compile/util\"\nimport ucs2length from \"../../runtime/ucs2length\"\n\nconst error: KeywordErrorDefinition = {\n  message({keyword, schemaCode}) {\n    const comp = keyword === \"maxLength\" ? \"more\" : \"fewer\"\n    return str`must NOT have ${comp} than ${schemaCode} characters`\n  },\n  params: ({schemaCode}) => _`{limit: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: [\"maxLength\", \"minLength\"],\n  type: \"string\",\n  schemaType: \"number\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {keyword, data, schemaCode, it} = cxt\n    const op = keyword === \"maxLength\" ? operators.GT : operators.LT\n    const len =\n      it.opts.unicode === false ? _`${data}.length` : _`${useFunc(cxt.gen, ucs2length)}(${data})`\n    cxt.fail$data(_`${len} ${op} ${schemaCode}`)\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, operators, Code} from \"../../compile/codegen\"\n\nconst ops = operators\n\ntype Kwd = \"maximum\" | \"minimum\" | \"exclusiveMaximum\" | \"exclusiveMinimum\"\n\ntype Comparison = \"<=\" | \">=\" | \"<\" | \">\"\n\nconst KWDs: {[K in Kwd]: {okStr: Comparison; ok: Code; fail: Code}} = {\n  maximum: {okStr: \"<=\", ok: ops.LTE, fail: ops.GT},\n  minimum: {okStr: \">=\", ok: ops.GTE, fail: ops.LT},\n  exclusiveMaximum: {okStr: \"<\", ok: ops.LT, fail: ops.GTE},\n  exclusiveMinimum: {okStr: \">\", ok: ops.GT, fail: ops.LTE},\n}\n\nexport type LimitNumberError = ErrorObject<\n  Kwd,\n  {limit: number; comparison: Comparison},\n  number | {$data: string}\n>\n\nconst error: KeywordErrorDefinition = {\n  message: ({keyword, schemaCode}) => str`must be ${KWDs[keyword as Kwd].okStr} ${schemaCode}`,\n  params: ({keyword, schemaCode}) =>\n    _`{comparison: ${KWDs[keyword as Kwd].okStr}, limit: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: Object.keys(KWDs),\n  type: \"number\",\n  schemaType: \"number\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {keyword, data, schemaCode} = cxt\n    cxt.fail$data(_`${data} ${KWDs[keyword as Kwd].fail} ${schemaCode} || isNaN(${data})`)\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, operators} from \"../../compile/codegen\"\n\nconst error: KeywordErrorDefinition = {\n  message({keyword, schemaCode}) {\n    const comp = keyword === \"maxProperties\" ? \"more\" : \"fewer\"\n    return str`must NOT have ${comp} than ${schemaCode} properties`\n  },\n  params: ({schemaCode}) => _`{limit: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: [\"maxProperties\", \"minProperties\"],\n  type: \"object\",\n  schemaType: \"number\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {keyword, data, schemaCode} = cxt\n    const op = keyword === \"maxProperties\" ? operators.GT : operators.LT\n    cxt.fail$data(_`Object.keys(${data}).length ${op} ${schemaCode}`)\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str} from \"../../compile/codegen\"\n\nexport type MultipleOfError = ErrorObject<\n  \"multipleOf\",\n  {multipleOf: number},\n  number | {$data: string}\n>\n\nconst error: KeywordErrorDefinition = {\n  message: ({schemaCode}) => str`must be multiple of ${schemaCode}`,\n  params: ({schemaCode}) => _`{multipleOf: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"multipleOf\",\n  type: \"number\",\n  schemaType: \"number\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, data, schemaCode, it} = cxt\n    // const bdt = bad$DataType(schemaCode, <string>def.schemaType, $data)\n    const prec = it.opts.multipleOfPrecision\n    const res = gen.let(\"res\")\n    const invalid = prec\n      ? _`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}`\n      : _`${res} !== parseInt(${res})`\n    cxt.fail$data(_`(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`)\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {usePattern} from \"../code\"\nimport {_, str} from \"../../compile/codegen\"\n\nexport type PatternError = ErrorObject<\"pattern\", {pattern: string}, string | {$data: string}>\n\nconst error: KeywordErrorDefinition = {\n  message: ({schemaCode}) => str`must match pattern \"${schemaCode}\"`,\n  params: ({schemaCode}) => _`{pattern: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"pattern\",\n  type: \"string\",\n  schemaType: \"string\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {data, $data, schema, schemaCode, it} = cxt\n    // TODO regexp should be wrapped in try/catchs\n    const u = it.opts.unicodeRegExp ? \"u\" : \"\"\n    const regExp = $data ? _`(new RegExp(${schemaCode}, ${u}))` : usePattern(cxt, schema)\n    cxt.fail$data(_`!${regExp}.test(${data})`)\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {\n  checkReportMissingProp,\n  checkMissingProp,\n  reportMissingProp,\n  propertyInData,\n  noPropertyInData,\n} from \"../code\"\nimport {_, str, nil, not, Name, Code} from \"../../compile/codegen\"\nimport {checkStrictMode} from \"../../compile/util\"\n\nexport type RequiredError = ErrorObject<\n  \"required\",\n  {missingProperty: string},\n  string[] | {$data: string}\n>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {missingProperty}}) => str`must have required property '${missingProperty}'`,\n  params: ({params: {missingProperty}}) => _`{missingProperty: ${missingProperty}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"required\",\n  type: \"object\",\n  schemaType: \"array\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, schema, schemaCode, data, $data, it} = cxt\n    const {opts} = it\n    if (!$data && schema.length === 0) return\n    const useLoop = schema.length >= opts.loopRequired\n    if (it.allErrors) allErrorsMode()\n    else exitOnErrorMode()\n\n    if (opts.strictRequired) {\n      const props = cxt.parentSchema.properties\n      const {definedProperties} = cxt.it\n      for (const requiredKey of schema) {\n        if (props?.[requiredKey] === undefined && !definedProperties.has(requiredKey)) {\n          const schemaPath = it.schemaEnv.baseId + it.errSchemaPath\n          const msg = `required property \"${requiredKey}\" is not defined at \"${schemaPath}\" (strictRequired)`\n          checkStrictMode(it, msg, it.opts.strictRequired)\n        }\n      }\n    }\n\n    function allErrorsMode(): void {\n      if (useLoop || $data) {\n        cxt.block$data(nil, loopAllRequired)\n      } else {\n        for (const prop of schema) {\n          checkReportMissingProp(cxt, prop)\n        }\n      }\n    }\n\n    function exitOnErrorMode(): void {\n      const missing = gen.let(\"missing\")\n      if (useLoop || $data) {\n        const valid = gen.let(\"valid\", true)\n        cxt.block$data(valid, () => loopUntilMissing(missing, valid))\n        cxt.ok(valid)\n      } else {\n        gen.if(checkMissingProp(cxt, schema, missing))\n        reportMissingProp(cxt, missing)\n        gen.else()\n      }\n    }\n\n    function loopAllRequired(): void {\n      gen.forOf(\"prop\", schemaCode as Code, (prop) => {\n        cxt.setParams({missingProperty: prop})\n        gen.if(noPropertyInData(gen, data, prop, opts.ownProperties), () => cxt.error())\n      })\n    }\n\n    function loopUntilMissing(missing: Name, valid: Name): void {\n      cxt.setParams({missingProperty: missing})\n      gen.forOf(\n        missing,\n        schemaCode as Code,\n        () => {\n          gen.assign(valid, propertyInData(gen, data, missing, opts.ownProperties))\n          gen.if(not(valid), () => {\n            cxt.error()\n            gen.break()\n          })\n        },\n        nil\n      )\n    }\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {checkDataTypes, getSchemaTypes, DataType} from \"../../compile/validate/dataType\"\nimport {_, str, Name} from \"../../compile/codegen\"\nimport {useFunc} from \"../../compile/util\"\nimport equal from \"../../runtime/equal\"\n\nexport type UniqueItemsError = ErrorObject<\n  \"uniqueItems\",\n  {i: number; j: number},\n  boolean | {$data: string}\n>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {i, j}}) =>\n    str`must NOT have duplicate items (items ## ${j} and ${i} are identical)`,\n  params: ({params: {i, j}}) => _`{i: ${i}, j: ${j}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"uniqueItems\",\n  type: \"array\",\n  schemaType: \"boolean\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, data, $data, schema, parentSchema, schemaCode, it} = cxt\n    if (!$data && !schema) return\n    const valid = gen.let(\"valid\")\n    const itemTypes = parentSchema.items ? getSchemaTypes(parentSchema.items) : []\n    cxt.block$data(valid, validateUniqueItems, _`${schemaCode} === false`)\n    cxt.ok(valid)\n\n    function validateUniqueItems(): void {\n      const i = gen.let(\"i\", _`${data}.length`)\n      const j = gen.let(\"j\")\n      cxt.setParams({i, j})\n      gen.assign(valid, true)\n      gen.if(_`${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j))\n    }\n\n    function canOptimize(): boolean {\n      return itemTypes.length > 0 && !itemTypes.some((t) => t === \"object\" || t === \"array\")\n    }\n\n    function loopN(i: Name, j: Name): void {\n      const item = gen.name(\"item\")\n      const wrongType = checkDataTypes(itemTypes, item, it.opts.strictNumbers, DataType.Wrong)\n      const indices = gen.const(\"indices\", _`{}`)\n      gen.for(_`;${i}--;`, () => {\n        gen.let(item, _`${data}[${i}]`)\n        gen.if(wrongType, _`continue`)\n        if (itemTypes.length > 1) gen.if(_`typeof ${item} == \"string\"`, _`${item} += \"_\"`)\n        gen\n          .if(_`typeof ${indices}[${item}] == \"number\"`, () => {\n            gen.assign(j, _`${indices}[${item}]`)\n            cxt.error()\n            gen.assign(valid, false).break()\n          })\n          .code(_`${indices}[${item}] = ${i}`)\n      })\n    }\n\n    function loopN2(i: Name, j: Name): void {\n      const eql = useFunc(gen, equal)\n      const outer = gen.name(\"outer\")\n      gen.label(outer).for(_`;${i}--;`, () =>\n        gen.for(_`${j} = ${i}; ${j}--;`, () =>\n          gen.if(_`${eql}(${data}[${i}], ${data}[${j}])`, () => {\n            cxt.error()\n            gen.assign(valid, false).break(outer)\n          })\n        )\n      )\n    }\n  },\n}\n\nexport default def\n","'use strict';\n\nvar traverse = module.exports = function (schema, opts, cb) {\n  // Legacy support for v0.3.1 and earlier.\n  if (typeof opts == 'function') {\n    cb = opts;\n    opts = {};\n  }\n\n  cb = opts.cb || cb;\n  var pre = (typeof cb == 'function') ? cb : cb.pre || function() {};\n  var post = cb.post || function() {};\n\n  _traverse(opts, pre, post, schema, '', schema);\n};\n\n\ntraverse.keywords = {\n  additionalItems: true,\n  items: true,\n  contains: true,\n  additionalProperties: true,\n  propertyNames: true,\n  not: true,\n  if: true,\n  then: true,\n  else: true\n};\n\ntraverse.arrayKeywords = {\n  items: true,\n  allOf: true,\n  anyOf: true,\n  oneOf: true\n};\n\ntraverse.propsKeywords = {\n  $defs: true,\n  definitions: true,\n  properties: true,\n  patternProperties: true,\n  dependencies: true\n};\n\ntraverse.skipKeywords = {\n  default: true,\n  enum: true,\n  const: true,\n  required: true,\n  maximum: true,\n  minimum: true,\n  exclusiveMaximum: true,\n  exclusiveMinimum: true,\n  multipleOf: true,\n  maxLength: true,\n  minLength: true,\n  pattern: true,\n  format: true,\n  maxItems: true,\n  minItems: true,\n  uniqueItems: true,\n  maxProperties: true,\n  minProperties: true\n};\n\n\nfunction _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {\n  if (schema && typeof schema == 'object' && !Array.isArray(schema)) {\n    pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);\n    for (var key in schema) {\n      var sch = schema[key];\n      if (Array.isArray(sch)) {\n        if (key in traverse.arrayKeywords) {\n          for (var i=0; i<sch.length; i++)\n            _traverse(opts, pre, post, sch[i], jsonPtr + '/' + key + '/' + i, rootSchema, jsonPtr, key, schema, i);\n        }\n      } else if (key in traverse.propsKeywords) {\n        if (sch && typeof sch == 'object') {\n          for (var prop in sch)\n            _traverse(opts, pre, post, sch[prop], jsonPtr + '/' + key + '/' + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);\n        }\n      } else if (key in traverse.keywords || (opts.allKeys && !(key in traverse.skipKeywords))) {\n        _traverse(opts, pre, post, sch, jsonPtr + '/' + key, rootSchema, jsonPtr, key, schema);\n      }\n    }\n    post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);\n  }\n}\n\n\nfunction escapeJsonPtr(str) {\n  return str.replace(/~/g, '~0').replace(/\\//g, '~1');\n}\n","'use strict';\n\n// do not edit .js files directly - edit src/index.jst\n\n\n\nmodule.exports = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false;\n\n    var length, i, keys;\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;)\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      var key = keys[i];\n\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  // true if both NaN, false otherwise\n  return a!==a && b!==b;\n};\n","export function merge(...sets:Array<string>):string {\n\tif (sets.length > 1) {\n\t\tsets[0] = sets[0].slice(0, -1);\n\t\tconst xl = sets.length - 1;\n\t\tfor (let x = 1; x < xl; ++x) {\n\t\t\tsets[x] = sets[x].slice(1, -1);\n\t\t}\n\t\tsets[xl] = sets[xl].slice(1);\n\t\treturn sets.join('');\n\t} else {\n\t\treturn sets[0];\n\t}\n}\n\nexport function subexp(str:string):string {\n\treturn \"(?:\" + str + \")\";\n}\n\nexport function typeOf(o:any):string {\n\treturn o === undefined ? \"undefined\" : (o === null ? \"null\" : Object.prototype.toString.call(o).split(\" \").pop().split(\"]\").shift().toLowerCase());\n}\n\nexport function toUpperCase(str:string):string {\n\treturn str.toUpperCase();\n}\n\nexport function toArray(obj:any):Array<any> {\n\treturn obj !== undefined && obj !== null ? (obj instanceof Array ? obj : (typeof obj.length !== \"number\" || obj.split || obj.setInterval || obj.call ? [obj] : Array.prototype.slice.call(obj))) : [];\n}\n\n\nexport function assign(target: object, source: any): any {\n\tconst obj = target as any;\n\tif (source) {\n\t\tfor (const key in source) {\n\t\t\tobj[key] = source[key];\n\t\t}\n\t}\n\treturn obj;\n}","import { URIRegExps } from \"./uri\";\nimport { merge, subexp } from \"./util\";\n\nexport function buildExps(isIRI:boolean):URIRegExps {\n\tconst\n\t\tALPHA$$ = \"[A-Za-z]\",\n\t\tCR$ = \"[\\\\x0D]\",\n\t\tDIGIT$$ = \"[0-9]\",\n\t\tDQUOTE$$ = \"[\\\\x22]\",\n\t\tHEXDIG$$ = merge(DIGIT$$, \"[A-Fa-f]\"),  //case-insensitive\n\t\tLF$$ = \"[\\\\x0A]\",\n\t\tSP$$ = \"[\\\\x20]\",\n\t\tPCT_ENCODED$ = subexp(subexp(\"%[EFef]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%[89A-Fa-f]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%\" + HEXDIG$$ + HEXDIG$$)),  //expanded\n\t\tGEN_DELIMS$$ = \"[\\\\:\\\\/\\\\?\\\\#\\\\[\\\\]\\\\@]\",\n\t\tSUB_DELIMS$$ = \"[\\\\!\\\\$\\\\&\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\;\\\\=]\",\n\t\tRESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$),\n\t\tUCSCHAR$$ = isIRI ? \"[\\\\xA0-\\\\u200D\\\\u2010-\\\\u2029\\\\u202F-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF]\" : \"[]\",  //subset, excludes bidi control characters\n\t\tIPRIVATE$$ = isIRI ? \"[\\\\uE000-\\\\uF8FF]\" : \"[]\",  //subset\n\t\tUNRESERVED$$ = merge(ALPHA$$, DIGIT$$, \"[\\\\-\\\\.\\\\_\\\\~]\", UCSCHAR$$),\n\t\tSCHEME$ = subexp(ALPHA$$ + merge(ALPHA$$, DIGIT$$, \"[\\\\+\\\\-\\\\.]\") + \"*\"),\n\t\tUSERINFO$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:]\")) + \"*\"),\n\t\tDEC_OCTET$ = subexp(subexp(\"25[0-5]\") + \"|\" + subexp(\"2[0-4]\" + DIGIT$$) + \"|\" + subexp(\"1\" + DIGIT$$ + DIGIT$$) + \"|\" + subexp(\"[1-9]\" + DIGIT$$) + \"|\" + DIGIT$$),\n\t\tDEC_OCTET_RELAXED$ = subexp(subexp(\"25[0-5]\") + \"|\" + subexp(\"2[0-4]\" + DIGIT$$) + \"|\" + subexp(\"1\" + DIGIT$$ + DIGIT$$) + \"|\" + subexp(\"0?[1-9]\" + DIGIT$$) + \"|0?0?\" + DIGIT$$),  //relaxed parsing rules\n\t\tIPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + \"\\\\.\" + DEC_OCTET_RELAXED$ + \"\\\\.\" + DEC_OCTET_RELAXED$ + \"\\\\.\" + DEC_OCTET_RELAXED$),\n\t\tH16$ = subexp(HEXDIG$$ + \"{1,4}\"),\n\t\tLS32$ = subexp(subexp(H16$ + \"\\\\:\" + H16$) + \"|\" + IPV4ADDRESS$),\n\t\tIPV6ADDRESS1$ = subexp(                                                            subexp(H16$ + \"\\\\:\") + \"{6}\" + LS32$), //                           6( h16 \":\" ) ls32\n\t\tIPV6ADDRESS2$ = subexp(                                                 \"\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{5}\" + LS32$), //                      \"::\" 5( h16 \":\" ) ls32\n\t\tIPV6ADDRESS3$ = subexp(subexp(                                 H16$) + \"?\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{4}\" + LS32$), //[               h16 ] \"::\" 4( h16 \":\" ) ls32\n\t\tIPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,1}\" + H16$) + \"?\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{3}\" + LS32$), //[ *1( h16 \":\" ) h16 ] \"::\" 3( h16 \":\" ) ls32\n\t\tIPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,2}\" + H16$) + \"?\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{2}\" + LS32$), //[ *2( h16 \":\" ) h16 ] \"::\" 2( h16 \":\" ) ls32\n\t\tIPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,3}\" + H16$) + \"?\\\\:\\\\:\" +        H16$ + \"\\\\:\"          + LS32$), //[ *3( h16 \":\" ) h16 ] \"::\"    h16 \":\"   ls32\n\t\tIPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,4}\" + H16$) + \"?\\\\:\\\\:\"                                + LS32$), //[ *4( h16 \":\" ) h16 ] \"::\"              ls32\n\t\tIPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,5}\" + H16$) + \"?\\\\:\\\\:\"                                + H16$ ), //[ *5( h16 \":\" ) h16 ] \"::\"              h16\n\t\tIPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,6}\" + H16$) + \"?\\\\:\\\\:\"                                       ), //[ *6( h16 \":\" ) h16 ] \"::\"\n\t\tIPV6ADDRESS$ = subexp([IPV6ADDRESS1$, IPV6ADDRESS2$, IPV6ADDRESS3$, IPV6ADDRESS4$, IPV6ADDRESS5$, IPV6ADDRESS6$, IPV6ADDRESS7$, IPV6ADDRESS8$, IPV6ADDRESS9$].join(\"|\")),\n\t\tZONEID$ = subexp(subexp(UNRESERVED$$ + \"|\" + PCT_ENCODED$) + \"+\"),  //RFC 6874\n\t\tIPV6ADDRZ$ = subexp(IPV6ADDRESS$ + \"\\\\%25\" + ZONEID$),  //RFC 6874\n\t\tIPV6ADDRZ_RELAXED$ = subexp(IPV6ADDRESS$ + subexp(\"\\\\%25|\\\\%(?!\" + HEXDIG$$ + \"{2})\") + ZONEID$),  //RFC 6874, with relaxed parsing rules\n\t\tIPVFUTURE$ = subexp(\"[vV]\" + HEXDIG$$ + \"+\\\\.\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:]\") + \"+\"),\n\t\tIP_LITERAL$ = subexp(\"\\\\[\" + subexp(IPV6ADDRZ_RELAXED$ + \"|\" + IPV6ADDRESS$ + \"|\" + IPVFUTURE$) + \"\\\\]\"),  //RFC 6874\n\t\tREG_NAME$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$)) + \"*\"),\n\t\tHOST$ = subexp(IP_LITERAL$ + \"|\" + IPV4ADDRESS$ + \"(?!\" + REG_NAME$ + \")\" + \"|\" + REG_NAME$),\n\t\tPORT$ = subexp(DIGIT$$ + \"*\"),\n\t\tAUTHORITY$ = subexp(subexp(USERINFO$ + \"@\") + \"?\" + HOST$ + subexp(\"\\\\:\" + PORT$) + \"?\"),\n\t\tPCHAR$ = subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@]\")),\n\t\tSEGMENT$ = subexp(PCHAR$ + \"*\"),\n\t\tSEGMENT_NZ$ = subexp(PCHAR$ + \"+\"),\n\t\tSEGMENT_NZ_NC$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\@]\")) + \"+\"),\n\t\tPATH_ABEMPTY$ = subexp(subexp(\"\\\\/\" + SEGMENT$) + \"*\"),\n\t\tPATH_ABSOLUTE$ = subexp(\"\\\\/\" + subexp(SEGMENT_NZ$ + PATH_ABEMPTY$) + \"?\"),  //simplified\n\t\tPATH_NOSCHEME$ = subexp(SEGMENT_NZ_NC$ + PATH_ABEMPTY$),  //simplified\n\t\tPATH_ROOTLESS$ = subexp(SEGMENT_NZ$ + PATH_ABEMPTY$),  //simplified\n\t\tPATH_EMPTY$ = \"(?!\" + PCHAR$ + \")\",\n\t\tPATH$ = subexp(PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$),\n\t\tQUERY$ = subexp(subexp(PCHAR$ + \"|\" + merge(\"[\\\\/\\\\?]\", IPRIVATE$$)) + \"*\"),\n\t\tFRAGMENT$ = subexp(subexp(PCHAR$ + \"|[\\\\/\\\\?]\") + \"*\"),\n\t\tHIER_PART$ = subexp(subexp(\"\\\\/\\\\/\" + AUTHORITY$ + PATH_ABEMPTY$) + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$),\n\t\tURI$ = subexp(SCHEME$ + \"\\\\:\" + HIER_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\" + subexp(\"\\\\#\" + FRAGMENT$) + \"?\"),\n\t\tRELATIVE_PART$ = subexp(subexp(\"\\\\/\\\\/\" + AUTHORITY$ + PATH_ABEMPTY$) + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_EMPTY$),\n\t\tRELATIVE$ = subexp(RELATIVE_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\" + subexp(\"\\\\#\" + FRAGMENT$) + \"?\"),\n\t\tURI_REFERENCE$ = subexp(URI$ + \"|\" + RELATIVE$),\n\t\tABSOLUTE_URI$ = subexp(SCHEME$ + \"\\\\:\" + HIER_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\"),\n\n\t\tGENERIC_REF$ = \"^(\" + SCHEME$ + \")\\\\:\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\",\n\t\tRELATIVE_REF$ = \"^(){0}\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\",\n\t\tABSOLUTE_REF$ = \"^(\" + SCHEME$ + \")\\\\:\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?$\",\n\t\tSAMEDOC_REF$ = \"^\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\",\n\t\tAUTHORITY_REF$ = \"^\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?$\"\n\t;\n\n\treturn {\n\t\tNOT_SCHEME : new RegExp(merge(\"[^]\", ALPHA$$, DIGIT$$, \"[\\\\+\\\\-\\\\.]\"), \"g\"),\n\t\tNOT_USERINFO : new RegExp(merge(\"[^\\\\%\\\\:]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n\t\tNOT_HOST : new RegExp(merge(\"[^\\\\%\\\\[\\\\]\\\\:]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n\t\tNOT_PATH : new RegExp(merge(\"[^\\\\%\\\\/\\\\:\\\\@]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n\t\tNOT_PATH_NOSCHEME : new RegExp(merge(\"[^\\\\%\\\\/\\\\@]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n\t\tNOT_QUERY : new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@\\\\/\\\\?]\", IPRIVATE$$), \"g\"),\n\t\tNOT_FRAGMENT : new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@\\\\/\\\\?]\"), \"g\"),\n\t\tESCAPE : new RegExp(merge(\"[^]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n\t\tUNRESERVED : new RegExp(UNRESERVED$$, \"g\"),\n\t\tOTHER_CHARS : new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, RESERVED$$), \"g\"),\n\t\tPCT_ENCODED : new RegExp(PCT_ENCODED$, \"g\"),\n\t\tIPV4ADDRESS : new RegExp(\"^(\" + IPV4ADDRESS$ + \")$\"),\n\t\tIPV6ADDRESS : new RegExp(\"^\\\\[?(\" + IPV6ADDRESS$ + \")\" + subexp(subexp(\"\\\\%25|\\\\%(?!\" + HEXDIG$$ + \"{2})\") + \"(\" + ZONEID$ + \")\") + \"?\\\\]?$\")  //RFC 6874, with relaxed parsing rules\n\t};\n}\n\nexport default buildExps(false);\n","import { URIRegExps } from \"./uri\";\nimport { buildExps } from \"./regexps-uri\";\n\nexport default buildExps(true);\n","'use strict';\n\n/** Highest positive signed 32-bit float value */\nconst maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1\n\n/** Bootstring parameters */\nconst base = 36;\nconst tMin = 1;\nconst tMax = 26;\nconst skew = 38;\nconst damp = 700;\nconst initialBias = 72;\nconst initialN = 128; // 0x80\nconst delimiter = '-'; // '\\x2D'\n\n/** Regular expressions */\nconst regexPunycode = /^xn--/;\nconst regexNonASCII = /[^\\0-\\x7E]/; // non-ASCII chars\nconst regexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g; // RFC 3490 separators\n\n/** Error messages */\nconst errors = {\n\t'overflow': 'Overflow: input needs wider integers to process',\n\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n\t'invalid-input': 'Invalid input'\n};\n\n/** Convenience shortcuts */\nconst baseMinusTMin = base - tMin;\nconst floor = Math.floor;\nconst stringFromCharCode = String.fromCharCode;\n\n/*--------------------------------------------------------------------------*/\n\n/**\n * A generic error utility function.\n * @private\n * @param {String} type The error type.\n * @returns {Error} Throws a `RangeError` with the applicable error message.\n */\nfunction error(type) {\n\tthrow new RangeError(errors[type]);\n}\n\n/**\n * A generic `Array#map` utility function.\n * @private\n * @param {Array} array The array to iterate over.\n * @param {Function} callback The function that gets called for every array\n * item.\n * @returns {Array} A new array of values returned by the callback function.\n */\nfunction map(array, fn) {\n\tconst result = [];\n\tlet length = array.length;\n\twhile (length--) {\n\t\tresult[length] = fn(array[length]);\n\t}\n\treturn result;\n}\n\n/**\n * A simple `Array#map`-like wrapper to work with domain name strings or email\n * addresses.\n * @private\n * @param {String} domain The domain name or email address.\n * @param {Function} callback The function that gets called for every\n * character.\n * @returns {Array} A new string of characters returned by the callback\n * function.\n */\nfunction mapDomain(string, fn) {\n\tconst parts = string.split('@');\n\tlet result = '';\n\tif (parts.length > 1) {\n\t\t// In email addresses, only the domain name should be punycoded. Leave\n\t\t// the local part (i.e. everything up to `@`) intact.\n\t\tresult = parts[0] + '@';\n\t\tstring = parts[1];\n\t}\n\t// Avoid `split(regex)` for IE8 compatibility. See #17.\n\tstring = string.replace(regexSeparators, '\\x2E');\n\tconst labels = string.split('.');\n\tconst encoded = map(labels, fn).join('.');\n\treturn result + encoded;\n}\n\n/**\n * Creates an array containing the numeric code points of each Unicode\n * character in the string. While JavaScript uses UCS-2 internally,\n * this function will convert a pair of surrogate halves (each of which\n * UCS-2 exposes as separate characters) into a single code point,\n * matching UTF-16.\n * @see `punycode.ucs2.encode`\n * @see <https://mathiasbynens.be/notes/javascript-encoding>\n * @memberOf punycode.ucs2\n * @name decode\n * @param {String} string The Unicode input string (UCS-2).\n * @returns {Array} The new array of code points.\n */\nfunction ucs2decode(string) {\n\tconst output = [];\n\tlet counter = 0;\n\tconst length = string.length;\n\twhile (counter < length) {\n\t\tconst value = string.charCodeAt(counter++);\n\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t// It's a high surrogate, and there is a next character.\n\t\t\tconst extra = string.charCodeAt(counter++);\n\t\t\tif ((extra & 0xFC00) == 0xDC00) { // Low surrogate.\n\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t} else {\n\t\t\t\t// It's an unmatched surrogate; only append this code unit, in case the\n\t\t\t\t// next code unit is the high surrogate of a surrogate pair.\n\t\t\t\toutput.push(value);\n\t\t\t\tcounter--;\n\t\t\t}\n\t\t} else {\n\t\t\toutput.push(value);\n\t\t}\n\t}\n\treturn output;\n}\n\n/**\n * Creates a string based on an array of numeric code points.\n * @see `punycode.ucs2.decode`\n * @memberOf punycode.ucs2\n * @name encode\n * @param {Array} codePoints The array of numeric code points.\n * @returns {String} The new Unicode string (UCS-2).\n */\nconst ucs2encode = array => String.fromCodePoint(...array);\n\n/**\n * Converts a basic code point into a digit/integer.\n * @see `digitToBasic()`\n * @private\n * @param {Number} codePoint The basic numeric code point value.\n * @returns {Number} The numeric value of a basic code point (for use in\n * representing integers) in the range `0` to `base - 1`, or `base` if\n * the code point does not represent a value.\n */\nconst basicToDigit = function(codePoint) {\n\tif (codePoint - 0x30 < 0x0A) {\n\t\treturn codePoint - 0x16;\n\t}\n\tif (codePoint - 0x41 < 0x1A) {\n\t\treturn codePoint - 0x41;\n\t}\n\tif (codePoint - 0x61 < 0x1A) {\n\t\treturn codePoint - 0x61;\n\t}\n\treturn base;\n};\n\n/**\n * Converts a digit/integer into a basic code point.\n * @see `basicToDigit()`\n * @private\n * @param {Number} digit The numeric value of a basic code point.\n * @returns {Number} The basic code point whose value (when used for\n * representing integers) is `digit`, which needs to be in the range\n * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n * used; else, the lowercase form is used. The behavior is undefined\n * if `flag` is non-zero and `digit` has no uppercase form.\n */\nconst digitToBasic = function(digit, flag) {\n\t//  0..25 map to ASCII a..z or A..Z\n\t// 26..35 map to ASCII 0..9\n\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n};\n\n/**\n * Bias adaptation function as per section 3.4 of RFC 3492.\n * https://tools.ietf.org/html/rfc3492#section-3.4\n * @private\n */\nconst adapt = function(delta, numPoints, firstTime) {\n\tlet k = 0;\n\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\n\tdelta += floor(delta / numPoints);\n\tfor (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {\n\t\tdelta = floor(delta / baseMinusTMin);\n\t}\n\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n};\n\n/**\n * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n * symbols.\n * @memberOf punycode\n * @param {String} input The Punycode string of ASCII-only symbols.\n * @returns {String} The resulting string of Unicode symbols.\n */\nconst decode = function(input) {\n\t// Don't use UCS-2.\n\tconst output = [];\n\tconst inputLength = input.length;\n\tlet i = 0;\n\tlet n = initialN;\n\tlet bias = initialBias;\n\n\t// Handle the basic code points: let `basic` be the number of input code\n\t// points before the last delimiter, or `0` if there is none, then copy\n\t// the first basic code points to the output.\n\n\tlet basic = input.lastIndexOf(delimiter);\n\tif (basic < 0) {\n\t\tbasic = 0;\n\t}\n\n\tfor (let j = 0; j < basic; ++j) {\n\t\t// if it's not a basic code point\n\t\tif (input.charCodeAt(j) >= 0x80) {\n\t\t\terror('not-basic');\n\t\t}\n\t\toutput.push(input.charCodeAt(j));\n\t}\n\n\t// Main decoding loop: start just after the last delimiter if any basic code\n\t// points were copied; start at the beginning otherwise.\n\n\tfor (let index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {\n\n\t\t// `index` is the index of the next character to be consumed.\n\t\t// Decode a generalized variable-length integer into `delta`,\n\t\t// which gets added to `i`. The overflow checking is easier\n\t\t// if we increase `i` as we go, then subtract off its starting\n\t\t// value at the end to obtain `delta`.\n\t\tlet oldi = i;\n\t\tfor (let w = 1, k = base; /* no condition */; k += base) {\n\n\t\t\tif (index >= inputLength) {\n\t\t\t\terror('invalid-input');\n\t\t\t}\n\n\t\t\tconst digit = basicToDigit(input.charCodeAt(index++));\n\n\t\t\tif (digit >= base || digit > floor((maxInt - i) / w)) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\ti += digit * w;\n\t\t\tconst t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\n\t\t\tif (digit < t) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst baseMinusT = base - t;\n\t\t\tif (w > floor(maxInt / baseMinusT)) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tw *= baseMinusT;\n\n\t\t}\n\n\t\tconst out = output.length + 1;\n\t\tbias = adapt(i - oldi, out, oldi == 0);\n\n\t\t// `i` was supposed to wrap around from `out` to `0`,\n\t\t// incrementing `n` each time, so we'll fix that now:\n\t\tif (floor(i / out) > maxInt - n) {\n\t\t\terror('overflow');\n\t\t}\n\n\t\tn += floor(i / out);\n\t\ti %= out;\n\n\t\t// Insert `n` at position `i` of the output.\n\t\toutput.splice(i++, 0, n);\n\n\t}\n\n\treturn String.fromCodePoint(...output);\n};\n\n/**\n * Converts a string of Unicode symbols (e.g. a domain name label) to a\n * Punycode string of ASCII-only symbols.\n * @memberOf punycode\n * @param {String} input The string of Unicode symbols.\n * @returns {String} The resulting Punycode string of ASCII-only symbols.\n */\nconst encode = function(input) {\n\tconst output = [];\n\n\t// Convert the input in UCS-2 to an array of Unicode code points.\n\tinput = ucs2decode(input);\n\n\t// Cache the length.\n\tlet inputLength = input.length;\n\n\t// Initialize the state.\n\tlet n = initialN;\n\tlet delta = 0;\n\tlet bias = initialBias;\n\n\t// Handle the basic code points.\n\tfor (const currentValue of input) {\n\t\tif (currentValue < 0x80) {\n\t\t\toutput.push(stringFromCharCode(currentValue));\n\t\t}\n\t}\n\n\tlet basicLength = output.length;\n\tlet handledCPCount = basicLength;\n\n\t// `handledCPCount` is the number of code points that have been handled;\n\t// `basicLength` is the number of basic code points.\n\n\t// Finish the basic string with a delimiter unless it's empty.\n\tif (basicLength) {\n\t\toutput.push(delimiter);\n\t}\n\n\t// Main encoding loop:\n\twhile (handledCPCount < inputLength) {\n\n\t\t// All non-basic code points < n have been handled already. Find the next\n\t\t// larger one:\n\t\tlet m = maxInt;\n\t\tfor (const currentValue of input) {\n\t\t\tif (currentValue >= n && currentValue < m) {\n\t\t\t\tm = currentValue;\n\t\t\t}\n\t\t}\n\n\t\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n\t\t// but guard against overflow.\n\t\tconst handledCPCountPlusOne = handledCPCount + 1;\n\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n\t\t\terror('overflow');\n\t\t}\n\n\t\tdelta += (m - n) * handledCPCountPlusOne;\n\t\tn = m;\n\n\t\tfor (const currentValue of input) {\n\t\t\tif (currentValue < n && ++delta > maxInt) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\t\t\tif (currentValue == n) {\n\t\t\t\t// Represent delta as a generalized variable-length integer.\n\t\t\t\tlet q = delta;\n\t\t\t\tfor (let k = base; /* no condition */; k += base) {\n\t\t\t\t\tconst t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\t\t\t\t\tif (q < t) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tconst qMinusT = q - t;\n\t\t\t\t\tconst baseMinusT = base - t;\n\t\t\t\t\toutput.push(\n\t\t\t\t\t\tstringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))\n\t\t\t\t\t);\n\t\t\t\t\tq = floor(qMinusT / baseMinusT);\n\t\t\t\t}\n\n\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\n\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n\t\t\t\tdelta = 0;\n\t\t\t\t++handledCPCount;\n\t\t\t}\n\t\t}\n\n\t\t++delta;\n\t\t++n;\n\n\t}\n\treturn output.join('');\n};\n\n/**\n * Converts a Punycode string representing a domain name or an email address\n * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n * it doesn't matter if you call it on a string that has already been\n * converted to Unicode.\n * @memberOf punycode\n * @param {String} input The Punycoded domain name or email address to\n * convert to Unicode.\n * @returns {String} The Unicode representation of the given Punycode\n * string.\n */\nconst toUnicode = function(input) {\n\treturn mapDomain(input, function(string) {\n\t\treturn regexPunycode.test(string)\n\t\t\t? decode(string.slice(4).toLowerCase())\n\t\t\t: string;\n\t});\n};\n\n/**\n * Converts a Unicode string representing a domain name or an email address to\n * Punycode. Only the non-ASCII parts of the domain name will be converted,\n * i.e. it doesn't matter if you call it with a domain that's already in\n * ASCII.\n * @memberOf punycode\n * @param {String} input The domain name or email address to convert, as a\n * Unicode string.\n * @returns {String} The Punycode representation of the given domain name or\n * email address.\n */\nconst toASCII = function(input) {\n\treturn mapDomain(input, function(string) {\n\t\treturn regexNonASCII.test(string)\n\t\t\t? 'xn--' + encode(string)\n\t\t\t: string;\n\t});\n};\n\n/*--------------------------------------------------------------------------*/\n\n/** Define the public API */\nconst punycode = {\n\t/**\n\t * A string representing the current Punycode.js version number.\n\t * @memberOf punycode\n\t * @type String\n\t */\n\t'version': '2.1.0',\n\t/**\n\t * An object of methods to convert from JavaScript's internal character\n\t * representation (UCS-2) to Unicode code points, and back.\n\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t * @memberOf punycode\n\t * @type Object\n\t */\n\t'ucs2': {\n\t\t'decode': ucs2decode,\n\t\t'encode': ucs2encode\n\t},\n\t'decode': decode,\n\t'encode': encode,\n\t'toASCII': toASCII,\n\t'toUnicode': toUnicode\n};\n\nexport default punycode;\n","/**\n * URI.js\n *\n * @fileoverview An RFC 3986 compliant, scheme extendable URI parsing/validating/resolving library for JavaScript.\n * @author <a href=\"mailto:gary.court@gmail.com\">Gary Court</a>\n * @see http://github.com/garycourt/uri-js\n */\n\n/**\n * Copyright 2011 Gary Court. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are\n * permitted provided that the following conditions are met:\n *\n *    1. Redistributions of source code must retain the above copyright notice, this list of\n *       conditions and the following disclaimer.\n *\n *    2. Redistributions in binary form must reproduce the above copyright notice, this list\n *       of conditions and the following disclaimer in the documentation and/or other materials\n *       provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY GARY COURT ``AS IS'' AND ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GARY COURT OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * The views and conclusions contained in the software and documentation are those of the\n * authors and should not be interpreted as representing official policies, either expressed\n * or implied, of Gary Court.\n */\n\nimport URI_PROTOCOL from \"./regexps-uri\";\nimport IRI_PROTOCOL from \"./regexps-iri\";\nimport punycode from \"punycode\";\nimport { toUpperCase, typeOf, assign } from \"./util\";\n\nexport interface URIComponents {\n\tscheme?:string;\n\tuserinfo?:string;\n\thost?:string;\n\tport?:number|string;\n\tpath?:string;\n\tquery?:string;\n\tfragment?:string;\n\treference?:string;\n\terror?:string;\n}\n\nexport interface URIOptions {\n\tscheme?:string;\n\treference?:string;\n\ttolerant?:boolean;\n\tabsolutePath?:boolean;\n\tiri?:boolean;\n\tunicodeSupport?:boolean;\n\tdomainHost?:boolean;\n}\n\nexport interface URISchemeHandler<Components extends URIComponents = URIComponents, Options extends URIOptions = URIOptions, ParentComponents extends URIComponents = URIComponents> {\n\tscheme:string;\n\tparse(components:ParentComponents, options:Options):Components;\n\tserialize(components:Components, options:Options):ParentComponents;\n\tunicodeSupport?:boolean;\n\tdomainHost?:boolean;\n\tabsolutePath?:boolean;\n}\n\nexport interface URIRegExps {\n\tNOT_SCHEME : RegExp,\n\tNOT_USERINFO : RegExp,\n\tNOT_HOST : RegExp,\n\tNOT_PATH : RegExp,\n\tNOT_PATH_NOSCHEME : RegExp,\n\tNOT_QUERY : RegExp,\n\tNOT_FRAGMENT : RegExp,\n\tESCAPE : RegExp,\n\tUNRESERVED : RegExp,\n\tOTHER_CHARS : RegExp,\n\tPCT_ENCODED : RegExp,\n\tIPV4ADDRESS : RegExp,\n\tIPV6ADDRESS : RegExp,\n}\n\nexport const SCHEMES:{[scheme:string]:URISchemeHandler} = {};\n\nexport function pctEncChar(chr:string):string {\n\tconst c = chr.charCodeAt(0);\n\tlet e:string;\n\n\tif (c < 16) e = \"%0\" + c.toString(16).toUpperCase();\n\telse if (c < 128) e = \"%\" + c.toString(16).toUpperCase();\n\telse if (c < 2048) e = \"%\" + ((c >> 6) | 192).toString(16).toUpperCase() + \"%\" + ((c & 63) | 128).toString(16).toUpperCase();\n\telse e = \"%\" + ((c >> 12) | 224).toString(16).toUpperCase() + \"%\" + (((c >> 6) & 63) | 128).toString(16).toUpperCase() + \"%\" + ((c & 63) | 128).toString(16).toUpperCase();\n\n\treturn e;\n}\n\nexport function pctDecChars(str:string):string {\n\tlet newStr = \"\";\n\tlet i = 0;\n\tconst il = str.length;\n\n\twhile (i < il) {\n\t\tconst c = parseInt(str.substr(i + 1, 2), 16);\n\n\t\tif (c < 128) {\n\t\t\tnewStr += String.fromCharCode(c);\n\t\t\ti += 3;\n\t\t}\n\t\telse if (c >= 194 && c < 224) {\n\t\t\tif ((il - i) >= 6) {\n\t\t\t\tconst c2 = parseInt(str.substr(i + 4, 2), 16);\n\t\t\t\tnewStr += String.fromCharCode(((c & 31) << 6) | (c2 & 63));\n\t\t\t} else {\n\t\t\t\tnewStr += str.substr(i, 6);\n\t\t\t}\n\t\t\ti += 6;\n\t\t}\n\t\telse if (c >= 224) {\n\t\t\tif ((il - i) >= 9) {\n\t\t\t\tconst c2 = parseInt(str.substr(i + 4, 2), 16);\n\t\t\t\tconst c3 = parseInt(str.substr(i + 7, 2), 16);\n\t\t\t\tnewStr += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));\n\t\t\t} else {\n\t\t\t\tnewStr += str.substr(i, 9);\n\t\t\t}\n\t\t\ti += 9;\n\t\t}\n\t\telse {\n\t\t\tnewStr += str.substr(i, 3);\n\t\t\ti += 3;\n\t\t}\n\t}\n\n\treturn newStr;\n}\n\nfunction _normalizeComponentEncoding(components:URIComponents, protocol:URIRegExps) {\n\tfunction decodeUnreserved(str:string):string {\n\t\tconst decStr = pctDecChars(str);\n\t\treturn (!decStr.match(protocol.UNRESERVED) ? str : decStr);\n\t}\n\n\tif (components.scheme) components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_SCHEME, \"\");\n\tif (components.userinfo !== undefined) components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n\tif (components.host !== undefined) components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n\tif (components.path !== undefined) components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved).replace((components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME), pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n\tif (components.query !== undefined) components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n\tif (components.fragment !== undefined) components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n\n\treturn components;\n};\n\nfunction _stripLeadingZeros(str:string):string {\n\treturn str.replace(/^0*(.*)/, \"$1\") || \"0\";\n}\n\nfunction _normalizeIPv4(host:string, protocol:URIRegExps):string {\n\tconst matches = host.match(protocol.IPV4ADDRESS) || [];\n\tconst [, address] = matches;\n\t\n\tif (address) {\n\t\treturn address.split(\".\").map(_stripLeadingZeros).join(\".\");\n\t} else {\n\t\treturn host;\n\t}\n}\n\nfunction _normalizeIPv6(host:string, protocol:URIRegExps):string {\n\tconst matches = host.match(protocol.IPV6ADDRESS) || [];\n\tconst [, address, zone] = matches;\n\n\tif (address) {\n\t\tconst [last, first] = address.toLowerCase().split('::').reverse();\n\t\tconst firstFields = first ? first.split(\":\").map(_stripLeadingZeros) : [];\n\t\tconst lastFields = last.split(\":\").map(_stripLeadingZeros);\n\t\tconst isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);\n\t\tconst fieldCount = isLastFieldIPv4Address ? 7 : 8;\n\t\tconst lastFieldsStart = lastFields.length - fieldCount;\n\t\tconst fields = Array<string>(fieldCount);\n\n\t\tfor (let x = 0; x < fieldCount; ++x) {\n\t\t\tfields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || '';\n\t\t}\n\n\t\tif (isLastFieldIPv4Address) {\n\t\t\tfields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);\n\t\t}\n\n\t\tconst allZeroFields = fields.reduce<Array<{index:number,length:number}>>((acc, field, index) => {\n\t\t\tif (!field || field === \"0\") {\n\t\t\t\tconst lastLongest = acc[acc.length - 1];\n\t\t\t\tif (lastLongest && lastLongest.index + lastLongest.length === index) {\n\t\t\t\t\tlastLongest.length++;\n\t\t\t\t} else {\n\t\t\t\t\tacc.push({ index, length : 1 });\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn acc;\n\t\t}, []);\n\n\t\tconst longestZeroFields = allZeroFields.sort((a, b) => b.length - a.length)[0];\n\n\t\tlet newHost:string;\n\t\tif (longestZeroFields && longestZeroFields.length > 1) {\n\t\t\tconst newFirst = fields.slice(0, longestZeroFields.index) ;\n\t\t\tconst newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);\n\t\t\tnewHost = newFirst.join(\":\") + \"::\" + newLast.join(\":\");\n\t\t} else {\n\t\t\tnewHost = fields.join(\":\");\n\t\t}\n\n\t\tif (zone) {\n\t\t\tnewHost += \"%\" + zone;\n\t\t}\n\n\t\treturn newHost;\n\t} else {\n\t\treturn host;\n\t}\n}\n\nconst URI_PARSE = /^(?:([^:\\/?#]+):)?(?:\\/\\/((?:([^\\/?#@]*)@)?(\\[[^\\/?#\\]]+\\]|[^\\/?#:]*)(?:\\:(\\d*))?))?([^?#]*)(?:\\?([^#]*))?(?:#((?:.|\\n|\\r)*))?/i;\nconst NO_MATCH_IS_UNDEFINED = (<RegExpMatchArray>(\"\").match(/(){0}/))[1] === undefined;\n\nexport function parse(uriString:string, options:URIOptions = {}):URIComponents {\n\tconst components:URIComponents = {};\n\tconst protocol = (options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL);\n\n\tif (options.reference === \"suffix\") uriString = (options.scheme ? options.scheme + \":\" : \"\") + \"//\" + uriString;\n\n\tconst matches = uriString.match(URI_PARSE);\n\n\tif (matches) {\n\t\tif (NO_MATCH_IS_UNDEFINED) {\n\t\t\t//store each component\n\t\t\tcomponents.scheme = matches[1];\n\t\t\tcomponents.userinfo = matches[3];\n\t\t\tcomponents.host = matches[4];\n\t\t\tcomponents.port = parseInt(matches[5], 10);\n\t\t\tcomponents.path = matches[6] || \"\";\n\t\t\tcomponents.query = matches[7];\n\t\t\tcomponents.fragment = matches[8];\n\n\t\t\t//fix port number\n\t\t\tif (isNaN(components.port)) {\n\t\t\t\tcomponents.port = matches[5];\n\t\t\t}\n\t\t} else {  //IE FIX for improper RegExp matching\n\t\t\t//store each component\n\t\t\tcomponents.scheme = matches[1] || undefined;\n\t\t\tcomponents.userinfo = (uriString.indexOf(\"@\") !== -1 ? matches[3] : undefined);\n\t\t\tcomponents.host = (uriString.indexOf(\"//\") !== -1 ? matches[4] : undefined);\n\t\t\tcomponents.port = parseInt(matches[5], 10);\n\t\t\tcomponents.path = matches[6] || \"\";\n\t\t\tcomponents.query = (uriString.indexOf(\"?\") !== -1 ? matches[7] : undefined);\n\t\t\tcomponents.fragment = (uriString.indexOf(\"#\") !== -1 ? matches[8] : undefined);\n\n\t\t\t//fix port number\n\t\t\tif (isNaN(components.port)) {\n\t\t\t\tcomponents.port = (uriString.match(/\\/\\/(?:.|\\n)*\\:(?:\\/|\\?|\\#|$)/) ? matches[4] : undefined);\n\t\t\t}\n\t\t}\n\n\t\tif (components.host) {\n\t\t\t//normalize IP hosts\n\t\t\tcomponents.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);\n\t\t}\n\n\t\t//determine reference type\n\t\tif (components.scheme === undefined && components.userinfo === undefined && components.host === undefined && components.port === undefined && !components.path && components.query === undefined) {\n\t\t\tcomponents.reference = \"same-document\";\n\t\t} else if (components.scheme === undefined) {\n\t\t\tcomponents.reference = \"relative\";\n\t\t} else if (components.fragment === undefined) {\n\t\t\tcomponents.reference = \"absolute\";\n\t\t} else {\n\t\t\tcomponents.reference = \"uri\";\n\t\t}\n\n\t\t//check for reference errors\n\t\tif (options.reference && options.reference !== \"suffix\" && options.reference !== components.reference) {\n\t\t\tcomponents.error = components.error || \"URI is not a \" + options.reference + \" reference.\";\n\t\t}\n\n\t\t//find scheme handler\n\t\tconst schemeHandler = SCHEMES[(options.scheme || components.scheme || \"\").toLowerCase()];\n\n\t\t//check if scheme can't handle IRIs\n\t\tif (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {\n\t\t\t//if host component is a domain name\n\t\t\tif (components.host && (options.domainHost || (schemeHandler && schemeHandler.domainHost))) {\n\t\t\t\t//convert Unicode IDN -> ASCII IDN\n\t\t\t\ttry {\n\t\t\t\t\tcomponents.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());\n\t\t\t\t} catch (e) {\n\t\t\t\t\tcomponents.error = components.error || \"Host's domain name can not be converted to ASCII via punycode: \" + e;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//convert IRI -> URI\n\t\t\t_normalizeComponentEncoding(components, URI_PROTOCOL);\n\t\t} else {\n\t\t\t//normalize encodings\n\t\t\t_normalizeComponentEncoding(components, protocol);\n\t\t}\n\n\t\t//perform scheme specific parsing\n\t\tif (schemeHandler && schemeHandler.parse) {\n\t\t\tschemeHandler.parse(components, options);\n\t\t}\n\t} else {\n\t\tcomponents.error = components.error || \"URI can not be parsed.\";\n\t}\n\n\treturn components;\n};\n\nfunction _recomposeAuthority(components:URIComponents, options:URIOptions):string|undefined {\n\tconst protocol = (options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL);\n\tconst uriTokens:Array<string> = [];\n\n\tif (components.userinfo !== undefined) {\n\t\turiTokens.push(components.userinfo);\n\t\turiTokens.push(\"@\");\n\t}\n\n\tif (components.host !== undefined) {\n\t\t//normalize IP hosts, add brackets and escape zone separator for IPv6\n\t\turiTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, (_, $1, $2) => \"[\" + $1 + ($2 ? \"%25\" + $2 : \"\") + \"]\"));\n\t}\n\n\tif (typeof components.port === \"number\" || typeof components.port === \"string\") {\n\t\turiTokens.push(\":\");\n\t\turiTokens.push(String(components.port));\n\t}\n\n\treturn uriTokens.length ? uriTokens.join(\"\") : undefined;\n};\n\nconst RDS1 = /^\\.\\.?\\//;\nconst RDS2 = /^\\/\\.(\\/|$)/;\nconst RDS3 = /^\\/\\.\\.(\\/|$)/;\nconst RDS4 = /^\\.\\.?$/;\nconst RDS5 = /^\\/?(?:.|\\n)*?(?=\\/|$)/;\n\nexport function removeDotSegments(input:string):string {\n\tconst output:Array<string> = [];\n\n\twhile (input.length) {\n\t\tif (input.match(RDS1)) {\n\t\t\tinput = input.replace(RDS1, \"\");\n\t\t} else if (input.match(RDS2)) {\n\t\t\tinput = input.replace(RDS2, \"/\");\n\t\t} else if (input.match(RDS3)) {\n\t\t\tinput = input.replace(RDS3, \"/\");\n\t\t\toutput.pop();\n\t\t} else if (input === \".\" || input === \"..\") {\n\t\t\tinput = \"\";\n\t\t} else {\n\t\t\tconst im = input.match(RDS5);\n\t\t\tif (im) {\n\t\t\t\tconst s = im[0];\n\t\t\t\tinput = input.slice(s.length);\n\t\t\t\toutput.push(s);\n\t\t\t} else {\n\t\t\t\tthrow new Error(\"Unexpected dot segment condition\");\n\t\t\t}\n\t\t}\n\t}\n\n\treturn output.join(\"\");\n};\n\nexport function serialize(components:URIComponents, options:URIOptions = {}):string {\n\tconst protocol = (options.iri ? IRI_PROTOCOL : URI_PROTOCOL);\n\tconst uriTokens:Array<string> = [];\n\n\t//find scheme handler\n\tconst schemeHandler = SCHEMES[(options.scheme || components.scheme || \"\").toLowerCase()];\n\n\t//perform scheme specific serialization\n\tif (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options);\n\n\tif (components.host) {\n\t\t//if host component is an IPv6 address\n\t\tif (protocol.IPV6ADDRESS.test(components.host)) {\n\t\t\t//TODO: normalize IPv6 address as per RFC 5952\n\t\t}\n\n\t\t//if host component is a domain name\n\t\telse if (options.domainHost || (schemeHandler && schemeHandler.domainHost)) {\n\t\t\t//convert IDN via punycode\n\t\t\ttry {\n\t\t\t\tcomponents.host = (!options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host));\n\t\t\t} catch (e) {\n\t\t\t\tcomponents.error = components.error || \"Host's domain name can not be converted to \" + (!options.iri ? \"ASCII\" : \"Unicode\") + \" via punycode: \" + e;\n\t\t\t}\n\t\t}\n\t}\n\n\t//normalize encoding\n\t_normalizeComponentEncoding(components, protocol);\n\n\tif (options.reference !== \"suffix\" && components.scheme) {\n\t\turiTokens.push(components.scheme);\n\t\turiTokens.push(\":\");\n\t}\n\n\tconst authority = _recomposeAuthority(components, options);\n\tif (authority !== undefined) {\n\t\tif (options.reference !== \"suffix\") {\n\t\t\turiTokens.push(\"//\");\n\t\t}\n\n\t\turiTokens.push(authority);\n\n\t\tif (components.path && components.path.charAt(0) !== \"/\") {\n\t\t\turiTokens.push(\"/\");\n\t\t}\n\t}\n\n\tif (components.path !== undefined) {\n\t\tlet s = components.path;\n\n\t\tif (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {\n\t\t\ts = removeDotSegments(s);\n\t\t}\n\n\t\tif (authority === undefined) {\n\t\t\ts = s.replace(/^\\/\\//, \"/%2F\");  //don't allow the path to start with \"//\"\n\t\t}\n\n\t\turiTokens.push(s);\n\t}\n\n\tif (components.query !== undefined) {\n\t\turiTokens.push(\"?\");\n\t\turiTokens.push(components.query);\n\t}\n\n\tif (components.fragment !== undefined) {\n\t\turiTokens.push(\"#\");\n\t\turiTokens.push(components.fragment);\n\t}\n\n\treturn uriTokens.join(\"\");  //merge tokens into a string\n};\n\nexport function resolveComponents(base:URIComponents, relative:URIComponents, options:URIOptions = {}, skipNormalization?:boolean):URIComponents {\n\tconst target:URIComponents = {};\n\n\tif (!skipNormalization) {\n\t\tbase = parse(serialize(base, options), options);  //normalize base components\n\t\trelative = parse(serialize(relative, options), options);  //normalize relative components\n\t}\n\toptions = options || {};\n\n\tif (!options.tolerant && relative.scheme) {\n\t\ttarget.scheme = relative.scheme;\n\t\t//target.authority = relative.authority;\n\t\ttarget.userinfo = relative.userinfo;\n\t\ttarget.host = relative.host;\n\t\ttarget.port = relative.port;\n\t\ttarget.path = removeDotSegments(relative.path || \"\");\n\t\ttarget.query = relative.query;\n\t} else {\n\t\tif (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {\n\t\t\t//target.authority = relative.authority;\n\t\t\ttarget.userinfo = relative.userinfo;\n\t\t\ttarget.host = relative.host;\n\t\t\ttarget.port = relative.port;\n\t\t\ttarget.path = removeDotSegments(relative.path || \"\");\n\t\t\ttarget.query = relative.query;\n\t\t} else {\n\t\t\tif (!relative.path) {\n\t\t\t\ttarget.path = base.path;\n\t\t\t\tif (relative.query !== undefined) {\n\t\t\t\t\ttarget.query = relative.query;\n\t\t\t\t} else {\n\t\t\t\t\ttarget.query = base.query;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (relative.path.charAt(0) === \"/\") {\n\t\t\t\t\ttarget.path = removeDotSegments(relative.path);\n\t\t\t\t} else {\n\t\t\t\t\tif ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) && !base.path) {\n\t\t\t\t\t\ttarget.path = \"/\" + relative.path;\n\t\t\t\t\t} else if (!base.path) {\n\t\t\t\t\t\ttarget.path = relative.path;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttarget.path = base.path.slice(0, base.path.lastIndexOf(\"/\") + 1) + relative.path;\n\t\t\t\t\t}\n\t\t\t\t\ttarget.path = removeDotSegments(target.path);\n\t\t\t\t}\n\t\t\t\ttarget.query = relative.query;\n\t\t\t}\n\t\t\t//target.authority = base.authority;\n\t\t\ttarget.userinfo = base.userinfo;\n\t\t\ttarget.host = base.host;\n\t\t\ttarget.port = base.port;\n\t\t}\n\t\ttarget.scheme = base.scheme;\n\t}\n\n\ttarget.fragment = relative.fragment;\n\n\treturn target;\n};\n\nexport function resolve(baseURI:string, relativeURI:string, options?:URIOptions):string {\n\tconst schemelessOptions = assign({ scheme : 'null' }, options);\n\treturn serialize(resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);\n};\n\nexport function normalize(uri:string, options?:URIOptions):string;\nexport function normalize(uri:URIComponents, options?:URIOptions):URIComponents;\nexport function normalize(uri:any, options?:URIOptions):any {\n\tif (typeof uri === \"string\") {\n\t\turi = serialize(parse(uri, options), options);\n\t} else if (typeOf(uri) === \"object\") {\n\t\turi = parse(serialize(<URIComponents>uri, options), options);\n\t}\n\n\treturn uri;\n};\n\nexport function equal(uriA:string, uriB:string, options?: URIOptions):boolean;\nexport function equal(uriA:URIComponents, uriB:URIComponents, options?:URIOptions):boolean;\nexport function equal(uriA:any, uriB:any, options?:URIOptions):boolean {\n\tif (typeof uriA === \"string\") {\n\t\turiA = serialize(parse(uriA, options), options);\n\t} else if (typeOf(uriA) === \"object\") {\n\t\turiA = serialize(<URIComponents>uriA, options);\n\t}\n\n\tif (typeof uriB === \"string\") {\n\t\turiB = serialize(parse(uriB, options), options);\n\t} else if (typeOf(uriB) === \"object\") {\n\t\turiB = serialize(<URIComponents>uriB, options);\n\t}\n\n\treturn uriA === uriB;\n};\n\nexport function escapeComponent(str:string, options?:URIOptions):string {\n\treturn str && str.toString().replace((!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE), pctEncChar);\n};\n\nexport function unescapeComponent(str:string, options?:URIOptions):string {\n\treturn str && str.toString().replace((!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED), pctDecChars);\n};\n","import { URISchemeHandler, URIComponents, URIOptions } from \"../uri\";\n\nconst handler:URISchemeHandler = {\n\tscheme : \"http\",\n\n\tdomainHost : true,\n\n\tparse : function (components:URIComponents, options:URIOptions):URIComponents {\n\t\t//report missing host\n\t\tif (!components.host) {\n\t\t\tcomponents.error = components.error || \"HTTP URIs must have a host.\";\n\t\t}\n\n\t\treturn components;\n\t},\n\n\tserialize : function (components:URIComponents, options:URIOptions):URIComponents {\n\t\tconst secure = String(components.scheme).toLowerCase() === \"https\";\n\n\t\t//normalize the default port\n\t\tif (components.port === (secure ? 443 : 80) || components.port === \"\") {\n\t\t\tcomponents.port = undefined;\n\t\t}\n\t\t\n\t\t//normalize the empty path\n\t\tif (!components.path) {\n\t\t\tcomponents.path = \"/\";\n\t\t}\n\n\t\t//NOTE: We do not parse query strings for HTTP URIs\n\t\t//as WWW Form Url Encoded query strings are part of the HTML4+ spec,\n\t\t//and not the HTTP spec.\n\n\t\treturn components;\n\t}\n};\n\nexport default handler;","import { URISchemeHandler, URIComponents, URIOptions } from \"../uri\";\nimport http from \"./http\";\n\nconst handler:URISchemeHandler = {\n\tscheme : \"https\",\n\tdomainHost : http.domainHost,\n\tparse : http.parse,\n\tserialize : http.serialize\n}\n\nexport default handler;","import { URISchemeHandler, URIComponents, URIOptions } from \"../uri\";\n\nexport interface WSComponents extends URIComponents {\n\tresourceName?: string;\n\tsecure?: boolean;\n}\n\nfunction isSecure(wsComponents:WSComponents):boolean {\n\treturn typeof wsComponents.secure === 'boolean' ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === \"wss\";\n}\n\n//RFC 6455\nconst handler:URISchemeHandler = {\n\tscheme : \"ws\",\n\n\tdomainHost : true,\n\n\tparse : function (components:URIComponents, options:URIOptions):WSComponents {\n\t\tconst wsComponents = components as WSComponents;\n\n\t\t//indicate if the secure flag is set\n\t\twsComponents.secure = isSecure(wsComponents);\n\n\t\t//construct resouce name\n\t\twsComponents.resourceName = (wsComponents.path || '/') + (wsComponents.query ? '?' + wsComponents.query : '');\n\t\twsComponents.path = undefined;\n\t\twsComponents.query = undefined;\n\n\t\treturn wsComponents;\n\t},\n\n\tserialize : function (wsComponents:WSComponents, options:URIOptions):URIComponents {\n\t\t//normalize the default port\n\t\tif (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === \"\") {\n\t\t\twsComponents.port = undefined;\n\t\t}\n\n\t\t//ensure scheme matches secure flag\n\t\tif (typeof wsComponents.secure === 'boolean') {\n\t\t\twsComponents.scheme = (wsComponents.secure ? 'wss' : 'ws');\n\t\t\twsComponents.secure = undefined;\n\t\t}\n\n\t\t//reconstruct path from resource name\n\t\tif (wsComponents.resourceName) {\n\t\t\tconst [path, query] = wsComponents.resourceName.split('?');\n\t\t\twsComponents.path = (path && path !== '/' ? path : undefined);\n\t\t\twsComponents.query = query;\n\t\t\twsComponents.resourceName = undefined;\n\t\t}\n\n\t\t//forbid fragment component\n\t\twsComponents.fragment = undefined;\n\n\t\treturn wsComponents;\n\t}\n};\n\nexport default handler;","import { URISchemeHandler, URIComponents, URIOptions } from \"../uri\";\nimport ws from \"./ws\";\n\nconst handler:URISchemeHandler = {\n\tscheme : \"wss\",\n\tdomainHost : ws.domainHost,\n\tparse : ws.parse,\n\tserialize : ws.serialize\n}\n\nexport default handler;","import { URISchemeHandler, URIComponents, URIOptions } from \"../uri\";\nimport { pctEncChar, pctDecChars, unescapeComponent } from \"../uri\";\nimport punycode from \"punycode\";\nimport { merge, subexp, toUpperCase, toArray } from \"../util\";\n\nexport interface MailtoHeaders {\n\t[hfname:string]:string\n}\n\nexport interface MailtoComponents extends URIComponents {\n\tto:Array<string>,\n\theaders?:MailtoHeaders,\n\tsubject?:string,\n\tbody?:string\n}\n\nconst O:MailtoHeaders = {};\nconst isIRI = true;\n\n//RFC 3986\nconst UNRESERVED$$ = \"[A-Za-z0-9\\\\-\\\\.\\\\_\\\\~\" + (isIRI ? \"\\\\xA0-\\\\u200D\\\\u2010-\\\\u2029\\\\u202F-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF\" : \"\") + \"]\";\nconst HEXDIG$$ = \"[0-9A-Fa-f]\";  //case-insensitive\nconst PCT_ENCODED$ = subexp(subexp(\"%[EFef]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%[89A-Fa-f]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%\" + HEXDIG$$ + HEXDIG$$));  //expanded\n\n//RFC 5322, except these symbols as per RFC 6068: @ : / ? # [ ] & ; =\n//const ATEXT$$ = \"[A-Za-z0-9\\\\!\\\\#\\\\$\\\\%\\\\&\\\\'\\\\*\\\\+\\\\-\\\\/\\\\=\\\\?\\\\^\\\\_\\\\`\\\\{\\\\|\\\\}\\\\~]\";\n//const WSP$$ = \"[\\\\x20\\\\x09]\";\n//const OBS_QTEXT$$ = \"[\\\\x01-\\\\x08\\\\x0B\\\\x0C\\\\x0E-\\\\x1F\\\\x7F]\";  //(%d1-8 / %d11-12 / %d14-31 / %d127)\n//const QTEXT$$ = merge(\"[\\\\x21\\\\x23-\\\\x5B\\\\x5D-\\\\x7E]\", OBS_QTEXT$$);  //%d33 / %d35-91 / %d93-126 / obs-qtext\n//const VCHAR$$ = \"[\\\\x21-\\\\x7E]\";\n//const WSP$$ = \"[\\\\x20\\\\x09]\";\n//const OBS_QP$ = subexp(\"\\\\\\\\\" + merge(\"[\\\\x00\\\\x0D\\\\x0A]\", OBS_QTEXT$$));  //%d0 / CR / LF / obs-qtext\n//const FWS$ = subexp(subexp(WSP$$ + \"*\" + \"\\\\x0D\\\\x0A\") + \"?\" + WSP$$ + \"+\");\n//const QUOTED_PAIR$ = subexp(subexp(\"\\\\\\\\\" + subexp(VCHAR$$ + \"|\" + WSP$$)) + \"|\" + OBS_QP$);\n//const QUOTED_STRING$ = subexp('\\\\\"' + subexp(FWS$ + \"?\" + QCONTENT$) + \"*\" + FWS$ + \"?\" + '\\\\\"');\nconst ATEXT$$ = \"[A-Za-z0-9\\\\!\\\\$\\\\%\\\\'\\\\*\\\\+\\\\-\\\\^\\\\_\\\\`\\\\{\\\\|\\\\}\\\\~]\";\nconst QTEXT$$ = \"[\\\\!\\\\$\\\\%\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\-\\\\.0-9\\\\<\\\\>A-Z\\\\x5E-\\\\x7E]\";\nconst VCHAR$$ = merge(QTEXT$$, \"[\\\\\\\"\\\\\\\\]\");\nconst DOT_ATOM_TEXT$ = subexp(ATEXT$$ + \"+\" + subexp(\"\\\\.\" + ATEXT$$ + \"+\") + \"*\");\nconst QUOTED_PAIR$ = subexp(\"\\\\\\\\\" + VCHAR$$);\nconst QCONTENT$ = subexp(QTEXT$$ + \"|\" + QUOTED_PAIR$);\nconst QUOTED_STRING$ = subexp('\\\\\"' + QCONTENT$ + \"*\" + '\\\\\"');\n\n//RFC 6068\nconst DTEXT_NO_OBS$$ = \"[\\\\x21-\\\\x5A\\\\x5E-\\\\x7E]\";  //%d33-90 / %d94-126\nconst SOME_DELIMS$$ = \"[\\\\!\\\\$\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\;\\\\:\\\\@]\";\nconst QCHAR$ = subexp(UNRESERVED$$ + \"|\" + PCT_ENCODED$ + \"|\" + SOME_DELIMS$$);\nconst DOMAIN$ = subexp(DOT_ATOM_TEXT$ + \"|\" + \"\\\\[\" + DTEXT_NO_OBS$$ + \"*\" + \"\\\\]\");\nconst LOCAL_PART$ = subexp(DOT_ATOM_TEXT$ + \"|\" + QUOTED_STRING$);\nconst ADDR_SPEC$ = subexp(LOCAL_PART$ + \"\\\\@\" + DOMAIN$);\nconst TO$ = subexp(ADDR_SPEC$ + subexp(\"\\\\,\" + ADDR_SPEC$) + \"*\");\nconst HFNAME$ = subexp(QCHAR$ + \"*\");\nconst HFVALUE$ = HFNAME$;\nconst HFIELD$ = subexp(HFNAME$ + \"\\\\=\" + HFVALUE$);\nconst HFIELDS2$ = subexp(HFIELD$ + subexp(\"\\\\&\" + HFIELD$) + \"*\");\nconst HFIELDS$ = subexp(\"\\\\?\" + HFIELDS2$);\nconst MAILTO_URI = new RegExp(\"^mailto\\\\:\" + TO$ + \"?\" + HFIELDS$ + \"?$\");\n\nconst UNRESERVED = new RegExp(UNRESERVED$$, \"g\");\nconst PCT_ENCODED = new RegExp(PCT_ENCODED$, \"g\");\nconst NOT_LOCAL_PART = new RegExp(merge(\"[^]\", ATEXT$$, \"[\\\\.]\", '[\\\\\"]', VCHAR$$), \"g\");\nconst NOT_DOMAIN = new RegExp(merge(\"[^]\", ATEXT$$, \"[\\\\.]\", \"[\\\\[]\", DTEXT_NO_OBS$$, \"[\\\\]]\"), \"g\");\nconst NOT_HFNAME = new RegExp(merge(\"[^]\", UNRESERVED$$, SOME_DELIMS$$), \"g\");\nconst NOT_HFVALUE = NOT_HFNAME;\nconst TO = new RegExp(\"^\" + TO$ + \"$\");\nconst HFIELDS = new RegExp(\"^\" + HFIELDS2$ + \"$\");\n\nfunction decodeUnreserved(str:string):string {\n\tconst decStr = pctDecChars(str);\n\treturn (!decStr.match(UNRESERVED) ? str : decStr);\n}\n\nconst handler:URISchemeHandler<MailtoComponents> =  {\n\tscheme : \"mailto\",\n\n\tparse : function (components:URIComponents, options:URIOptions):MailtoComponents {\n\t\tconst mailtoComponents = components as MailtoComponents;\n\t\tconst to = mailtoComponents.to = (mailtoComponents.path ? mailtoComponents.path.split(\",\") : []);\n\t\tmailtoComponents.path = undefined;\n\n\t\tif (mailtoComponents.query) {\n\t\t\tlet unknownHeaders = false\n\t\t\tconst headers:MailtoHeaders = {};\n\t\t\tconst hfields = mailtoComponents.query.split(\"&\");\n\n\t\t\tfor (let x = 0, xl = hfields.length; x < xl; ++x) {\n\t\t\t\tconst hfield = hfields[x].split(\"=\");\n\n\t\t\t\tswitch (hfield[0]) {\n\t\t\t\t\tcase \"to\":\n\t\t\t\t\t\tconst toAddrs = hfield[1].split(\",\");\n\t\t\t\t\t\tfor (let x = 0, xl = toAddrs.length; x < xl; ++x) {\n\t\t\t\t\t\t\tto.push(toAddrs[x]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"subject\":\n\t\t\t\t\t\tmailtoComponents.subject = unescapeComponent(hfield[1], options);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"body\":\n\t\t\t\t\t\tmailtoComponents.body = unescapeComponent(hfield[1], options);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tunknownHeaders = true;\n\t\t\t\t\t\theaders[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (unknownHeaders) mailtoComponents.headers = headers;\n\t\t}\n\n\t\tmailtoComponents.query = undefined;\n\n\t\tfor (let x = 0, xl = to.length; x < xl; ++x) {\n\t\t\tconst addr = to[x].split(\"@\");\n\n\t\t\taddr[0] = unescapeComponent(addr[0]);\n\n\t\t\tif (!options.unicodeSupport) {\n\t\t\t\t//convert Unicode IDN -> ASCII IDN\n\t\t\t\ttry {\n\t\t\t\t\taddr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());\n\t\t\t\t} catch (e) {\n\t\t\t\t\tmailtoComponents.error = mailtoComponents.error || \"Email address's domain name can not be converted to ASCII via punycode: \" + e;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\taddr[1] = unescapeComponent(addr[1], options).toLowerCase();\n\t\t\t}\n\n\t\t\tto[x] = addr.join(\"@\");\n\t\t}\n\n\t\treturn mailtoComponents;\n\t},\n\n\tserialize : function (mailtoComponents:MailtoComponents, options:URIOptions):URIComponents {\n\t\tconst components = mailtoComponents as URIComponents;\n\t\tconst to = toArray(mailtoComponents.to);\n\t\tif (to) {\n\t\t\tfor (let x = 0, xl = to.length; x < xl; ++x) {\n\t\t\t\tconst toAddr = String(to[x]);\n\t\t\t\tconst atIdx = toAddr.lastIndexOf(\"@\");\n\t\t\t\tconst localPart = (toAddr.slice(0, atIdx)).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);\n\t\t\t\tlet domain = toAddr.slice(atIdx + 1);\n\n\t\t\t\t//convert IDN via punycode\n\t\t\t\ttry {\n\t\t\t\t\tdomain = (!options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain));\n\t\t\t\t} catch (e) {\n\t\t\t\t\tcomponents.error = components.error || \"Email address's domain name can not be converted to \" + (!options.iri ? \"ASCII\" : \"Unicode\") + \" via punycode: \" + e;\n\t\t\t\t}\n\n\t\t\t\tto[x] = localPart + \"@\" + domain;\n\t\t\t}\n\n\t\t\tcomponents.path = to.join(\",\");\n\t\t}\n\n\t\tconst headers = mailtoComponents.headers = mailtoComponents.headers || {};\n\n\t\tif (mailtoComponents.subject) headers[\"subject\"] = mailtoComponents.subject;\n\t\tif (mailtoComponents.body) headers[\"body\"] = mailtoComponents.body;\n\n\t\tconst fields = [];\n\t\tfor (const name in headers) {\n\t\t\tif (headers[name] !== O[name]) {\n\t\t\t\tfields.push(\n\t\t\t\t\tname.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) +\n\t\t\t\t\t\"=\" +\n\t\t\t\t\theaders[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar)\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tif (fields.length) {\n\t\t\tcomponents.query = fields.join(\"&\");\n\t\t}\n\n\t\treturn components;\n\t}\n}\n\nexport default handler;","import { URISchemeHandler, URIComponents, URIOptions } from \"../uri\";\nimport { pctEncChar, SCHEMES } from \"../uri\";\n\nexport interface URNComponents extends URIComponents {\n\tnid?:string;\n\tnss?:string;\n}\n\nexport interface URNOptions extends URIOptions {\n\tnid?:string;\n}\n\nconst NID$ = \"(?:[0-9A-Za-z][0-9A-Za-z\\\\-]{1,31})\";\nconst PCT_ENCODED$ = \"(?:\\\\%[0-9A-Fa-f]{2})\";\nconst TRANS$$ = \"[0-9A-Za-z\\\\(\\\\)\\\\+\\\\,\\\\-\\\\.\\\\:\\\\=\\\\@\\\\;\\\\$\\\\_\\\\!\\\\*\\\\'\\\\/\\\\?\\\\#]\";\nconst NSS$ = \"(?:(?:\" + PCT_ENCODED$ + \"|\" + TRANS$$ + \")+)\";\nconst URN_SCHEME = new RegExp(\"^urn\\\\:(\" + NID$ + \")$\");\nconst URN_PATH = new RegExp(\"^(\" + NID$ + \")\\\\:(\" + NSS$ + \")$\");\nconst URN_PARSE = /^([^\\:]+)\\:(.*)/;\nconst URN_EXCLUDED = /[\\x00-\\x20\\\\\\\"\\&\\<\\>\\[\\]\\^\\`\\{\\|\\}\\~\\x7F-\\xFF]/g;\n\n//RFC 2141\nconst handler:URISchemeHandler<URNComponents,URNOptions> = {\n\tscheme : \"urn\",\n\n\tparse : function (components:URIComponents, options:URNOptions):URNComponents {\n\t\tconst matches = components.path && components.path.match(URN_PARSE);\n\t\tlet urnComponents = components as URNComponents;\n\n\t\tif (matches) {\n\t\t\tconst scheme = options.scheme || urnComponents.scheme || \"urn\";\n\t\t\tconst nid = matches[1].toLowerCase();\n\t\t\tconst nss = matches[2];\n\t\t\tconst urnScheme = `${scheme}:${options.nid || nid}`;\n\t\t\tconst schemeHandler = SCHEMES[urnScheme];\n\n\t\t\turnComponents.nid = nid;\n\t\t\turnComponents.nss = nss;\n\t\t\turnComponents.path = undefined;\n\n\t\t\tif (schemeHandler) {\n\t\t\t\turnComponents = schemeHandler.parse(urnComponents, options) as URNComponents;\n\t\t\t}\n\t\t} else {\n\t\t\turnComponents.error = urnComponents.error || \"URN can not be parsed.\";\n\t\t}\n\n\t\treturn urnComponents;\n\t},\n\n\tserialize : function (urnComponents:URNComponents, options:URNOptions):URIComponents {\n\t\tconst scheme = options.scheme || urnComponents.scheme || \"urn\";\n\t\tconst nid = urnComponents.nid;\n\t\tconst urnScheme = `${scheme}:${options.nid || nid}`;\n\t\tconst schemeHandler = SCHEMES[urnScheme];\n\n\t\tif (schemeHandler) {\n\t\t\turnComponents = schemeHandler.serialize(urnComponents, options) as URNComponents;\n\t\t}\n\n\t\tconst uriComponents = urnComponents as URIComponents;\n\t\tconst nss = urnComponents.nss;\n\t\turiComponents.path = `${nid || options.nid}:${nss}`;\n\n\t\treturn uriComponents;\n\t},\n};\n\nexport default handler;","import { URISchemeHandler, URIComponents, URIOptions } from \"../uri\";\nimport { URNComponents } from \"./urn\";\nimport { SCHEMES } from \"../uri\";\n\nexport interface UUIDComponents extends URNComponents {\n\tuuid?: string;\n}\n\nconst UUID = /^[0-9A-Fa-f]{8}(?:\\-[0-9A-Fa-f]{4}){3}\\-[0-9A-Fa-f]{12}$/;\nconst UUID_PARSE = /^[0-9A-Fa-f\\-]{36}/;\n\n//RFC 4122\nconst handler:URISchemeHandler<UUIDComponents, URIOptions, URNComponents> = {\n\tscheme : \"urn:uuid\",\n\n\tparse : function (urnComponents:URNComponents, options:URIOptions):UUIDComponents {\n\t\tconst uuidComponents = urnComponents as UUIDComponents;\n\t\tuuidComponents.uuid = uuidComponents.nss;\n\t\tuuidComponents.nss = undefined;\n\n\t\tif (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))) {\n\t\t\tuuidComponents.error = uuidComponents.error || \"UUID is not valid.\";\n\t\t}\n\n\t\treturn uuidComponents;\n\t},\n\n\tserialize : function (uuidComponents:UUIDComponents, options:URIOptions):URNComponents {\n\t\tconst urnComponents = uuidComponents as URNComponents;\n\t\t//normalize UUID\n\t\turnComponents.nss = (uuidComponents.uuid || \"\").toLowerCase();\n\t\treturn urnComponents;\n\t},\n};\n\nexport default handler;","import { SCHEMES } from \"./uri\";\n\nimport http from \"./schemes/http\";\nSCHEMES[http.scheme] = http;\n\nimport https from \"./schemes/https\";\nSCHEMES[https.scheme] = https;\n\nimport ws from \"./schemes/ws\";\nSCHEMES[ws.scheme] = ws;\n\nimport wss from \"./schemes/wss\";\nSCHEMES[wss.scheme] = wss;\n\nimport mailto from \"./schemes/mailto\";\nSCHEMES[mailto.scheme] = mailto;\n\nimport urn from \"./schemes/urn\";\nSCHEMES[urn.scheme] = urn;\n\nimport uuid from \"./schemes/urn-uuid\";\nSCHEMES[uuid.scheme] = uuid;\n\nexport * from \"./uri\";\n","function _taggedTemplateLiteral(strings, raw) {\n  if (!raw) {\n    raw = strings.slice(0);\n  }\n  return Object.freeze(Object.defineProperties(strings, {\n    raw: {\n      value: Object.freeze(raw)\n    }\n  }));\n}\nmodule.exports = _taggedTemplateLiteral, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;"],"names":["core_1","require","draft7_1","discriminator_1","draft7MetaSchema","META_SUPPORT_DATA","META_SCHEMA_ID","Ajv","_core_1$default","_inherits","_super","_createSuper","_classCallCheck","apply","arguments","_createClass","key","value","_this","_get","_getPrototypeOf","prototype","call","default","forEach","v","addVocabulary","this","opts","discriminator","addKeyword","meta","metaSchema","$data","$dataMetaSchema","addMetaSchema","refs","defaultMeta","getSchema","undefined","module","exports","Object","defineProperty","validate_1","enumerable","get","KeywordCxt","codegen_1","_","str","stringify","nil","Name","CodeGen","validation_error_1","ref_error_1","_CodeOrName","_CodeOrName2","s","IDENTIFIER","test","Error","_defineProperty","_Code","_CodeOrName3","_super2","code","_this2","_items","length","item","_a","_str","reduce","c","concat","_names","names","strs","i","_len","args","Array","_key","addCodeArg","push","plus","expr","safeStringify","_len2","_key2","res","mergeExprItems","splice","optimize","arg","x","_toConsumableArray","isArray","join","a","b","slice","JSON","replace","c1","c2","emptyStr","_templateObject","_taggedTemplateLiteral","_templateObject2","rx","toString","code_1","scope_1","code_2","strConcat","getProperty","regexpCode","scope_2","Scope","ValueScope","ValueScopeName","varKinds","GT","GTE","LT","LTE","EQ","NEQ","NOT","OR","AND","ADD","Node","_constants","Def","_Node","varKind","name","rhs","_ref","es5","_n","var","constants","optimizeExpr","Assign","_Node2","lhs","sideEffects","_ref2","addExprNames","_objectSpread","AssignOp","_Assign","_super3","op","_this3","_ref3","Label","_Node3","_super4","label","_this4","_ref4","Break","_Node4","_super5","_this5","_ref5","Throw","_Node5","_super6","error","_this6","_ref6","AnyCode","_Node6","_super7","_this7","_ref7","ParentNode","_Node7","_super8","_this8","nodes","n","render","optimizeNodes","optimizeNames","subtractNames","addNames","BlockNode","_ParentNode","_super9","Root","_ParentNode2","_super10","Else","_BlockNode","_super11","kind","If","_BlockNode2","_super12","condition","_this9","else","cond","e","ns","not","For","_BlockNode3","_super13","ForLoop","_For","_super14","iteration","_this10","ForRange","_For2","_super15","from","to","_this11","ForIter","_For3","_super16","loop","iterable","_this12","Func","_BlockNode4","_super17","async","_this13","_async","Return","_ParentNode3","_super18","Try","_BlockNode5","_super19","catch","finally","_b","Catch","_BlockNode6","_super20","_this14","Finally","_BlockNode7","_super21","extScope","_values","_blockStarts","lines","_extScope","_scope","parent","_nodes","_root","prefix","prefixOrName","Set","add","keyOrRef","getValue","scopeName","scopeRefs","scopeCode","nameOrPrefix","constant","toName","_leafNode","_constant","_def","const","let","operators","keyValues","_i","_keyValues","_keyValues$_i","_slicedToArray","thenBody","elseBody","_blockNode","endIf","_elseNode","_endBlockNode","node","forBody","endFor","_for","_this15","arr","forRange","obj","ownProperties","forOf","_templateObject3","tryBody","catchCode","finallyCode","_currNode","body","nodeCount","endBlock","len","pop","toClose","funcBody","endFunc","N1","N2","set","replaceName","some","items","_templateObject4","par","andCode","mappend","orCode","y","_templateObject5","_templateObject6","_len3","_key3","UsedValueState","ValueError","_Error","_wrapNativeSuper","prefixes","_prefixes","_parent","_newName","ng","_nameGroup","index","has","_code_1$Name","nameStr","property","itemIndex","scopePath","line","_Scope","scope","ref","valueKey","vs","_name","Map","setValue","values","_reduceValues","usedValues","getCode","valueCode","_loop","nameSet","Started","def","Completed","util_1","names_1","addError","gen","errObj","err","if","_templateObject14","vErrors","assign","_templateObject15","_templateObject16","_templateObject17","errors","returnErrors","it","errs","validateName","schemaEnv","$async","throw","_templateObject18","ValidationError","_templateObject19","return","message","keyword","schemaType","cxt","keywordError","errorPaths","overrideAllErrors","compositeRule","allErrors","errorObjectCode","errsCount","schemaValue","data","_templateObject7","_templateObject8","_templateObject9","instancePath","errorPath","_templateObject10","_templateObject11","errSchemaPath","verbose","_templateObject12","_templateObject13","E","schemaPath","params","propertyName","schema","parentSchema","createErrors","_templateObject20","errorInstancePath","errorSchemaPath","_ref8","topSchemaRef","_templateObject24","messages","_templateObject25","extraErrorProps","object","errorObject","instPath","_templateObject21","getErrorPath","Type","Str","schPath","_templateObject22","_templateObject23","resolve_1","SchemaEnv","env","dynamicAnchors","schemaId","root","baseId","normalizeId","localRefs","compileSchema","sch","_sch","getCompilingSchema","_ValidationError","rootId","getFullPath","uriResolver","_this$opts$code","scopeValue","sourceCode","schemaCxt","parentData","parentDataProperty","dataNames","dataPathArr","dataLevel","dataTypes","definedProperties","source","jtd","self","_compilations","validateFunctionCode","validateCode","process","validate","Function","makeValidate","scopeValues","unevaluated","props","evaluated","dynamicProps","dynamicItems","logger","delete","inlineOrCompile","inlineRef","inlineRefs","schEnv","_step","s1","s2","_iterator","_createForOfIteratorHelper","done","f","resolve","schemas","resolveSchema","p","parse","refPath","_getFullPath","keys","getJsonPointer","id","schOrRef","schId","resolveUrl","schOrFunc","PREVENT_SCOPE_CHANGE","parsedRef","fragment","_step2","_iterator2","split","part","partSchema","unescapeFragment","$ref","schemaHasRulesButRef","RULES","valCxt","rootData","json","jsonPos","jsonLen","jsonPart","MissingRefError","resolver","msg","missingRef","missingSchema","equal","traverse","SIMPLE_INLINED","limit","hasRef","countKeys","REF_KEYWORDS","count","Infinity","eachItem","serialize","TRAILING_SLASH_HASH","ANCHOR","_this$opts","baseIds","pathPrefix","schemaRefs","allKeys","jsonPtr","parentJsonPtr","fullPath","addRef","addAnchor","$anchor","$dynamicAnchor","_resolve","ambiguos","checkAmbiguosRef","anchor","sch1","sch2","jsonTypes","groups","number","type","rules","string","array","types","integer","boolean","null","post","all","keywords","checkUnknownRules","strictSchema","checkStrictMode","schemaHasRules","escapeJsonPointer","unescapeJsonPointer","makeMergeEvaluated","mergeNames","mergeToName","mergeValues","resultToName","evaluatedPropsToName","ps","setEvaluated","hash","decodeURIComponent","encodeURIComponent","xs","Math","max","snippets","mode","warn","dataProp","dataPropType","jsPropertySyntax","isNumber","Num","shouldUseGroup","group","rule","shouldUseRule","definition","implements","kwd","errors_1","boolError","falseSchemaError","schemaCode","reportError","valid","DataType","rules_1","applicability_1","getJSONTypes","ts","every","isJSONType","includes","nullable","coerceTo","coerceTypes","filter","t","COERCIBLE","coerceToTypes","checkTypes","schemaHasRulesForType","wrongType","checkDataTypes","strictNumbers","Wrong","dataType","coerced","coerceSpecificType","elseIf","reportTypeError","assignParentData","coerceData","checkDataType","strictNums","correct","Correct","numCond","_templateObject26","_templateObject27","_cond","and","_templateObject28","_templateObject29","toHash","notObj","_templateObject30","_templateObject31","typeError","_templateObject32","_templateObject33","schemaRefOrVal","getTypeErrorContext","assignDefault","prop","defaultValue","childData","useDefaults","ty","_it$schema","properties","boolSchema_1","dataType_1","dataType_2","defaults_1","keyword_1","subschema_1","validateFunction","func","funcSourceUrl","dynamicRef","destructureValCxtES5","destructureValCxt","subschemaCode","isSchemaObj","checkKeywords","schemaCxtHasRules","$comment","commentKeyword","updateContext","checkAsyncSchema","typeAndKeywords","subSchemaObjCode","boolOrEmptySchema","ignoreKeywordsWithRef","checkRefsAndKeywords","schemaKeywords","getSchemaTypes","coerceAndCheckDataType","rootName","typeErrors","groupKeywords","iterateKeywords","strictTypes","includesType","strictTypesError","withTypes","_step3","_iterator3","narrowSchemaTypes","checkContextTypes","allowUnionTypes","checkMultipleTypes","hasApplicableType","checkKeywordTypes","checkStrictTypes","block","keywordCode","assignDefaults","schTs","kwdT","checkNoDefault","resetEvaluated","assignEvaluated","returnResults","topSchemaObjCode","topBoolOrEmptySchema","validateKeywordUsage","getData","validSchemaType","allowUndefined","trackErrors","successAction","failAction","failResult","fail","_templateObject34","or","invalid$data","append","errorParams","setParams","_error","reportExtraError","$dataError","keyword$DataError","resetErrorsCount","codeBlock","$dataValid","check$data","_templateObject35","validateSchema","st","_templateObject36","wrong$DataType","validateSchemaRef","_templateObject37","invalid$DataSchema","appl","subschema","getSubschema","extendSubschemaData","extendSubschemaMode","nextContext","mergeEvaluated","ruleType","funcKeywordCode","macroKeywordCode","compile","JSON_POINTER","RELATIVE_JSON_POINTER","jsonPointer","matches","exec","up","errorMsg","_step4","segments","_iterator4","segment","_templateObject38","_templateObject39","pointerType","modifyData","useKeyword","result","macroSchema","macro","schemaRef","pass","checkAsyncKeyword","validateRef","assignValid","_await","passCxt","passContext","passSchema","callValidateCode","modifying","reportErrs","block$data","ruleErrs","try","validateAsync","validateErrs","validateSync","extendErrors","addErrs","ok","deps","dependencies","hasOwnProperty","errorsText","schemaProp","escapeFragment","dpType","dataContextProps","_nextData","jtdDiscriminator","jtdMetadata","compile_1","codegen_2","$dataRefSchema","uri_1","defaultRegExp","flags","RegExp","META_IGNORE_OPTIONS","EXT_SCOPE_NAMES","removedOptions","errorDataPath","format","jsonPointers","extendRefs","missingRefs","processCode","strictDefaults","strictKeywords","uniqueItems","unknownFormats","cache","ajvErrors","deprecatedOptions","unicode","formats","_loading","_cache","o","strict","_optz","regExp","_c","_d","_f","_e","_h","_g","_k","_j","strictTuples","_m","_l","strictRequired","_p","_o","loopRequired","_q","loopEnum","_r","_s","_t","_u","_v","addUsedSchema","_w","_x","validateFormats","_y","unicodeRegExp","_z","int32range","_0","requiredOptions","noLogs","console","log","getLogger","formatOpt","getRules","checkOptions","_metaOpts","getMetaSchemaOptions","addInitialFormats","_addVocabularies","_addDefaultMetaSchema","addInitialKeywords","addInitialSchemas","_dataRefSchema","$id","_this$opts2","schemaKeyRef","_meta","_addSchema","_compileSchemaEnv","loadSchema","runCompileAsync","_x2","_x3","_runCompileAsync","_asyncToGenerator","_regeneratorRuntime","mark","_callee","_schema","wrap","_context","prev","next","loadMetaSchema","$schema","abrupt","_compileAsync","stop","_x4","_loadMetaSchema","_callee2","_context2","_x5","_compileAsync2","_callee3","_context3","t0","checkLoaded","loadMissingSchema","_x6","_loadMissingSchema","_callee4","_context4","_loadSchema","sent","addSchema","_x7","_loadSchema2","_callee5","_context5","finish","_validateSchema","_checkUnique","throwOrLogError","keyRef","getSchEnv","_removeAllSchemas","clear","cacheKey","definitions","kwdOrDef","checkKeyword","addRule","keywordMetaschema","k","findIndex","_ref2$separator","separator","_ref2$dataVar","dataVar","map","text","keywordsJsonPointers","_step5","_iterator5","schemaOrData","regex","getSchemaRefs","startsWith","_compileMetaSchema","currentOpts","checkOpts","options","opt","optsSchemas","addFormat","defs","_step6","metaOpts","_iterator6","KEYWORD_NAME","ruleGroup","find","before","addBeforeRule","_rule","$dataRef","anyOf","ucs2length","pos","charCodeAt","uri","ajv","validation","validateAdditionalItems","alwaysValidSchema","break","validateItems","additionalProperty","removeAdditional","allSchemaProperties","patProps","patternProperties","forIn","definedProp","propsSchema","isOwnProperty","usePattern","isAdditional","additionalPropertyCode","deleteAdditional","applyAdditionalSchema","reset","schCxt","validateUnion","_ref$params","min","_ref2$params","minContains","maxContains","validateItemsWithCount","schValid","checkLimits","_valid","depsCount","property_ies","missingProperty","_splitDependencies","propertyDeps","schemaDeps","splitDependencies","_splitDependencies2","propDeps","schDeps","validatePropertyDeps","validateSchemaDeps","missing","hasProperty","propertyInData","depProp","checkReportMissingProp","checkMissingProp","reportMissingProp","_loop2","mergeValidEvaluated","ifClause","then","hasThen","hasSchema","hasElse","validateIf","validateClause","additionalItems_1","prefixItems_1","items_1","items2020_1","contains_1","dependencies_1","propertyNames_1","additionalProperties_1","properties_1","patternProperties_1","not_1","anyOf_1","oneOf_1","allOf_1","if_1","thenElse_1","draft2020","applicator","validateTuple","validateArray","extraItems","schArr","l","fullTuple","minItems","maxItems","checkStrictTuple","prefixItems","passing","util_2","patterns","alwaysValidPatterns","checkProperties","allowMatchingProperties","pat","checkMatchingProperties","validateProperties","validatePatternProperties","alwaysValid","additionalProperties","allProps","hasDefault","applyPropertySchema","hasPropFunc","noPropertyInData","schemaMap","context","_ref2$it","dataAndSchema","newRegExp","pattern","u","useFunc","validArr","notValid","id_1","ref_1","core","callRef","callRootRef","schOrEnv","resolveRef","getValidate","callValidate","schName","inlineRefSchema","addErrorsFrom","addEvaluatedFrom","schEvaluated","callAsyncRef","types_1","discrError","tagName","DiscrError","Tag","tag","oneOf","mapping","applyTagSchema","oneOfMapping","topRequired","hasRequired","tagRequired","propSch","addMappings","required","addMapping","enum","tagValue","getMapping","Mapping","validateMapping","validation_1","applicator_1","format_1","metadata_1","draft7Vocabularies","metadataVocabulary","contentVocabulary","fmts","fDef","fType","fail$data","callFormat","validData","invalidFmt","validate$DataFormat","formatDef","unknownMsg","unknownFormat","_getFormat","fmtDef","fmt","getFormat","_getFormat2","fmtType","fmtRef","validCondition","validateFormat","equal_1","eql","useLoop","getEql","vSchema","equalCode","limitNumber_1","multipleOf_1","limitLength_1","pattern_1","limitProperties_1","required_1","limitItems_1","uniqueItems_1","const_1","enum_1","comp","ucs2length_1","ops","KWDs","maximum","okStr","minimum","exclusiveMaximum","exclusiveMinimum","prec","multipleOfPrecision","invalid","loopAllRequired","allErrorsMode","loopUntilMissing","exitOnErrorMode","requiredKey","j","itemTypes","loopN","loopN2","indices","for","outer","cb","_traverse","pre","rootSchema","parentKeyword","keyIndex","arrayKeywords","propsKeywords","skipKeywords","additionalItems","contains","propertyNames","allOf","$defs","multipleOf","maxLength","minLength","maxProperties","minProperties","constructor","valueOf","merge","sets","xl","subexp","typeOf","shift","toLowerCase","toUpperCase","toArray","setInterval","target","buildExps","isIRI","ALPHA$$","DIGIT$$","HEXDIG$$","PCT_ENCODED$","SUB_DELIMS$$","RESERVED$$","SCHEME$","USERINFO$","UNRESERVED$$","DEC_OCTET_RELAXED$","H16$","LS32$","IPV4ADDRESS$","IPV6ADDRESS1$","IPV6ADDRESS2$","IPV6ADDRESS3$","IPV6ADDRESS4$","IPV6ADDRESS5$","IPV6ADDRESS6$","IPV6ADDRESS7$","IPV6ADDRESS8$","IPV6ADDRESS9$","ZONEID$","IPV6ADDRESS$","IP_LITERAL$","IPV6ADDRZ_RELAXED$","IPVFUTURE$","HOST$","REG_NAME$","PORT$","AUTHORITY$","PCHAR$","SEGMENT$","SEGMENT_NZ$","SEGMENT_NZ_NC$","PATH_ABEMPTY$","PATH_ABSOLUTE$","QUERY$","PATH_NOSCHEME$","PATH_ROOTLESS$","PATH_EMPTY$","IPRIVATE$$","FRAGMENT$","HIER_PART$","URI$","RELATIVE_PART$","RELATIVE$","URI_PROTOCOL","IRI_PROTOCOL","maxInt","base","tMin","tMax","skew","damp","initialBias","initialN","delimiter","regexPunycode","regexNonASCII","regexSeparators","baseMinusTMin","floor","stringFromCharCode","String","fromCharCode","error$1","RangeError","fn","mapDomain","parts","ucs2decode","output","counter","extra","basicToDigit","codePoint","digitToBasic","digit","flag","adapt","delta","numPoints","firstTime","decode","input","inputLength","bias","basic","lastIndexOf","oldi","w","baseMinusT","out","fromCodePoint","encode","Symbol","iterator","_iteratorNormalCompletion","_currentValue2","basicLength","handledCPCount","m","_iteratorNormalCompletion2","currentValue","handledCPCountPlusOne","_iteratorNormalCompletion3","_currentValue","q","qMinusT","toUnicode","toASCII","punycode","toConsumableArray","SCHEMES","pctEncChar","chr","pctDecChars","newStr","il","parseInt","substr","c3","_normalizeComponentEncoding","components","protocol","decodeUnreserved","decStr","match","UNRESERVED","scheme","PCT_ENCODED","NOT_SCHEME","userinfo","NOT_USERINFO","host","NOT_HOST","path","NOT_PATH","NOT_PATH_NOSCHEME","query","NOT_QUERY","NOT_FRAGMENT","_stripLeadingZeros","_normalizeIPv4","IPV4ADDRESS","address","_normalizeIPv6","IPV6ADDRESS","_matches2","zone","reverse","last","_address$toLowerCase$2","first","firstFields","lastFields","isLastFieldIPv4Address","fieldCount","lastFieldsStart","fields","longestZeroFields","acc","field","lastLongest","sort","newHost","newFirst","newLast","URI_PARSE","NO_MATCH_IS_UNDEFINED","uriString","iri","reference","port","isNaN","indexOf","schemeHandler","unicodeSupport","domainHost","_recomposeAuthority","uriTokens","$1","$2","RDS1","RDS2","RDS3","RDS5","removeDotSegments","im","authority","charAt","absolutePath","resolveComponents","relative","tolerant","baseURI","relativeURI","schemelessOptions","normalize","uriA","uriB","escapeComponent","ESCAPE","unescapeComponent","handler","secure","handler$1","isSecure","wsComponents","handler$2","resourceName","_wsComponents$resourc2","handler$3","O","ATEXT$$","VCHAR$$","SOME_DELIMS$$","NOT_LOCAL_PART","NOT_HFNAME","NOT_HFVALUE","handler$4","mailtoComponents","unknownHeaders","headers","hfields","hfield","toAddrs","_xl","subject","_xl2","addr","toAddr","atIdx","localPart","domain","URN_PARSE","handler$5","urnComponents","nid","nss","urnScheme","uriComponents","UUID","handler$6","uuidComponents","uuid","strings","raw","freeze","defineProperties","__esModule"],"sourceRoot":""}